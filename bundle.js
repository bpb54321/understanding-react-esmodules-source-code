var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// dist/shared/ReactFeatureFlags.js
var enableHydrationLaneScheduling = true;
var favorSafetyOverHydrationPerf = true;
var disableSchedulerTimeoutInWorkLoop = false;
var disableDefaultPropsExceptForClasses = true;
var enableSuspenseCallback = false;
var enableScopeAPI = false;
var enableCreateEventHandleAPI = false;
var enableLegacyFBSupport = false;
var enableYieldingBeforePassive = false;
var enableThrottledScheduling = false;
var enableLegacyCache = false;
var enableAsyncIterableChildren = false;
var enablePostpone = false;
var enableViewTransition = false;
var enableGestureTransition = false;
var enableScrollEndPolyfill = false;
var enableSuspenseyImages = false;
var enableSrcObject = false;
var enableHydrationChangeEvent = false;
var enableDefaultTransitionIndicator = false;
var enableObjectFiber = false;
var enableTransitionTracing = false;
var enableLegacyHidden = false;
var enableSuspenseAvoidThisFallback = false;
var enableCPUSuspense = false;
var enableNoCloningMemoCache = false;
var enableUseEffectEventHook = false;
var alwaysThrottleRetries = true;
var passChildrenWhenCloningPersistedNodes = false;
var enablePersistedModeClonedFlag = false;
var enableEagerAlternateStateNodeCleanup = true;
var enableRetryLaneExpiration = false;
var retryLaneExpirationMs = 5e3;
var syncLaneExpirationMs = 250;
var transitionLaneExpirationMs = 5e3;
var enableInfiniteRenderLoopDetection = false;
var enableFragmentRefs = false;
var renameElementSymbol = true;
var enableHiddenSubtreeInsertionEffectCleanup = false;
var disableLegacyContext = true;
var disableLegacyContextForFunctionComponents = true;
var enableMoveBefore = false;
var disableLegacyMode = true;
var enableRenderableContext = true;
var disableCommentsAsDOMContainers = true;
var enableTrustedTypesIntegration = false;
var disableInputAttributeSyncing = false;
var disableTextareaChildren = false;
var enableProfilerTimer = false;
var enableComponentPerformanceTrack = false;
var enableSchedulingProfiler = !enableComponentPerformanceTrack && false;
var enableProfilerCommitHooks = false;
var enableProfilerNestedUpdatePhase = false;
var enableUpdaterTracking = false;
var enableDO_NOT_USE_disableStrictPassiveEffect = false;

// dist/react-dom-bindings/src/client/HTMLNodeType.js
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

// dist/react-dom-bindings/src/client/ReactDOMContainer.js
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers && node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
}

// dist/scheduler/index.js
var scheduler_exports = {};
__export(scheduler_exports, {
  unstable_IdlePriority: () => IdlePriority,
  unstable_ImmediatePriority: () => ImmediatePriority,
  unstable_LowPriority: () => LowPriority,
  unstable_NormalPriority: () => NormalPriority,
  unstable_Profiling: () => unstable_Profiling,
  unstable_UserBlockingPriority: () => UserBlockingPriority,
  unstable_cancelCallback: () => unstable_cancelCallback,
  unstable_forceFrameRate: () => forceFrameRate,
  unstable_getCurrentPriorityLevel: () => unstable_getCurrentPriorityLevel,
  unstable_next: () => unstable_next,
  unstable_now: () => getCurrentTime,
  unstable_requestPaint: () => requestPaint,
  unstable_runWithPriority: () => unstable_runWithPriority,
  unstable_scheduleCallback: () => unstable_scheduleCallback,
  unstable_shouldYield: () => shouldYieldToHost,
  unstable_wrapCallback: () => unstable_wrapCallback
});

// dist/scheduler/src/SchedulerFeatureFlags.js
var enableProfiling = false;
var frameYieldMs = 5;
var userBlockingPriorityTimeout = 250;
var normalPriorityTimeout = 5e3;
var lowPriorityTimeout = 1e4;
var enableRequestPaint = true;
var enableAlwaysYieldScheduler = false;

// dist/scheduler/src/SchedulerMinHeap.js
function push(heap, node) {
  const index2 = heap.length;
  heap.push(node);
  siftUp(heap, node, index2);
}
function peek(heap) {
  return heap.length === 0 ? null : heap[0];
}
function pop(heap) {
  if (heap.length === 0) {
    return null;
  }
  const first = heap[0];
  const last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    siftDown(heap, last, 0);
  }
  return first;
}
function siftUp(heap, node, i) {
  let index2 = i;
  while (index2 > 0) {
    const parentIndex = index2 - 1 >>> 1;
    const parent = heap[parentIndex];
    if (compare(parent, node) > 0) {
      heap[parentIndex] = node;
      heap[index2] = parent;
      index2 = parentIndex;
    } else {
      return;
    }
  }
}
function siftDown(heap, node, i) {
  let index2 = i;
  const length = heap.length;
  const halfLength = length >>> 1;
  while (index2 < halfLength) {
    const leftIndex = (index2 + 1) * 2 - 1;
    const left = heap[leftIndex];
    const rightIndex = leftIndex + 1;
    const right = heap[rightIndex];
    if (compare(left, node) < 0) {
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index2] = right;
        heap[rightIndex] = node;
        index2 = rightIndex;
      } else {
        heap[index2] = left;
        heap[leftIndex] = node;
        index2 = leftIndex;
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index2] = right;
      heap[rightIndex] = node;
      index2 = rightIndex;
    } else {
      return;
    }
  }
}
function compare(a, b) {
  const diff = a.sortIndex - b.sortIndex;
  return diff !== 0 ? diff : a.id - b.id;
}

// dist/scheduler/src/SchedulerPriorities.js
var ImmediatePriority = 1;
var UserBlockingPriority = 2;
var NormalPriority = 3;
var LowPriority = 4;
var IdlePriority = 5;

// dist/scheduler/src/SchedulerProfiling.js
var runIdCounter = 0;
var mainThreadIdCounter = 0;
var INITIAL_EVENT_LOG_SIZE = 131072;
var MAX_EVENT_LOG_SIZE = 524288;
var eventLogSize = 0;
var eventLogBuffer = null;
var eventLog = null;
var eventLogIndex = 0;
var TaskStartEvent = 1;
var TaskCompleteEvent = 2;
var TaskErrorEvent = 3;
var TaskCancelEvent = 4;
var TaskRunEvent = 5;
var TaskYieldEvent = 6;
var SchedulerSuspendEvent = 7;
var SchedulerResumeEvent = 8;
function logEvent(entries) {
  if (eventLog !== null) {
    const offset = eventLogIndex;
    eventLogIndex += entries.length;
    if (eventLogIndex + 1 > eventLogSize) {
      eventLogSize *= 2;
      if (eventLogSize > MAX_EVENT_LOG_SIZE) {
        console["error"](
          "Scheduler Profiling: Event log exceeded maximum size. Don't forget to call `stopLoggingProfilingEvents()`."
        );
        stopLoggingProfilingEvents();
        return;
      }
      const newEventLog = new Int32Array(eventLogSize * 4);
      newEventLog.set(eventLog);
      eventLogBuffer = newEventLog.buffer;
      eventLog = newEventLog;
    }
    eventLog.set(entries, offset);
  }
}
function startLoggingProfilingEvents() {
  eventLogSize = INITIAL_EVENT_LOG_SIZE;
  eventLogBuffer = new ArrayBuffer(eventLogSize * 4);
  eventLog = new Int32Array(eventLogBuffer);
  eventLogIndex = 0;
}
function stopLoggingProfilingEvents() {
  const buffer = eventLogBuffer;
  eventLogSize = 0;
  eventLogBuffer = null;
  eventLog = null;
  eventLogIndex = 0;
  return buffer;
}
function markTaskStart(task, ms) {
  if (enableProfiling) {
    if (eventLog !== null) {
      logEvent([TaskStartEvent, ms * 1e3, task.id, task.priorityLevel]);
    }
  }
}
function markTaskCompleted(task, ms) {
  if (enableProfiling) {
    if (eventLog !== null) {
      logEvent([TaskCompleteEvent, ms * 1e3, task.id]);
    }
  }
}
function markTaskCanceled(task, ms) {
  if (enableProfiling) {
    if (eventLog !== null) {
      logEvent([TaskCancelEvent, ms * 1e3, task.id]);
    }
  }
}
function markTaskErrored(task, ms) {
  if (enableProfiling) {
    if (eventLog !== null) {
      logEvent([TaskErrorEvent, ms * 1e3, task.id]);
    }
  }
}
function markTaskRun(task, ms) {
  if (enableProfiling) {
    runIdCounter++;
    if (eventLog !== null) {
      logEvent([TaskRunEvent, ms * 1e3, task.id, runIdCounter]);
    }
  }
}
function markTaskYield(task, ms) {
  if (enableProfiling) {
    if (eventLog !== null) {
      logEvent([TaskYieldEvent, ms * 1e3, task.id, runIdCounter]);
    }
  }
}
function markSchedulerSuspended(ms) {
  if (enableProfiling) {
    mainThreadIdCounter++;
    if (eventLog !== null) {
      logEvent([SchedulerSuspendEvent, ms * 1e3, mainThreadIdCounter]);
    }
  }
}
function markSchedulerUnsuspended(ms) {
  if (enableProfiling) {
    if (eventLog !== null) {
      logEvent([SchedulerResumeEvent, ms * 1e3, mainThreadIdCounter]);
    }
  }
}

// dist/scheduler/src/forks/Scheduler.js
var getCurrentTime;
var hasPerformanceNow = (
  // $FlowFixMe[method-unbinding]
  typeof performance === "object" && typeof performance.now === "function"
);
if (hasPerformanceNow) {
  const localPerformance = performance;
  getCurrentTime = () => localPerformance.now();
} else {
  const localDate = Date;
  const initialTime = localDate.now();
  getCurrentTime = () => localDate.now() - initialTime;
}
var maxSigned31BitInt = 1073741823;
var taskQueue = [];
var timerQueue = [];
var taskIdCounter = 1;
var currentTask = null;
var currentPriorityLevel = NormalPriority;
var isPerformingWork = false;
var isHostCallbackScheduled = false;
var isHostTimeoutScheduled = false;
var needsPaint = false;
var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
function advanceTimers(currentTime) {
  let timer = peek(timerQueue);
  while (timer !== null) {
    if (timer.callback === null) {
      pop(timerQueue);
    } else if (timer.startTime <= currentTime) {
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
      if (enableProfiling) {
        markTaskStart(timer, currentTime);
        timer.isQueued = true;
      }
    } else {
      return;
    }
    timer = peek(timerQueue);
  }
}
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  advanceTimers(currentTime);
  if (!isHostCallbackScheduled) {
    if (peek(taskQueue) !== null) {
      isHostCallbackScheduled = true;
      requestHostCallback();
    } else {
      const firstTimer = peek(timerQueue);
      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}
function flushWork(initialTime) {
  if (enableProfiling) {
    markSchedulerUnsuspended(initialTime);
  }
  isHostCallbackScheduled = false;
  if (isHostTimeoutScheduled) {
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }
  isPerformingWork = true;
  const previousPriorityLevel = currentPriorityLevel;
  try {
    if (enableProfiling) {
      try {
        return workLoop(initialTime);
      } catch (error) {
        if (currentTask !== null) {
          const currentTime = getCurrentTime();
          markTaskErrored(currentTask, currentTime);
          currentTask.isQueued = false;
        }
        throw error;
      }
    } else {
      return workLoop(initialTime);
    }
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
    if (enableProfiling) {
      const currentTime = getCurrentTime();
      markSchedulerSuspended(currentTime);
    }
  }
}
function workLoop(initialTime) {
  let currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);
  while (currentTask !== null) {
    if (!enableAlwaysYieldScheduler) {
      if (currentTask.expirationTime > currentTime && shouldYieldToHost()) {
        break;
      }
    }
    const callback = currentTask.callback;
    if (typeof callback === "function") {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      if (enableProfiling) {
        markTaskRun(currentTask, currentTime);
      }
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      if (typeof continuationCallback === "function") {
        currentTask.callback = continuationCallback;
        if (enableProfiling) {
          markTaskYield(currentTask, currentTime);
        }
        advanceTimers(currentTime);
        return true;
      } else {
        if (enableProfiling) {
          markTaskCompleted(currentTask, currentTime);
          currentTask.isQueued = false;
        }
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
        advanceTimers(currentTime);
      }
    } else {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
    if (enableAlwaysYieldScheduler) {
      if (currentTask === null || currentTask.expirationTime > currentTime) {
        break;
      }
    }
  }
  if (currentTask !== null) {
    return true;
  } else {
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;
    default:
      priorityLevel = NormalPriority;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}
function unstable_next(eventHandler) {
  var priorityLevel;
  switch (currentPriorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
      priorityLevel = NormalPriority;
      break;
    default:
      priorityLevel = currentPriorityLevel;
      break;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}
function unstable_wrapCallback(callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function() {
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;
    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
}
function unstable_scheduleCallback(priorityLevel, callback, options) {
  var currentTime = getCurrentTime();
  var startTime2;
  if (typeof options === "object" && options !== null) {
    var delay = options.delay;
    if (typeof delay === "number" && delay > 0) {
      startTime2 = currentTime + delay;
    } else {
      startTime2 = currentTime;
    }
  } else {
    startTime2 = currentTime;
  }
  var timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = -1;
      break;
    case UserBlockingPriority:
      timeout = userBlockingPriorityTimeout;
      break;
    case IdlePriority:
      timeout = maxSigned31BitInt;
      break;
    case LowPriority:
      timeout = lowPriorityTimeout;
      break;
    case NormalPriority:
    default:
      timeout = normalPriorityTimeout;
      break;
  }
  var expirationTime = startTime2 + timeout;
  var newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime: startTime2,
    expirationTime,
    sortIndex: -1
  };
  if (enableProfiling) {
    newTask.isQueued = false;
  }
  if (startTime2 > currentTime) {
    newTask.sortIndex = startTime2;
    push(timerQueue, newTask);
    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      if (isHostTimeoutScheduled) {
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      }
      requestHostTimeout(handleTimeout, startTime2 - currentTime);
    }
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    if (enableProfiling) {
      markTaskStart(newTask, currentTime);
      newTask.isQueued = true;
    }
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback();
    }
  }
  return newTask;
}
function unstable_cancelCallback(task) {
  if (enableProfiling) {
    if (task.isQueued) {
      const currentTime = getCurrentTime();
      markTaskCanceled(task, currentTime);
      task.isQueued = false;
    }
  }
  task.callback = null;
}
function unstable_getCurrentPriorityLevel() {
  return currentPriorityLevel;
}
var isMessageLoopRunning = false;
var taskTimeoutID = -1;
var frameInterval = frameYieldMs;
var startTime = -1;
function shouldYieldToHost() {
  if (!enableAlwaysYieldScheduler && enableRequestPaint && needsPaint) {
    return true;
  }
  const timeElapsed = getCurrentTime() - startTime;
  if (timeElapsed < frameInterval) {
    return false;
  }
  return true;
}
function requestPaint() {
  if (enableRequestPaint) {
    needsPaint = true;
  }
}
function forceFrameRate(fps) {
  if (fps < 0 || fps > 125) {
    console["error"](
      "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
    );
    return;
  }
  if (fps > 0) {
    frameInterval = Math.floor(1e3 / fps);
  } else {
    frameInterval = frameYieldMs;
  }
}
var performWorkUntilDeadline = () => {
  if (enableRequestPaint) {
    needsPaint = false;
  }
  if (isMessageLoopRunning) {
    const currentTime = getCurrentTime();
    startTime = currentTime;
    let hasMoreWork = true;
    try {
      hasMoreWork = flushWork(currentTime);
    } finally {
      if (hasMoreWork) {
        schedulePerformWorkUntilDeadline();
      } else {
        isMessageLoopRunning = false;
      }
    }
  }
};
var schedulePerformWorkUntilDeadline;
if (typeof localSetImmediate === "function") {
  schedulePerformWorkUntilDeadline = () => {
    localSetImmediate(performWorkUntilDeadline);
  };
} else if (typeof MessageChannel !== "undefined") {
  const channel = new MessageChannel();
  const port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = () => {
    port.postMessage(null);
  };
} else {
  schedulePerformWorkUntilDeadline = () => {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
}
function requestHostCallback() {
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    schedulePerformWorkUntilDeadline();
  }
}
function requestHostTimeout(callback, ms) {
  taskTimeoutID = localSetTimeout(() => {
    callback(getCurrentTime());
  }, ms);
}
function cancelHostTimeout() {
  localClearTimeout(taskTimeoutID);
  taskTimeoutID = -1;
}
var unstable_Profiling = enableProfiling ? {
  startLoggingProfilingEvents,
  stopLoggingProfilingEvents
} : null;

// dist/react-reconciler/src/ReactWorkTags.js
var FunctionComponent = 0;
var ClassComponent = 1;
var HostRoot = 3;
var HostPortal = 4;
var HostComponent = 5;
var HostText = 6;
var Fragment = 7;
var Mode = 8;
var ContextConsumer = 9;
var ContextProvider = 10;
var ForwardRef = 11;
var Profiler = 12;
var SuspenseComponent = 13;
var MemoComponent = 14;
var SimpleMemoComponent = 15;
var LazyComponent = 16;
var IncompleteClassComponent = 17;
var DehydratedFragment = 18;
var SuspenseListComponent = 19;
var ScopeComponent = 21;
var OffscreenComponent = 22;
var LegacyHiddenComponent = 23;
var CacheComponent = 24;
var TracingMarkerComponent = 25;
var HostHoistable = 26;
var HostSingleton = 27;
var IncompleteFunctionComponent = 28;
var Throw = 29;
var ViewTransitionComponent = 30;
var ActivityComponent = 31;

// dist/react-reconciler/src/ReactFiberFlags.js
var NoFlags = (
  /*                      */
  0
);
var PerformedWork = (
  /*                */
  1
);
var Placement = (
  /*                    */
  2
);
var DidCapture = (
  /*                   */
  128
);
var Hydrating = (
  /*                    */
  4096
);
var Update = (
  /*                       */
  4
);
var Cloned = (
  /*                       */
  8
);
var ChildDeletion = (
  /*                */
  16
);
var ContentReset = (
  /*                 */
  32
);
var Callback = (
  /*                     */
  64
);
var ForceClientRender = (
  /*            */
  256
);
var Ref = (
  /*                          */
  512
);
var Snapshot = (
  /*                     */
  1024
);
var Passive = (
  /*                      */
  2048
);
var Visibility = (
  /*                   */
  8192
);
var StoreConsistency = (
  /*             */
  16384
);
var Hydrate = Callback;
var ScheduleRetry = StoreConsistency;
var ShouldSuspendCommit = Visibility;
var ViewTransitionNamedMount = ShouldSuspendCommit;
var DidDefer = ContentReset;
var FormReset = Snapshot;
var AffectedParentLayout = ContentReset;
var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
var HostEffectMask = (
  /*               */
  32767
);
var Incomplete = (
  /*                   */
  32768
);
var ShouldCapture = (
  /*                */
  65536
);
var ForceUpdateForLegacySuspense = (
  /* */
  131072
);
var DidPropagateContext = (
  /*          */
  262144
);
var NeedsPropagation = (
  /*             */
  524288
);
var Forked = (
  /*                       */
  1048576
);
var SnapshotStatic = (
  /*               */
  2097152
);
var LayoutStatic = (
  /*                 */
  4194304
);
var RefStatic = LayoutStatic;
var PassiveStatic = (
  /*                */
  8388608
);
var MaySuspendCommit = (
  /*             */
  16777216
);
var ViewTransitionNamedStatic = (
  /*    */
  SnapshotStatic | MaySuspendCommit
);
var ViewTransitionStatic = (
  /*         */
  33554432
);
var PlacementDEV = (
  /*                 */
  67108864
);
var BeforeMutationMask = Snapshot | (enableCreateEventHandleAPI ? (
  // createEventHandle needs to visit deleted and hidden trees to
  // fire beforeblur
  // TODO: Only need to visit Deletions during BeforeMutation phase if an
  // element is focused.
  Update | ChildDeletion | Visibility
) : enableUseEffectEventHook ? (
  // TODO: The useEffectEvent hook uses the snapshot phase for clean up but it
  // really should use the mutation phase for this or at least schedule an
  // explicit Snapshot phase flag for this.
  Update
) : 0);
var BeforeAndAfterMutationTransitionMask = Snapshot | Update | Placement | ChildDeletion | Visibility | ContentReset;
var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility | FormReset;
var LayoutMask = Update | Callback | Ref | Visibility;
var PassiveMask = Passive | Visibility | ChildDeletion;
var PassiveTransitionMask = PassiveMask | Update | Placement;
var StaticMask = LayoutStatic | PassiveStatic | RefStatic | MaySuspendCommit | ViewTransitionStatic | ViewTransitionNamedStatic;

// dist/react-reconciler/src/ReactFiberTreeReflection.js
function getNearestMountedFiber(fiber) {
  let node = fiber;
  let nearestMounted = fiber;
  if (!fiber.alternate) {
    let nextNode = node;
    do {
      node = nextNode;
      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
        nearestMounted = node.return;
      }
      nextNode = node.return;
    } while (nextNode);
  } else {
    while (node.return) {
      node = node.return;
    }
  }
  if (node.tag === HostRoot) {
    return nearestMounted;
  }
  return null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (fiber.tag === SuspenseComponent) {
    let suspenseState = fiber.memoizedState;
    if (suspenseState === null) {
      const current2 = fiber.alternate;
      if (current2 !== null) {
        suspenseState = current2.memoizedState;
      }
    }
    if (suspenseState !== null) {
      return suspenseState.dehydrated;
    }
  }
  return null;
}
function getActivityInstanceFromFiber(fiber) {
  if (fiber.tag === ActivityComponent) {
    let activityState = fiber.memoizedState;
    if (activityState === null) {
      const current2 = fiber.alternate;
      if (current2 !== null) {
        activityState = current2.memoizedState;
      }
    }
    if (activityState !== null) {
      return activityState.dehydrated;
    }
  }
  return null;
}
function getContainerFromFiber(fiber) {
  return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber) {
    throw new Error("Unable to find node on an unmounted component.");
  }
}
function findCurrentFiberUsingSlowPath(fiber) {
  const alternate = fiber.alternate;
  if (!alternate) {
    const nearestMounted = getNearestMountedFiber(fiber);
    if (nearestMounted === null) {
      throw new Error("Unable to find node on an unmounted component.");
    }
    if (nearestMounted !== fiber) {
      return null;
    }
    return fiber;
  }
  let a = fiber;
  let b = alternate;
  while (true) {
    const parentA = a.return;
    if (parentA === null) {
      break;
    }
    const parentB = parentA.alternate;
    if (parentB === null) {
      const nextParent = parentA.return;
      if (nextParent !== null) {
        a = b = nextParent;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      let child = parentA.child;
      while (child) {
        if (child === a) {
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      throw new Error("Unable to find node on an unmounted component.");
    }
    if (a.return !== b.return) {
      a = parentA;
      b = parentB;
    } else {
      let didFindChild = false;
      let child = parentA.child;
      while (child) {
        if (child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        child = child.sibling;
      }
      if (!didFindChild) {
        child = parentB.child;
        while (child) {
          if (child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          child = child.sibling;
        }
        if (!didFindChild) {
          throw new Error(
            "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
          );
        }
      }
    }
    if (a.alternate !== b) {
      throw new Error(
        "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
      );
    }
  }
  if (a.tag !== HostRoot) {
    throw new Error("Unable to find node on an unmounted component.");
  }
  if (a.stateNode.current === a) {
    return fiber;
  }
  return alternate;
}
function findCurrentHostFiber(parent) {
  const currentParent = findCurrentFiberUsingSlowPath(parent);
  return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
}
function findCurrentHostFiberImpl(node) {
  const tag = node.tag;
  if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {
    return node;
  }
  let child = node.child;
  while (child !== null) {
    const match = findCurrentHostFiberImpl(child);
    if (match !== null) {
      return match;
    }
    child = child.sibling;
  }
  return null;
}
function isFiberSuspenseAndTimedOut(fiber) {
  const memoizedState = fiber.memoizedState;
  return fiber.tag === SuspenseComponent && memoizedState !== null && memoizedState.dehydrated === null;
}
function doesFiberContain(parentFiber, childFiber) {
  let node = childFiber;
  const parentFiberAlternate = parentFiber.alternate;
  while (node !== null) {
    if (node === parentFiber || node === parentFiberAlternate) {
      return true;
    }
    node = node.return;
  }
  return false;
}
function traverseFragmentInstance(fragmentFiber, fn, a, b, c) {
  traverseVisibleHostChildren(fragmentFiber.child, false, fn, a, b, c);
}
function traverseFragmentInstanceDeeply(fragmentFiber, fn, a, b, c) {
  traverseVisibleHostChildren(fragmentFiber.child, true, fn, a, b, c);
}
function traverseVisibleHostChildren(child, searchWithinHosts, fn, a, b, c) {
  while (child !== null) {
    if (child.tag === HostComponent && fn(child, a, b, c)) {
      return true;
    } else if (child.tag === OffscreenComponent && child.memoizedState !== null) {
    } else {
      if ((searchWithinHosts || child.tag !== HostComponent) && traverseVisibleHostChildren(child.child, searchWithinHosts, fn, a, b, c)) {
        return true;
      }
    }
    child = child.sibling;
  }
  return false;
}
function getFragmentParentHostFiber(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (parent.tag === HostRoot || parent.tag === HostComponent) {
      return parent;
    }
    parent = parent.return;
  }
  return null;
}
function getInstanceFromHostFiber(fiber) {
  switch (fiber.tag) {
    case HostComponent:
      return fiber.stateNode;
    case HostRoot:
      return fiber.stateNode.containerInfo;
    default:
      throw new Error("Expected to find a host node. This is a bug in React.");
  }
}
var searchTarget = null;
var searchBoundary = null;
function pushSearchTarget(target) {
  searchTarget = target;
}
function popSearchTarget() {
  return searchTarget;
}
function pushSearchBoundary(value) {
  searchBoundary = value;
}
function popSearchBoundary() {
  return searchBoundary;
}
function getNextSiblingHostFiber(fiber) {
  traverseVisibleHostChildren(fiber.sibling, false, findNextSibling);
  const sibling = popSearchTarget();
  pushSearchTarget(null);
  return sibling;
}
function findNextSibling(child) {
  pushSearchTarget(child);
  return true;
}
function isFiberContainedBy(maybeChild, maybeParent) {
  let parent = maybeParent.return;
  if (parent === maybeChild || parent === maybeChild.alternate) {
    return true;
  }
  while (parent !== null && parent !== maybeChild) {
    if ((parent.tag === HostComponent || parent.tag === HostRoot) && (parent.return === maybeChild || parent.return === maybeChild.alternate)) {
      return true;
    }
    parent = parent.return;
  }
  return false;
}
function isFiberPreceding(fiber, otherFiber) {
  const commonAncestor = getLowestCommonAncestor(
    fiber,
    otherFiber,
    getParentForFragmentAncestors
  );
  if (commonAncestor === null) {
    return false;
  }
  traverseVisibleHostChildren(
    commonAncestor,
    true,
    isFiberPrecedingCheck,
    otherFiber,
    fiber
  );
  const target = popSearchTarget();
  pushSearchTarget(null);
  return target !== null;
}
function isFiberPrecedingCheck(child, target, boundary) {
  if (child === boundary) {
    return true;
  }
  if (child === target) {
    pushSearchTarget(child);
    return true;
  }
  return false;
}
function isFiberFollowing(fiber, otherFiber) {
  const commonAncestor = getLowestCommonAncestor(
    fiber,
    otherFiber,
    getParentForFragmentAncestors
  );
  if (commonAncestor === null) {
    return false;
  }
  traverseVisibleHostChildren(
    commonAncestor,
    true,
    isFiberFollowingCheck,
    otherFiber,
    fiber
  );
  const target = popSearchTarget();
  pushSearchTarget(null);
  pushSearchBoundary(null);
  return target !== null;
}
function isFiberFollowingCheck(child, target, boundary) {
  if (child === boundary) {
    pushSearchBoundary(child);
    return false;
  }
  if (child === target) {
    if (popSearchBoundary() !== null) {
      pushSearchTarget(child);
    }
    return true;
  }
  return false;
}
function getParentForFragmentAncestors(inst) {
  if (inst === null) {
    return null;
  }
  do {
    inst = inst === null ? null : inst.return;
  } while (inst && inst.tag !== HostComponent && inst.tag !== HostSingleton && inst.tag !== HostRoot);
  if (inst) {
    return inst;
  }
  return null;
}
function getLowestCommonAncestor(instA, instB, getParent2) {
  let nodeA = instA;
  let nodeB = instB;
  let depthA = 0;
  for (let tempA = nodeA; tempA; tempA = getParent2(tempA)) {
    depthA++;
  }
  let depthB = 0;
  for (let tempB = nodeB; tempB; tempB = getParent2(tempB)) {
    depthB++;
  }
  while (depthA - depthB > 0) {
    nodeA = getParent2(nodeA);
    depthA--;
  }
  while (depthB - depthA > 0) {
    nodeB = getParent2(nodeB);
    depthB--;
  }
  let depth = depthA;
  while (depth--) {
    if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
      return nodeA;
    }
    nodeA = getParent2(nodeA);
    nodeB = getParent2(nodeB);
  }
  return null;
}

// dist/react-reconciler/src/ReactRootTags.js
var LegacyRoot = 0;
var ConcurrentRoot = 1;

// dist/shared/ReactInstanceMap.js
function get(key) {
  return key._reactInternals;
}
function set(key, value) {
  key._reactInternals = value;
}

// dist/shared/ReactSymbols.js
var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
var REACT_ELEMENT_TYPE = renameElementSymbol ? Symbol.for("react.transitional.element") : REACT_LEGACY_ELEMENT_TYPE;
var REACT_PORTAL_TYPE = Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = Symbol.for(
  "react.suspense_list"
);
var REACT_MEMO_TYPE = Symbol.for("react.memo");
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var REACT_SCOPE_TYPE = Symbol.for("react.scope");
var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(
  "react.legacy_hidden"
);
var REACT_TRACING_MARKER_TYPE = Symbol.for(
  "react.tracing_marker"
);
var REACT_MEMO_CACHE_SENTINEL = Symbol.for(
  "react.memo_cache_sentinel"
);
var REACT_POSTPONE_TYPE = Symbol.for("react.postpone");
var REACT_VIEW_TRANSITION_TYPE = Symbol.for(
  "react.view_transition"
);
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = "@@iterator";
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== "object") {
    return null;
  }
  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === "function") {
    return maybeIterator;
  }
  return null;
}
var ASYNC_ITERATOR = Symbol.asyncIterator;

// dist/shared/getComponentNameFromType.js
function getWrappedName(outerType, innerType, wrapperName) {
  const displayName = outerType.displayName;
  if (displayName) {
    return displayName;
  }
  const functionName = innerType.displayName || innerType.name || "";
  return functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName;
}
function getContextName(type) {
  return type.displayName || "Context";
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(type) {
  if (type == null) {
    return null;
  }
  if (typeof type === "function") {
    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
      return null;
    }
    return type.displayName || type.name || null;
  }
  if (typeof type === "string") {
    return type;
  }
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
      return "Activity";
    case REACT_VIEW_TRANSITION_TYPE:
      if (enableViewTransition) {
        return "ViewTransition";
      }
    // Fall through
    case REACT_TRACING_MARKER_TYPE:
      if (enableTransitionTracing) {
        return "TracingMarker";
      }
  }
  if (typeof type === "object") {
    if (false) {
      if (typeof type.tag === "number") {
        console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        );
      }
    }
    switch (type.$$typeof) {
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_PROVIDER_TYPE:
        if (enableRenderableContext) {
          return null;
        } else {
          const provider = type;
          return getContextName(provider._context) + ".Provider";
        }
      case REACT_CONTEXT_TYPE:
        const context = type;
        if (enableRenderableContext) {
          return getContextName(context) + ".Provider";
        } else {
          return getContextName(context) + ".Consumer";
        }
      case REACT_CONSUMER_TYPE:
        if (enableRenderableContext) {
          const consumer = type;
          return getContextName(consumer._context) + ".Consumer";
        } else {
          return null;
        }
      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, "ForwardRef");
      case REACT_MEMO_TYPE:
        const outerName = type.displayName || null;
        if (outerName !== null) {
          return outerName;
        }
        return getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE: {
        const lazyComponent = type;
        const payload = lazyComponent._payload;
        const init = lazyComponent._init;
        try {
          return getComponentNameFromType(init(payload));
        } catch (x) {
          return null;
        }
      }
    }
  }
  return null;
}

// dist/react-reconciler/src/getComponentNameFromFiber.js
function getWrappedName2(outerType, innerType, wrapperName) {
  const functionName = innerType.displayName || innerType.name || "";
  return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
function getContextName2(type) {
  return type.displayName || "Context";
}
function getComponentNameFromFiber(fiber) {
  const { tag, type } = fiber;
  switch (tag) {
    case ActivityComponent:
      return "Activity";
    case CacheComponent:
      return "Cache";
    case ContextConsumer:
      if (enableRenderableContext) {
        const consumer = type;
        return getContextName2(consumer._context) + ".Consumer";
      } else {
        const context = type;
        return getContextName2(context) + ".Consumer";
      }
    case ContextProvider:
      if (enableRenderableContext) {
        const context = type;
        return getContextName2(context) + ".Provider";
      } else {
        const provider = type;
        return getContextName2(provider._context) + ".Provider";
      }
    case DehydratedFragment:
      return "DehydratedFragment";
    case ForwardRef:
      return getWrappedName2(type, type.render, "ForwardRef");
    case Fragment:
      return "Fragment";
    case HostHoistable:
    case HostSingleton:
    case HostComponent:
      return type;
    case HostPortal:
      return "Portal";
    case HostRoot:
      return "Root";
    case HostText:
      return "Text";
    case LazyComponent:
      return getComponentNameFromType(type);
    case Mode:
      if (type === REACT_STRICT_MODE_TYPE) {
        return "StrictMode";
      }
      return "Mode";
    case OffscreenComponent:
      return "Offscreen";
    case Profiler:
      return "Profiler";
    case ScopeComponent:
      return "Scope";
    case SuspenseComponent:
      return "Suspense";
    case SuspenseListComponent:
      return "SuspenseList";
    case TracingMarkerComponent:
      return "TracingMarker";
    case ViewTransitionComponent:
      if (enableViewTransition) {
        return "ViewTransition";
      }
    // The display name for these tags come from the user-provided type:
    // Fallthrough
    case IncompleteClassComponent:
    case IncompleteFunctionComponent:
      if (disableLegacyMode) {
        break;
      }
    // Fallthrough
    case ClassComponent:
    case FunctionComponent:
    case MemoComponent:
    case SimpleMemoComponent:
      if (typeof type === "function") {
        return type.displayName || type.name || null;
      }
      if (typeof type === "string") {
        return type;
      }
      break;
    case LegacyHiddenComponent:
      if (enableLegacyHidden) {
        return "LegacyHidden";
      }
      break;
    case Throw: {
      if (false) {
        const debugInfo = fiber._debugInfo;
        if (debugInfo != null) {
          for (let i = debugInfo.length - 1; i >= 0; i--) {
            if (typeof debugInfo[i].name === "string") {
              return debugInfo[i].name;
            }
          }
        }
        if (fiber.return === null) {
          return null;
        }
        return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
  }
  return null;
}

// dist/shared/isArray.js
var isArrayImpl = Array.isArray;
function isArray(a) {
  return isArrayImpl(a);
}
var isArray_default = isArray;

// dist/shared/ReactVersion.js
var ReactVersion_default = "19.1.0";

// dist/react/src/ReactNoopUpdateQueue.js
function warnNoop(publicInstance, callerName) {
  if (false) {
    const constructor = publicInstance.constructor;
    const componentName = constructor && (constructor.displayName || constructor.name) || "ReactClass";
    const warningKey = `${componentName}.${callerName}`;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    console.error(
      "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
      callerName,
      componentName
    );
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function(publicInstance) {
    return false;
  },
  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function(publicInstance, callback, callerName) {
    warnNoop(publicInstance, "forceUpdate");
  },
  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, "replaceState");
  },
  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function(publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, "setState");
  }
};
var ReactNoopUpdateQueue_default = ReactNoopUpdateQueue;

// dist/shared/assign.js
var assign = Object.assign;
var assign_default = assign;

// dist/react/src/ReactBaseClasses.js
var emptyObject = {};
if (false) {
  Object.freeze(emptyObject);
}
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue_default;
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function(partialState, callback) {
  if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
    throw new Error(
      "takes an object of state variables to update or a function which returns an object of state variables."
    );
  }
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
Component.prototype.forceUpdate = function(callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};
if (false) {
  const deprecatedAPIs = {
    isMounted: [
      "isMounted",
      "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
    ],
    replaceState: [
      "replaceState",
      "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
    ]
  };
  const defineDeprecationWarning = function(methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function() {
        console.warn(
          "%s(...) is deprecated in plain JavaScript React classes. %s",
          info[0],
          info[1]
        );
        return void 0;
      }
    });
  };
  for (const fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}
function ComponentDummy() {
}
ComponentDummy.prototype = Component.prototype;
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue_default;
}
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
assign_default(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

// dist/shared/noop.js
function noop() {
}

// dist/shared/hasOwnProperty.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwnProperty_default = hasOwnProperty;

// dist/react/src/jsx/ReactJSXElement.js
var createTask = (
  // eslint-disable-next-line react-internal/no-production-logging
  false ? (
    // eslint-disable-next-line react-internal/no-production-logging
    console.createTask
  ) : () => null
);
function getOwner() {
  if (false) {
    const dispatcher = ReactSharedInternals_default.A;
    if (dispatcher === null) {
      return null;
    }
    return dispatcher.getOwner();
  }
  return null;
}
if (false) {
  didWarnAboutElementRef = {};
  unknownOwnerDebugStack = createFakeCallStack["react-stack-bottom-frame"].bind(
    createFakeCallStack,
    UnknownOwner
  )();
  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
}
function hasValidKey(config) {
  if (false) {
    if (hasOwnProperty_default.call(config, "key")) {
      const getter = Object.getOwnPropertyDescriptor(config, "key").get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== void 0;
}
function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
  const refProp = props.ref;
  const ref = refProp !== void 0 ? refProp : null;
  let element;
  if (false) {
    element = {
      // This tag allows us to uniquely identify this as a React Element
      $$typeof: REACT_ELEMENT_TYPE,
      // Built-in properties that belong on the element
      type,
      key,
      props,
      // Record the component responsible for creating this element.
      _owner: owner
    };
    if (ref !== null) {
      Object.defineProperty(element, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      });
    } else {
      Object.defineProperty(element, "ref", {
        enumerable: false,
        value: null
      });
    }
  } else {
    element = {
      // This tag allows us to uniquely identify this as a React Element
      $$typeof: REACT_ELEMENT_TYPE,
      // Built-in properties that belong on the element
      type,
      key,
      ref,
      props
    };
  }
  if (false) {
    element._store = {};
    Object.defineProperty(element._store, "validated", {
      configurable: false,
      enumerable: false,
      writable: true,
      value: 0
    });
    Object.defineProperty(element, "_debugInfo", {
      configurable: false,
      enumerable: false,
      writable: true,
      value: null
    });
    Object.defineProperty(element, "_debugStack", {
      configurable: false,
      enumerable: false,
      writable: true,
      value: debugStack
    });
    Object.defineProperty(element, "_debugTask", {
      configurable: false,
      enumerable: false,
      writable: true,
      value: debugTask
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }
  return element;
}
function createElement(type, config, children) {
  if (false) {
    for (let i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }
  let propName;
  const props = {};
  let key = null;
  if (config != null) {
    if (false) {
      if (!didWarnAboutOldJSXRuntime && "__self" in config && // Do not assume this is the result of an oudated JSX transform if key
      // is present, because the modern JSX transform sometimes outputs
      // createElement to preserve precedence between a static key and a
      // spread key. To avoid false positive warnings, we never warn if
      // there's a key.
      !("key" in config)) {
        didWarnAboutOldJSXRuntime = true;
        console.warn(
          "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
        );
      }
    }
    if (hasValidKey(config)) {
      if (false) {
        checkKeyStringCoercion(config.key);
      }
      key = "" + config.key;
    }
    for (propName in config) {
      if (hasOwnProperty_default.call(config, propName) && // Skip over reserved prop names
      propName !== "key" && // Even though we don't use these anymore in the runtime, we don't want
      // them to appear as props, so in createElement we filter them out.
      // We don't have to do this in the jsx() runtime because the jsx()
      // transform never passed these as props; it used separate arguments.
      propName !== "__self" && propName !== "__source") {
        props[propName] = config[propName];
      }
    }
  }
  const childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    const childArray = Array(childrenLength);
    for (let i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (false) {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }
  if (type && type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === void 0) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (false) {
    if (key) {
      const displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
      defineKeyPropWarningGetter(props, displayName);
    }
  }
  const trackActualOwner = false;
  return ReactElement(
    type,
    key,
    void 0,
    void 0,
    getOwner(),
    props,
    false,
    false
  );
}

// dist/react/src/ReactSharedInternalsClient.js
var ReactSharedInternals = {
  H: null,
  A: null,
  T: null,
  S: null
};
if (enableGestureTransition) {
  ReactSharedInternals.G = null;
}
if (false) {
  ReactSharedInternals.actQueue = null;
  ReactSharedInternals.asyncTransitions = 0;
  ReactSharedInternals.isBatchingLegacy = false;
  ReactSharedInternals.didScheduleLegacyUpdate = false;
  ReactSharedInternals.didUsePromise = false;
  ReactSharedInternals.thrownErrors = [];
  ReactSharedInternals.getCurrentStack = null;
  ReactSharedInternals.recentlyCreatedOwnerStacks = 0;
}
var ReactSharedInternalsClient_default = ReactSharedInternals;

// dist/shared/reportGlobalError.js
var reportGlobalError = typeof reportError === "function" ? (
  // In modern browsers, reportError will dispatch an error event,
  // emulating an uncaught JavaScript error.
  reportError
) : (error) => {
  if (typeof window === "object" && typeof window.ErrorEvent === "function") {
    const message = typeof error === "object" && error !== null && typeof error.message === "string" ? (
      // eslint-disable-next-line react-internal/safe-string-coercion
      String(error.message)
    ) : (
      // eslint-disable-next-line react-internal/safe-string-coercion
      String(error)
    );
    const event = new window.ErrorEvent("error", {
      bubbles: true,
      cancelable: true,
      message,
      error
    });
    const shouldLog = window.dispatchEvent(event);
    if (!shouldLog) {
      return;
    }
  } else if (typeof process === "object" && // $FlowFixMe[method-unbinding]
  typeof process.emit === "function") {
    process.emit("uncaughtException", error);
    return;
  }
  console["error"](error);
};
var reportGlobalError_default = reportGlobalError;

// dist/shared/ReactSharedInternals.js
var ReactSharedInternals2 = ReactSharedInternalsClient_default;
var ReactSharedInternals_default = ReactSharedInternals2;

// dist/react-reconciler/src/ReactFiberConfig.js
throw new Error("This module must be shimmed by a specific renderer.");

// dist/react-reconciler/src/ReactFiberStack.js
var valueStack = [];
if (false) {
  fiberStack = [];
}
var index = -1;
function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}
function pop2(cursor, fiber) {
  if (index < 0) {
    if (false) {
      console.error("Unexpected pop.");
    }
    return;
  }
  if (false) {
    if (fiber !== fiberStack[index]) {
      console.error("Unexpected Fiber popped.");
    }
  }
  cursor.current = valueStack[index];
  valueStack[index] = null;
  if (false) {
    fiberStack[index] = null;
  }
  index--;
}
function push2(cursor, value, fiber) {
  index++;
  valueStack[index] = cursor.current;
  if (false) {
    fiberStack[index] = fiber;
  }
  cursor.current = value;
}

// dist/react-reconciler/src/ReactFiberContext.js
if (false) {
  warnedAboutMissingGetChildContext = {};
}
var emptyContextObject = {};
if (false) {
  Object.freeze(emptyContextObject);
}
var contextStackCursor = createCursor(emptyContextObject);
var didPerformWorkStackCursor = createCursor(false);
var previousContext = emptyContextObject;
function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
  if (disableLegacyContext) {
    return emptyContextObject;
  } else {
    if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
      return previousContext;
    }
    return contextStackCursor.current;
  }
}
function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
  if (disableLegacyContext) {
    return;
  } else {
    const instance = workInProgress2.stateNode;
    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
  }
}
function getMaskedContext(workInProgress2, unmaskedContext) {
  if (disableLegacyContext) {
    return emptyContextObject;
  } else {
    const type = workInProgress2.type;
    const contextTypes = type.contextTypes;
    if (!contextTypes) {
      return emptyContextObject;
    }
    const instance = workInProgress2.stateNode;
    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
      return instance.__reactInternalMemoizedMaskedChildContext;
    }
    const context = {};
    for (const key in contextTypes) {
      context[key] = unmaskedContext[key];
    }
    if (instance) {
      cacheContext(workInProgress2, unmaskedContext, context);
    }
    return context;
  }
}
function hasContextChanged() {
  if (disableLegacyContext) {
    return false;
  } else {
    return didPerformWorkStackCursor.current;
  }
}
function isContextProvider(type) {
  if (disableLegacyContext) {
    return false;
  } else {
    const childContextTypes = type.childContextTypes;
    return childContextTypes !== null && childContextTypes !== void 0;
  }
}
function popContext(fiber) {
  if (disableLegacyContext) {
    return;
  } else {
    pop2(didPerformWorkStackCursor, fiber);
    pop2(contextStackCursor, fiber);
  }
}
function popTopLevelContextObject(fiber) {
  if (disableLegacyContext) {
    return;
  } else {
    pop2(didPerformWorkStackCursor, fiber);
    pop2(contextStackCursor, fiber);
  }
}
function pushTopLevelContextObject(fiber, context, didChange) {
  if (disableLegacyContext) {
    return;
  } else {
    if (contextStackCursor.current !== emptyContextObject) {
      throw new Error(
        "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    push2(contextStackCursor, context, fiber);
    push2(didPerformWorkStackCursor, didChange, fiber);
  }
}
function processChildContext(fiber, type, parentContext) {
  if (disableLegacyContext) {
    return parentContext;
  } else {
    const instance = fiber.stateNode;
    const childContextTypes = type.childContextTypes;
    if (typeof instance.getChildContext !== "function") {
      if (false) {
        const componentName = getComponentNameFromFiber(fiber) || "Unknown";
        if (!warnedAboutMissingGetChildContext[componentName]) {
          warnedAboutMissingGetChildContext[componentName] = true;
          console.error(
            "%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.",
            componentName,
            componentName
          );
        }
      }
      return parentContext;
    }
    const childContext = instance.getChildContext();
    for (const contextKey in childContext) {
      if (!(contextKey in childContextTypes)) {
        throw new Error(
          `${getComponentNameFromFiber(fiber) || "Unknown"}.getChildContext(): key "${contextKey}" is not defined in childContextTypes.`
        );
      }
    }
    return { ...parentContext, ...childContext };
  }
}
function pushContextProvider(workInProgress2) {
  if (disableLegacyContext) {
    return false;
  } else {
    const instance = workInProgress2.stateNode;
    const memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
    previousContext = contextStackCursor.current;
    push2(contextStackCursor, memoizedMergedChildContext, workInProgress2);
    push2(
      didPerformWorkStackCursor,
      didPerformWorkStackCursor.current,
      workInProgress2
    );
    return true;
  }
}
function invalidateContextProvider(workInProgress2, type, didChange) {
  if (disableLegacyContext) {
    return;
  } else {
    const instance = workInProgress2.stateNode;
    if (!instance) {
      throw new Error(
        "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    if (didChange) {
      const mergedContext = processChildContext(
        workInProgress2,
        type,
        previousContext
      );
      instance.__reactInternalMemoizedMergedChildContext = mergedContext;
      pop2(didPerformWorkStackCursor, workInProgress2);
      pop2(contextStackCursor, workInProgress2);
      push2(contextStackCursor, mergedContext, workInProgress2);
      push2(didPerformWorkStackCursor, didChange, workInProgress2);
    } else {
      pop2(didPerformWorkStackCursor, workInProgress2);
      push2(didPerformWorkStackCursor, didChange, workInProgress2);
    }
  }
}
function findCurrentUnmaskedContext(fiber) {
  if (disableLegacyContext) {
    return emptyContextObject;
  } else {
    let node = fiber;
    do {
      switch (node.tag) {
        case HostRoot:
          return node.stateNode.context;
        case ClassComponent: {
          const Component2 = node.type;
          if (isContextProvider(Component2)) {
            return node.stateNode.__reactInternalMemoizedMergedChildContext;
          }
          break;
        }
      }
      node = node.return;
    } while (node !== null);
    throw new Error(
      "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
    );
  }
}

// dist/react-reconciler/src/ReactFiberOffscreenComponent.js
var OffscreenVisible = (
  /*                     */
  1
);
var OffscreenPassiveEffectsConnected = (
  /*     */
  2
);

// dist/react-reconciler/src/clz32.js
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
var log = Math.log;
var LN2 = Math.LN2;
function clz32Fallback(x) {
  const asUint = x >>> 0;
  if (asUint === 0) {
    return 32;
  }
  return 31 - (log(asUint) / LN2 | 0) | 0;
}

// dist/react-reconciler/src/ReactFiberLane.js
var TotalLanes = 31;
var NoLanes = (
  /*                        */
  0
);
var NoLane = (
  /*                          */
  0
);
var SyncHydrationLane = (
  /*               */
  1
);
var SyncLane = (
  /*                        */
  2
);
var SyncLaneIndex = 1;
var InputContinuousHydrationLane = (
  /*    */
  4
);
var InputContinuousLane = (
  /*             */
  8
);
var DefaultHydrationLane = (
  /*            */
  16
);
var DefaultLane = (
  /*                     */
  32
);
var SyncUpdateLanes = SyncLane | InputContinuousLane | DefaultLane;
var GestureLane = (
  /*                     */
  64
);
var TransitionHydrationLane = (
  /*                */
  128
);
var TransitionLanes = (
  /*                       */
  4194048
);
var TransitionLane1 = (
  /*                        */
  256
);
var TransitionLane2 = (
  /*                        */
  512
);
var TransitionLane3 = (
  /*                        */
  1024
);
var TransitionLane4 = (
  /*                        */
  2048
);
var TransitionLane5 = (
  /*                        */
  4096
);
var TransitionLane6 = (
  /*                        */
  8192
);
var TransitionLane7 = (
  /*                        */
  16384
);
var TransitionLane8 = (
  /*                        */
  32768
);
var TransitionLane9 = (
  /*                        */
  65536
);
var TransitionLane10 = (
  /*                       */
  131072
);
var TransitionLane11 = (
  /*                       */
  262144
);
var TransitionLane12 = (
  /*                       */
  524288
);
var TransitionLane13 = (
  /*                       */
  1048576
);
var TransitionLane14 = (
  /*                       */
  2097152
);
var RetryLanes = (
  /*                            */
  62914560
);
var RetryLane1 = (
  /*                             */
  4194304
);
var RetryLane2 = (
  /*                             */
  8388608
);
var RetryLane3 = (
  /*                             */
  16777216
);
var RetryLane4 = (
  /*                             */
  33554432
);
var SomeRetryLane = RetryLane1;
var SelectiveHydrationLane = (
  /*          */
  67108864
);
var NonIdleLanes = (
  /*                          */
  134217727
);
var IdleHydrationLane = (
  /*               */
  134217728
);
var IdleLane = (
  /*                        */
  268435456
);
var OffscreenLane = (
  /*                   */
  536870912
);
var DeferredLane = (
  /*                    */
  1073741824
);
var UpdateLanes = SyncLane | InputContinuousLane | DefaultLane | TransitionLanes;
var HydrationLanes = SyncHydrationLane | InputContinuousHydrationLane | DefaultHydrationLane | TransitionHydrationLane | SelectiveHydrationLane | IdleHydrationLane;
function getLabelForLane(lane) {
  if (enableSchedulingProfiler) {
    if (lane & SyncHydrationLane) {
      return "SyncHydrationLane";
    }
    if (lane & SyncLane) {
      return "Sync";
    }
    if (lane & InputContinuousHydrationLane) {
      return "InputContinuousHydration";
    }
    if (lane & InputContinuousLane) {
      return "InputContinuous";
    }
    if (lane & DefaultHydrationLane) {
      return "DefaultHydration";
    }
    if (lane & DefaultLane) {
      return "Default";
    }
    if (lane & TransitionHydrationLane) {
      return "TransitionHydration";
    }
    if (lane & TransitionLanes) {
      return "Transition";
    }
    if (lane & RetryLanes) {
      return "Retry";
    }
    if (lane & SelectiveHydrationLane) {
      return "SelectiveHydration";
    }
    if (lane & IdleHydrationLane) {
      return "IdleHydration";
    }
    if (lane & IdleLane) {
      return "Idle";
    }
    if (lane & OffscreenLane) {
      return "Offscreen";
    }
    if (lane & DeferredLane) {
      return "Deferred";
    }
  }
}
var NoTimestamp = -1;
var nextTransitionLane = TransitionLane1;
var nextRetryLane = RetryLane1;
function getHighestPriorityLanes(lanes) {
  const pendingSyncLanes = lanes & SyncUpdateLanes;
  if (pendingSyncLanes !== 0) {
    return pendingSyncLanes;
  }
  switch (getHighestPriorityLane(lanes)) {
    case SyncHydrationLane:
      return SyncHydrationLane;
    case SyncLane:
      return SyncLane;
    case InputContinuousHydrationLane:
      return InputContinuousHydrationLane;
    case InputContinuousLane:
      return InputContinuousLane;
    case DefaultHydrationLane:
      return DefaultHydrationLane;
    case DefaultLane:
      return DefaultLane;
    case GestureLane:
      return GestureLane;
    case TransitionHydrationLane:
      return TransitionHydrationLane;
    case TransitionLane1:
    case TransitionLane2:
    case TransitionLane3:
    case TransitionLane4:
    case TransitionLane5:
    case TransitionLane6:
    case TransitionLane7:
    case TransitionLane8:
    case TransitionLane9:
    case TransitionLane10:
    case TransitionLane11:
    case TransitionLane12:
    case TransitionLane13:
    case TransitionLane14:
      return lanes & TransitionLanes;
    case RetryLane1:
    case RetryLane2:
    case RetryLane3:
    case RetryLane4:
      return lanes & RetryLanes;
    case SelectiveHydrationLane:
      return SelectiveHydrationLane;
    case IdleHydrationLane:
      return IdleHydrationLane;
    case IdleLane:
      return IdleLane;
    case OffscreenLane:
      return OffscreenLane;
    case DeferredLane:
      return NoLanes;
    default:
      if (false) {
        console.error(
          "Should have found matching lanes. This is a bug in React."
        );
      }
      return lanes;
  }
}
function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
  const pendingLanes = root2.pendingLanes;
  if (pendingLanes === NoLanes) {
    return NoLanes;
  }
  let nextLanes = NoLanes;
  const suspendedLanes = root2.suspendedLanes;
  const pingedLanes = root2.pingedLanes;
  const warmLanes = root2.warmLanes;
  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
  if (nonIdlePendingLanes !== NoLanes) {
    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
    if (nonIdleUnblockedLanes !== NoLanes) {
      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
    } else {
      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
      if (nonIdlePingedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
      } else {
        if (!rootHasPendingCommit) {
          const lanesToPrewarm = nonIdlePendingLanes & ~warmLanes;
          if (lanesToPrewarm !== NoLanes) {
            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
          }
        }
      }
    }
  } else {
    const unblockedLanes = pendingLanes & ~suspendedLanes;
    if (unblockedLanes !== NoLanes) {
      nextLanes = getHighestPriorityLanes(unblockedLanes);
    } else {
      if (pingedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(pingedLanes);
      } else {
        if (!rootHasPendingCommit) {
          const lanesToPrewarm = pendingLanes & ~warmLanes;
          if (lanesToPrewarm !== NoLanes) {
            nextLanes = getHighestPriorityLanes(lanesToPrewarm);
          }
        }
      }
    }
  }
  if (nextLanes === NoLanes) {
    return NoLanes;
  }
  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
  // bother waiting until the root is complete.
  (wipLanes & suspendedLanes) === NoLanes) {
    const nextLane = getHighestPriorityLane(nextLanes);
    const wipLane = getHighestPriorityLane(wipLanes);
    if (
      // Tests whether the next lane is equal or lower priority than the wip
      // one. This works because the bits decrease in priority as you go left.
      nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
      // only difference between default updates and transition updates is that
      // default updates do not support refresh transitions.
      nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
    ) {
      return wipLanes;
    }
  }
  return nextLanes;
}
function getNextLanesToFlushSync(root2, extraLanesToForceSync) {
  const lanesToFlush = SyncUpdateLanes | extraLanesToForceSync;
  const pendingLanes = root2.pendingLanes;
  if (pendingLanes === NoLanes) {
    return NoLanes;
  }
  const suspendedLanes = root2.suspendedLanes;
  const pingedLanes = root2.pingedLanes;
  const unblockedLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);
  const unblockedLanesWithMatchingPriority = unblockedLanes & getLanesOfEqualOrHigherPriority(lanesToFlush);
  if (unblockedLanesWithMatchingPriority & HydrationLanes) {
    return unblockedLanesWithMatchingPriority & HydrationLanes | SyncHydrationLane;
  }
  if (unblockedLanesWithMatchingPriority) {
    return unblockedLanesWithMatchingPriority | SyncLane;
  }
  return NoLanes;
}
function checkIfRootIsPrerendering(root2, renderLanes2) {
  const pendingLanes = root2.pendingLanes;
  const suspendedLanes = root2.suspendedLanes;
  const pingedLanes = root2.pingedLanes;
  const unblockedLanes = pendingLanes & ~(suspendedLanes & ~pingedLanes);
  return (unblockedLanes & renderLanes2) === 0;
}
function getEntangledLanes(root2, renderLanes2) {
  let entangledLanes = renderLanes2;
  if ((entangledLanes & InputContinuousLane) !== NoLanes) {
    entangledLanes |= entangledLanes & DefaultLane;
  }
  const allEntangledLanes = root2.entangledLanes;
  if (allEntangledLanes !== NoLanes) {
    const entanglements = root2.entanglements;
    let lanes = entangledLanes & allEntangledLanes;
    while (lanes > 0) {
      const index2 = pickArbitraryLaneIndex(lanes);
      const lane = 1 << index2;
      entangledLanes |= entanglements[index2];
      lanes &= ~lane;
    }
  }
  return entangledLanes;
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case SyncHydrationLane:
    case SyncLane:
    case InputContinuousHydrationLane:
    case InputContinuousLane:
    case GestureLane:
      return currentTime + syncLaneExpirationMs;
    case DefaultHydrationLane:
    case DefaultLane:
    case TransitionHydrationLane:
    case TransitionLane1:
    case TransitionLane2:
    case TransitionLane3:
    case TransitionLane4:
    case TransitionLane5:
    case TransitionLane6:
    case TransitionLane7:
    case TransitionLane8:
    case TransitionLane9:
    case TransitionLane10:
    case TransitionLane11:
    case TransitionLane12:
    case TransitionLane13:
    case TransitionLane14:
      return currentTime + transitionLaneExpirationMs;
    case RetryLane1:
    case RetryLane2:
    case RetryLane3:
    case RetryLane4:
      return enableRetryLaneExpiration ? currentTime + retryLaneExpirationMs : NoTimestamp;
    case SelectiveHydrationLane:
    case IdleHydrationLane:
    case IdleLane:
    case OffscreenLane:
    case DeferredLane:
      return NoTimestamp;
    default:
      if (false) {
        console.error(
          "Should have found matching lanes. This is a bug in React."
        );
      }
      return NoTimestamp;
  }
}
function markStarvedLanesAsExpired(root2, currentTime) {
  const pendingLanes = root2.pendingLanes;
  const suspendedLanes = root2.suspendedLanes;
  const pingedLanes = root2.pingedLanes;
  const expirationTimes = root2.expirationTimes;
  let lanes = enableRetryLaneExpiration ? pendingLanes : pendingLanes & ~RetryLanes;
  while (lanes > 0) {
    const index2 = pickArbitraryLaneIndex(lanes);
    const lane = 1 << index2;
    const expirationTime = expirationTimes[index2];
    if (expirationTime === NoTimestamp) {
      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
        expirationTimes[index2] = computeExpirationTime(lane, currentTime);
      }
    } else if (expirationTime <= currentTime) {
      root2.expiredLanes |= lane;
    }
    lanes &= ~lane;
  }
}
function getHighestPriorityPendingLanes(root2) {
  return getHighestPriorityLanes(root2.pendingLanes);
}
function getLanesToRetrySynchronouslyOnError(root2, originallyAttemptedLanes) {
  if (root2.errorRecoveryDisabledLanes & originallyAttemptedLanes) {
    return NoLanes;
  }
  const everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
  if (everythingButOffscreen !== NoLanes) {
    return everythingButOffscreen;
  }
  if (everythingButOffscreen & OffscreenLane) {
    return OffscreenLane;
  }
  return NoLanes;
}
function includesSyncLane(lanes) {
  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
}
function isSyncLane(lanes) {
  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
}
function includesNonIdleWork(lanes) {
  return (lanes & NonIdleLanes) !== NoLanes;
}
function includesOnlyRetries(lanes) {
  return (lanes & RetryLanes) === lanes;
}
function includesOnlyNonUrgentLanes(lanes) {
  const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
  return (lanes & UrgentLanes) === NoLanes;
}
function includesOnlyTransitions(lanes) {
  return (lanes & TransitionLanes) === lanes;
}
function includesTransitionLane(lanes) {
  return (lanes & TransitionLanes) !== NoLanes;
}
function includesOnlyHydrationLanes(lanes) {
  return (lanes & HydrationLanes) === lanes;
}
function includesOnlyOffscreenLanes(lanes) {
  return (lanes & OffscreenLane) === lanes;
}
function includesOnlyHydrationOrOffscreenLanes(lanes) {
  return (lanes & (HydrationLanes | OffscreenLane)) === lanes;
}
function includesOnlyViewTransitionEligibleLanes(lanes) {
  return (lanes & (TransitionLanes | RetryLanes | IdleLane)) === lanes;
}
function includesOnlySuspenseyCommitEligibleLanes(lanes) {
  return (lanes & (TransitionLanes | RetryLanes | IdleLane | GestureLane)) === lanes;
}
function includesLoadingIndicatorLanes(lanes) {
  return (lanes & (SyncLane | DefaultLane)) !== NoLanes;
}
function includesBlockingLane(lanes) {
  const SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane | GestureLane;
  return (lanes & SyncDefaultLanes) !== NoLanes;
}
function includesExpiredLane(root2, lanes) {
  return (lanes & root2.expiredLanes) !== NoLanes;
}
function isBlockingLane(lane) {
  const SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
  return (lane & SyncDefaultLanes) !== NoLanes;
}
function isTransitionLane(lane) {
  return (lane & TransitionLanes) !== NoLanes;
}
function isGestureRender(lanes) {
  return lanes === GestureLane;
}
function claimNextTransitionLane() {
  const lane = nextTransitionLane;
  nextTransitionLane <<= 1;
  if ((nextTransitionLane & TransitionLanes) === NoLanes) {
    nextTransitionLane = TransitionLane1;
  }
  return lane;
}
function claimNextRetryLane() {
  const lane = nextRetryLane;
  nextRetryLane <<= 1;
  if ((nextRetryLane & RetryLanes) === NoLanes) {
    nextRetryLane = RetryLane1;
  }
  return lane;
}
function getHighestPriorityLane(lanes) {
  return lanes & -lanes;
}
function getLanesOfEqualOrHigherPriority(lanes) {
  const lowestPriorityLaneIndex = 31 - clz32(lanes);
  return (1 << lowestPriorityLaneIndex + 1) - 1;
}
function pickArbitraryLane(lanes) {
  return getHighestPriorityLane(lanes);
}
function pickArbitraryLaneIndex(lanes) {
  return 31 - clz32(lanes);
}
function laneToIndex(lane) {
  return pickArbitraryLaneIndex(lane);
}
function includesSomeLane(a, b) {
  return (a & b) !== NoLanes;
}
function isSubsetOfLanes(set2, subset) {
  return (set2 & subset) === subset;
}
function mergeLanes(a, b) {
  return a | b;
}
function removeLanes(set2, subset) {
  return set2 & ~subset;
}
function intersectLanes(a, b) {
  return a & b;
}
function laneToLanes(lane) {
  return lane;
}
function higherPriorityLane(a, b) {
  return a !== NoLane && a < b ? a : b;
}
function createLaneMap(initial) {
  const laneMap = [];
  for (let i = 0; i < TotalLanes; i++) {
    laneMap.push(initial);
  }
  return laneMap;
}
function markRootUpdated(root2, updateLane) {
  root2.pendingLanes |= updateLane;
  if (enableDefaultTransitionIndicator) {
    root2.indicatorLanes |= updateLane & TransitionLanes;
  }
  if (updateLane !== IdleLane) {
    root2.suspendedLanes = NoLanes;
    root2.pingedLanes = NoLanes;
    root2.warmLanes = NoLanes;
  }
}
function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
  root2.suspendedLanes |= suspendedLanes;
  root2.pingedLanes &= ~suspendedLanes;
  if (didAttemptEntireTree) {
    root2.warmLanes |= suspendedLanes;
  } else {
  }
  const expirationTimes = root2.expirationTimes;
  let lanes = suspendedLanes;
  while (lanes > 0) {
    const index2 = pickArbitraryLaneIndex(lanes);
    const lane = 1 << index2;
    expirationTimes[index2] = NoTimestamp;
    lanes &= ~lane;
  }
  if (spawnedLane !== NoLane) {
    markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
  }
}
function markRootPinged(root2, pingedLanes) {
  root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
  root2.warmLanes &= ~pingedLanes;
}
function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
  const previouslyPendingLanes = root2.pendingLanes;
  const noLongerPendingLanes = previouslyPendingLanes & ~remainingLanes;
  root2.pendingLanes = remainingLanes;
  root2.suspendedLanes = NoLanes;
  root2.pingedLanes = NoLanes;
  root2.warmLanes = NoLanes;
  if (enableDefaultTransitionIndicator) {
    root2.indicatorLanes &= remainingLanes;
  }
  root2.expiredLanes &= remainingLanes;
  root2.entangledLanes &= remainingLanes;
  root2.errorRecoveryDisabledLanes &= remainingLanes;
  root2.shellSuspendCounter = 0;
  const entanglements = root2.entanglements;
  const expirationTimes = root2.expirationTimes;
  const hiddenUpdates = root2.hiddenUpdates;
  let lanes = noLongerPendingLanes;
  while (lanes > 0) {
    const index2 = pickArbitraryLaneIndex(lanes);
    const lane = 1 << index2;
    entanglements[index2] = NoLanes;
    expirationTimes[index2] = NoTimestamp;
    const hiddenUpdatesForLane = hiddenUpdates[index2];
    if (hiddenUpdatesForLane !== null) {
      hiddenUpdates[index2] = null;
      for (let i = 0; i < hiddenUpdatesForLane.length; i++) {
        const update = hiddenUpdatesForLane[i];
        if (update !== null) {
          update.lane &= ~OffscreenLane;
        }
      }
    }
    lanes &= ~lane;
  }
  if (spawnedLane !== NoLane) {
    markSpawnedDeferredLane(
      root2,
      spawnedLane,
      // This render finished successfully without suspending, so we don't need
      // to entangle the spawned task with the parent task.
      NoLanes
    );
  }
  if (suspendedRetryLanes !== NoLanes && // Note that we only do this if there were no updates since we started
  // rendering. This mirrors the logic in markRootUpdated — whenever we
  // receive an update, we reset all the suspended and pinged lanes.
  updatedLanes === NoLanes && !(disableLegacyMode && root2.tag === LegacyRoot)) {
    const freshlySpawnedRetryLanes = suspendedRetryLanes & // Remove any retry lane that was already pending before our just-finished
    // attempt, and also wasn't included in that attempt.
    ~(previouslyPendingLanes & ~finishedLanes);
    root2.suspendedLanes |= freshlySpawnedRetryLanes;
  }
}
function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
  root2.pendingLanes |= spawnedLane;
  root2.suspendedLanes &= ~spawnedLane;
  const spawnedLaneIndex = laneToIndex(spawnedLane);
  root2.entangledLanes |= spawnedLane;
  root2.entanglements[spawnedLaneIndex] |= DeferredLane | // If the parent render task suspended, we must also entangle those lanes
  // with the spawned task, so that the deferred task includes all the same
  // updates that the parent task did. We can exclude any lane that is not
  // used for updates (e.g. Offscreen).
  entangledLanes & UpdateLanes;
}
function markRootEntangled(root2, entangledLanes) {
  const rootEntangledLanes = root2.entangledLanes |= entangledLanes;
  const entanglements = root2.entanglements;
  let lanes = rootEntangledLanes;
  while (lanes) {
    const index2 = pickArbitraryLaneIndex(lanes);
    const lane = 1 << index2;
    if (
      // Is this one of the newly entangled lanes?
      lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
      entanglements[index2] & entangledLanes
    ) {
      entanglements[index2] |= entangledLanes;
    }
    lanes &= ~lane;
  }
}
function upgradePendingLanesToSync(root2, lanesToUpgrade) {
  root2.pendingLanes |= SyncLane;
  root2.entangledLanes |= SyncLane;
  let lanes = lanesToUpgrade;
  while (lanes) {
    const index2 = pickArbitraryLaneIndex(lanes);
    const lane = 1 << index2;
    root2.entanglements[SyncLaneIndex] |= lane;
    lanes &= ~lane;
  }
}
function markHiddenUpdate(root2, update, lane) {
  const index2 = laneToIndex(lane);
  const hiddenUpdates = root2.hiddenUpdates;
  const hiddenUpdatesForLane = hiddenUpdates[index2];
  if (hiddenUpdatesForLane === null) {
    hiddenUpdates[index2] = [update];
  } else {
    hiddenUpdatesForLane.push(update);
  }
  update.lane = lane | OffscreenLane;
}
function getBumpedLaneForHydration(root2, renderLanes2) {
  const renderLane = getHighestPriorityLane(renderLanes2);
  const bumpedLane = (renderLane & SyncUpdateLanes) !== NoLane ? (
    // Unify sync lanes. We don't do this inside getBumpedLaneForHydrationByLane
    // because that causes things to flush synchronously when they shouldn't.
    // TODO: This is not coherent but that's beacuse the unification is not coherent.
    // We need to get merge these into an actual single lane.
    SyncHydrationLane
  ) : getBumpedLaneForHydrationByLane(renderLane);
  if ((bumpedLane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
    return NoLane;
  }
  return bumpedLane;
}
function getBumpedLaneForHydrationByLane(lane) {
  switch (lane) {
    case SyncLane:
      lane = SyncHydrationLane;
      break;
    case InputContinuousLane:
      lane = InputContinuousHydrationLane;
      break;
    case DefaultLane:
      lane = DefaultHydrationLane;
      break;
    case TransitionLane1:
    case TransitionLane2:
    case TransitionLane3:
    case TransitionLane4:
    case TransitionLane5:
    case TransitionLane6:
    case TransitionLane7:
    case TransitionLane8:
    case TransitionLane9:
    case TransitionLane10:
    case TransitionLane11:
    case TransitionLane12:
    case TransitionLane13:
    case TransitionLane14:
    case RetryLane1:
    case RetryLane2:
    case RetryLane3:
    case RetryLane4:
      lane = TransitionHydrationLane;
      break;
    case IdleLane:
      lane = IdleHydrationLane;
      break;
    default:
      lane = NoLane;
      break;
  }
  return lane;
}
function addFiberToLanesMap(root2, fiber, lanes) {
  if (!enableUpdaterTracking) {
    return;
  }
  if (!isDevToolsPresent) {
    return;
  }
  const pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
  while (lanes > 0) {
    const index2 = laneToIndex(lanes);
    const lane = 1 << index2;
    const updaters = pendingUpdatersLaneMap[index2];
    updaters.add(fiber);
    lanes &= ~lane;
  }
}
function movePendingFibersToMemoized(root2, lanes) {
  if (!enableUpdaterTracking) {
    return;
  }
  if (!isDevToolsPresent) {
    return;
  }
  const pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
  const memoizedUpdaters = root2.memoizedUpdaters;
  while (lanes > 0) {
    const index2 = laneToIndex(lanes);
    const lane = 1 << index2;
    const updaters = pendingUpdatersLaneMap[index2];
    if (updaters.size > 0) {
      updaters.forEach((fiber) => {
        const alternate = fiber.alternate;
        if (alternate === null || !memoizedUpdaters.has(alternate)) {
          memoizedUpdaters.add(fiber);
        }
      });
      updaters.clear();
    }
    lanes &= ~lane;
  }
}
function addTransitionToLanesMap(root2, transition, lane) {
  if (enableTransitionTracing) {
    const transitionLanesMap = root2.transitionLanes;
    const index2 = laneToIndex(lane);
    let transitions = transitionLanesMap[index2];
    if (transitions === null) {
      transitions = /* @__PURE__ */ new Set();
    }
    transitions.add(transition);
    transitionLanesMap[index2] = transitions;
  }
}
function getTransitionsForLanes(root2, lanes) {
  if (!enableTransitionTracing) {
    return null;
  }
  const transitionsForLanes = [];
  while (lanes > 0) {
    const index2 = laneToIndex(lanes);
    const lane = 1 << index2;
    const transitions = root2.transitionLanes[index2];
    if (transitions !== null) {
      transitions.forEach((transition) => {
        transitionsForLanes.push(transition);
      });
    }
    lanes &= ~lane;
  }
  if (transitionsForLanes.length === 0) {
    return null;
  }
  return transitionsForLanes;
}
function clearTransitionsForLanes(root2, lanes) {
  if (!enableTransitionTracing) {
    return;
  }
  while (lanes > 0) {
    const index2 = laneToIndex(lanes);
    const lane = 1 << index2;
    const transitions = root2.transitionLanes[index2];
    if (transitions !== null) {
      root2.transitionLanes[index2] = null;
    }
    lanes &= ~lane;
  }
}
function getGroupNameOfHighestPriorityLane(lanes) {
  if (lanes & (SyncHydrationLane | SyncLane | InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane | GestureLane)) {
    return "Blocking";
  }
  if (lanes & (TransitionHydrationLane | TransitionLanes)) {
    return "Transition";
  }
  if (lanes & RetryLanes) {
    return "Suspense";
  }
  if (lanes & (SelectiveHydrationLane | IdleHydrationLane | IdleLane | OffscreenLane | DeferredLane)) {
    return "Idle";
  }
  return "Other";
}

// dist/react-reconciler/src/ReactEventPriorities.js
var NoEventPriority = NoLane;
var DiscreteEventPriority = SyncLane;
var ContinuousEventPriority = InputContinuousLane;
var DefaultEventPriority = DefaultLane;
var IdleEventPriority = IdleLane;
function higherEventPriority(a, b) {
  return a !== 0 && a < b ? a : b;
}
function lowerEventPriority(a, b) {
  return a === 0 || a > b ? a : b;
}
function isHigherEventPriority(a, b) {
  return a !== 0 && a < b;
}
function eventPriorityToLane(updatePriority) {
  return updatePriority;
}
function lanesToEventPriority(lanes) {
  const lane = getHighestPriorityLane(lanes);
  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
    return DiscreteEventPriority;
  }
  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
    return ContinuousEventPriority;
  }
  if (includesNonIdleWork(lane)) {
    return DefaultEventPriority;
  }
  return IdleEventPriority;
}

// dist/react-reconciler/src/Scheduler.js
var scheduleCallback = unstable_scheduleCallback;
var cancelCallback = unstable_cancelCallback;
var shouldYield = shouldYieldToHost;
var requestPaint2 = requestPaint;
var now = getCurrentTime;
var getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
var ImmediatePriority2 = ImmediatePriority;
var UserBlockingPriority2 = UserBlockingPriority;
var NormalPriority2 = NormalPriority;
var LowPriority2 = LowPriority;
var IdlePriority2 = IdlePriority;
var log3 = void 0;
var unstable_setDisableYieldValue2 = void 0;

// dist/react-reconciler/src/ReactFiberDevToolsHook.js
var rendererID = null;
var injectedHook = null;
var injectedProfilingHooks = null;
var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
    return false;
  }
  const hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    return true;
  }
  if (!hook.supportsFiber) {
    if (false) {
      console.error(
        "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
      );
    }
    return true;
  }
  try {
    rendererID = hook.inject(internals);
    injectedHook = hook;
  } catch (err) {
    if (false) {
      console.error("React instrumentation encountered an error: %s.", err);
    }
  }
  if (hook.checkDCE) {
    return true;
  } else {
    return false;
  }
}
function onCommitRoot(root2, eventPriority) {
  if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
    try {
      const didError = (root2.current.flags & DidCapture) === DidCapture;
      if (enableProfilerTimer) {
        let schedulerPriority;
        switch (eventPriority) {
          case DiscreteEventPriority:
            schedulerPriority = ImmediatePriority2;
            break;
          case ContinuousEventPriority:
            schedulerPriority = UserBlockingPriority2;
            break;
          case DefaultEventPriority:
            schedulerPriority = NormalPriority2;
            break;
          case IdleEventPriority:
            schedulerPriority = IdlePriority2;
            break;
          default:
            schedulerPriority = NormalPriority2;
            break;
        }
        injectedHook.onCommitFiberRoot(
          rendererID,
          root2,
          schedulerPriority,
          didError
        );
      } else {
        injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
      }
    } catch (err) {
      if (false) {
        if (!hasLoggedError) {
          hasLoggedError = true;
          console.error("React instrumentation encountered an error: %s", err);
        }
      }
    }
  }
}
function onPostCommitRoot(root2) {
  if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
    try {
      injectedHook.onPostCommitFiberRoot(rendererID, root2);
    } catch (err) {
      if (false) {
        if (!hasLoggedError) {
          hasLoggedError = true;
          console.error("React instrumentation encountered an error: %s", err);
        }
      }
    }
  }
}
function onCommitUnmount(fiber) {
  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
    try {
      injectedHook.onCommitFiberUnmount(rendererID, fiber);
    } catch (err) {
      if (false) {
        if (!hasLoggedError) {
          hasLoggedError = true;
          console.error("React instrumentation encountered an error: %s", err);
        }
      }
    }
  }
}
function setIsStrictModeForDevtools(newIsStrictMode) {
  if (typeof log3 === "function") {
    unstable_setDisableYieldValue2(newIsStrictMode);
  }
  if (injectedHook && typeof injectedHook.setStrictMode === "function") {
    try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {
      if (false) {
        if (!hasLoggedError) {
          hasLoggedError = true;
          console.error("React instrumentation encountered an error: %s", err);
        }
      }
    }
  }
}
function injectProfilingHooks(profilingHooks) {
  injectedProfilingHooks = profilingHooks;
}
function markCommitStarted(lanes) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
      injectedProfilingHooks.markCommitStarted(lanes);
    }
  }
}
function markCommitStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
      injectedProfilingHooks.markCommitStopped();
    }
  }
}
function markComponentRenderStarted(fiber) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
      injectedProfilingHooks.markComponentRenderStarted(fiber);
    }
  }
}
function markComponentRenderStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
      injectedProfilingHooks.markComponentRenderStopped();
    }
  }
}
function markComponentPassiveEffectMountStarted(fiber) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
      injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
    }
  }
}
function markComponentPassiveEffectMountStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
      injectedProfilingHooks.markComponentPassiveEffectMountStopped();
    }
  }
}
function markComponentPassiveEffectUnmountStarted(fiber) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
      injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
    }
  }
}
function markComponentPassiveEffectUnmountStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
      injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
    }
  }
}
function markComponentLayoutEffectMountStarted(fiber) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
      injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
    }
  }
}
function markComponentLayoutEffectMountStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
      injectedProfilingHooks.markComponentLayoutEffectMountStopped();
    }
  }
}
function markComponentLayoutEffectUnmountStarted(fiber) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
      injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
    }
  }
}
function markComponentLayoutEffectUnmountStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
      injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
    }
  }
}
function markComponentErrored(fiber, thrownValue, lanes) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
      injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
    }
  }
}
function markComponentSuspended(fiber, wakeable, lanes) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
      injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
    }
  }
}
function markLayoutEffectsStarted(lanes) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
      injectedProfilingHooks.markLayoutEffectsStarted(lanes);
    }
  }
}
function markLayoutEffectsStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
      injectedProfilingHooks.markLayoutEffectsStopped();
    }
  }
}
function markPassiveEffectsStarted(lanes) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
      injectedProfilingHooks.markPassiveEffectsStarted(lanes);
    }
  }
}
function markPassiveEffectsStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
      injectedProfilingHooks.markPassiveEffectsStopped();
    }
  }
}
function markRenderStarted(lanes) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
      injectedProfilingHooks.markRenderStarted(lanes);
    }
  }
}
function markRenderYielded() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
      injectedProfilingHooks.markRenderYielded();
    }
  }
}
function markRenderStopped() {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
      injectedProfilingHooks.markRenderStopped();
    }
  }
}
function markRenderScheduled(lane) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
      injectedProfilingHooks.markRenderScheduled(lane);
    }
  }
}
function markForceUpdateScheduled(fiber, lane) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
      injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
    }
  }
}
function markStateUpdateScheduled(fiber, lane) {
  if (enableSchedulingProfiler) {
    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
      injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
    }
  }
}

// dist/react-reconciler/src/ReactFiberViewTransitionComponent.js
var globalClientIdCounter = 0;
function getViewTransitionName(props, instance) {
  if (props.name != null && props.name !== "auto") {
    return props.name;
  }
  if (instance.autoName !== null) {
    return instance.autoName;
  }
  const root2 = getCommittingRoot();
  const identifierPrefix = root2.identifierPrefix;
  const globalClientId = globalClientIdCounter++;
  const name = "\xAB" + identifierPrefix + "t" + globalClientId.toString(32) + "\xBB";
  instance.autoName = name;
  return name;
}
function getClassNameByType(classByType) {
  if (classByType == null || typeof classByType === "string") {
    return classByType;
  }
  let className = null;
  const activeTypes = getPendingTransitionTypes();
  if (activeTypes !== null) {
    for (let i = 0; i < activeTypes.length; i++) {
      const match = classByType[activeTypes[i]];
      if (match != null) {
        if (match === "none") {
          return "none";
        }
        if (className == null) {
          className = match;
        } else {
          className += " " + match;
        }
      }
    }
  }
  if (className == null) {
    return classByType.default;
  }
  return className;
}
function getViewTransitionClassName(defaultClass, eventClass) {
  const className = getClassNameByType(defaultClass);
  const eventClassName = getClassNameByType(eventClass);
  if (eventClassName == null) {
    return className === "auto" ? null : className;
  }
  if (eventClassName === "auto") {
    return null;
  }
  return eventClassName;
}

// dist/shared/ReactOwnerStackReset.js
var getCurrentTime2;
var hasPerformanceNow2 = (
  // $FlowFixMe[method-unbinding]
  typeof performance === "object" && typeof performance.now === "function"
);
if (hasPerformanceNow2) {
  const localPerformance = performance;
  getCurrentTime2 = () => localPerformance.now();
} else {
  const localDate = Date;
  getCurrentTime2 = () => localDate.now();
}

// dist/shared/objectIs.js
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}
var objectIs = (
  // $FlowFixMe[method-unbinding]
  typeof Object.is === "function" ? Object.is : is
);
var objectIs_default = objectIs;

// dist/react-reconciler/src/ReactFiberPerformanceTrack.js
var supportsUserTiming = enableProfilerTimer && typeof console !== "undefined" && typeof console.timeStamp === "function";
var COMPONENTS_TRACK = "Components \u269B";
var LANES_TRACK_GROUP = "Scheduler \u269B";
var currentTrack = "Blocking";
var reusableLaneDevToolDetails = {
  color: "primary",
  track: "Blocking",
  // Lane
  trackGroup: LANES_TRACK_GROUP
};
var reusableLaneOptions = {
  start: -0,
  end: -0,
  detail: {
    devtools: reusableLaneDevToolDetails
  }
};
function setCurrentTrackFromLanes(lanes) {
  currentTrack = getGroupNameOfHighestPriorityLane(lanes);
}
function markAllLanesInOrder() {
  if (supportsUserTiming) {
    console.timeStamp(
      "Blocking Track",
      3e-3,
      3e-3,
      "Blocking",
      LANES_TRACK_GROUP,
      "primary-light"
    );
    console.timeStamp(
      "Transition Track",
      3e-3,
      3e-3,
      "Transition",
      LANES_TRACK_GROUP,
      "primary-light"
    );
    console.timeStamp(
      "Suspense Track",
      3e-3,
      3e-3,
      "Suspense",
      LANES_TRACK_GROUP,
      "primary-light"
    );
    console.timeStamp(
      "Idle Track",
      3e-3,
      3e-3,
      "Idle",
      LANES_TRACK_GROUP,
      "primary-light"
    );
  }
}
function logComponentTrigger(fiber, startTime2, endTime, trigger) {
  if (supportsUserTiming) {
    const debugTask = fiber._debugTask;
    if (false) {
      debugTask.run(
        console.timeStamp.bind(
          console,
          trigger,
          startTime2,
          endTime,
          COMPONENTS_TRACK,
          void 0,
          "warning"
        )
      );
    } else {
      console.timeStamp(
        trigger,
        startTime2,
        endTime,
        COMPONENTS_TRACK,
        void 0,
        "warning"
      );
    }
  }
}
function logComponentMount(fiber, startTime2, endTime) {
  logComponentTrigger(fiber, startTime2, endTime, "Mount");
}
function logComponentUnmount(fiber, startTime2, endTime) {
  logComponentTrigger(fiber, startTime2, endTime, "Unmount");
}
function logComponentReappeared(fiber, startTime2, endTime) {
  logComponentTrigger(fiber, startTime2, endTime, "Reconnect");
}
function logComponentDisappeared(fiber, startTime2, endTime) {
  logComponentTrigger(fiber, startTime2, endTime, "Disconnect");
}
function logComponentRender(fiber, startTime2, endTime, wasHydrated) {
  const name = getComponentNameFromFiber(fiber);
  if (name === null) {
    return;
  }
  if (supportsUserTiming) {
    let selfTime = fiber.actualDuration;
    if (fiber.alternate === null || fiber.alternate.child !== fiber.child) {
      for (let child = fiber.child; child !== null; child = child.sibling) {
        selfTime -= child.actualDuration;
      }
    }
    const color = selfTime < 0.5 ? wasHydrated ? "tertiary-light" : "primary-light" : selfTime < 10 ? wasHydrated ? "tertiary" : "primary" : selfTime < 100 ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
    const debugTask = fiber._debugTask;
    if (false) {
      debugTask.run(
        // $FlowFixMe[method-unbinding]
        console.timeStamp.bind(
          console,
          name,
          startTime2,
          endTime,
          COMPONENTS_TRACK,
          void 0,
          color
        )
      );
    } else {
      console.timeStamp(
        name,
        startTime2,
        endTime,
        COMPONENTS_TRACK,
        void 0,
        color
      );
    }
  }
}
function logComponentErrored(fiber, startTime2, endTime, errors) {
  if (supportsUserTiming) {
    const name = getComponentNameFromFiber(fiber);
    if (name === null) {
      return;
    }
    if (false) {
      let debugTask = null;
      const properties = [];
      for (let i = 0; i < errors.length; i++) {
        const capturedValue = errors[i];
        if (debugTask == null && capturedValue.source !== null) {
          debugTask = capturedValue.source._debugTask;
        }
        const error = capturedValue.value;
        const message = typeof error === "object" && error !== null && typeof error.message === "string" ? (
          // eslint-disable-next-line react-internal/safe-string-coercion
          String(error.message)
        ) : (
          // eslint-disable-next-line react-internal/safe-string-coercion
          String(error)
        );
        properties.push(["Error", message]);
      }
      if (debugTask == null) {
        debugTask = fiber._debugTask;
      }
      const options = {
        start: startTime2,
        end: endTime,
        detail: {
          devtools: {
            color: "error",
            track: COMPONENTS_TRACK,
            tooltipText: fiber.tag === SuspenseComponent ? "Hydration failed" : "Error boundary caught an error",
            properties
          }
        }
      };
      if (false) {
        debugTask.run(
          // $FlowFixMe[method-unbinding]
          performance.measure.bind(performance, name, options)
        );
      } else {
        performance.measure(name, options);
      }
    } else {
      console.timeStamp(
        name,
        startTime2,
        endTime,
        COMPONENTS_TRACK,
        void 0,
        "error"
      );
    }
  }
}
function logComponentEffectErrored(fiber, startTime2, endTime, errors) {
  if (supportsUserTiming) {
    const name = getComponentNameFromFiber(fiber);
    if (name === null) {
      return;
    }
    if (false) {
      const properties = [];
      for (let i = 0; i < errors.length; i++) {
        const capturedValue = errors[i];
        const error = capturedValue.value;
        const message = typeof error === "object" && error !== null && typeof error.message === "string" ? (
          // eslint-disable-next-line react-internal/safe-string-coercion
          String(error.message)
        ) : (
          // eslint-disable-next-line react-internal/safe-string-coercion
          String(error)
        );
        properties.push(["Error", message]);
      }
      const options = {
        start: startTime2,
        end: endTime,
        detail: {
          devtools: {
            color: "error",
            track: COMPONENTS_TRACK,
            tooltipText: "A lifecycle or effect errored",
            properties
          }
        }
      };
      const debugTask = fiber._debugTask;
      if (debugTask) {
        debugTask.run(
          // $FlowFixMe[method-unbinding]
          performance.measure.bind(performance, name, options)
        );
      } else {
        performance.measure(name, options);
      }
    } else {
      console.timeStamp(
        name,
        startTime2,
        endTime,
        COMPONENTS_TRACK,
        void 0,
        "error"
      );
    }
  }
}
function logComponentEffect(fiber, startTime2, endTime, selfTime, errors) {
  if (errors !== null) {
    logComponentEffectErrored(fiber, startTime2, endTime, errors);
    return;
  }
  const name = getComponentNameFromFiber(fiber);
  if (name === null) {
    return;
  }
  if (supportsUserTiming) {
    const color = selfTime < 1 ? "secondary-light" : selfTime < 100 ? "secondary" : selfTime < 500 ? "secondary-dark" : "error";
    const debugTask = fiber._debugTask;
    if (false) {
      debugTask.run(
        // $FlowFixMe[method-unbinding]
        console.timeStamp.bind(
          console,
          name,
          startTime2,
          endTime,
          COMPONENTS_TRACK,
          void 0,
          color
        )
      );
    } else {
      console.timeStamp(
        name,
        startTime2,
        endTime,
        COMPONENTS_TRACK,
        void 0,
        color
      );
    }
  }
}
function logYieldTime(startTime2, endTime) {
  if (supportsUserTiming) {
    const yieldDuration = endTime - startTime2;
    if (yieldDuration < 3) {
      return;
    }
    const color = yieldDuration < 5 ? "primary-light" : yieldDuration < 10 ? "primary" : yieldDuration < 100 ? "primary-dark" : "error";
    console.timeStamp(
      "Blocked",
      startTime2,
      endTime,
      COMPONENTS_TRACK,
      void 0,
      color
    );
  }
}
function logSuspendedYieldTime(startTime2, endTime, suspendedFiber) {
  if (supportsUserTiming) {
    const debugTask = suspendedFiber._debugTask;
    if (false) {
      debugTask.run(
        // $FlowFixMe[method-unbinding]
        console.timeStamp.bind(
          console,
          "Suspended",
          startTime2,
          endTime,
          COMPONENTS_TRACK,
          void 0,
          "primary-light"
        )
      );
    } else {
      console.timeStamp(
        "Suspended",
        startTime2,
        endTime,
        COMPONENTS_TRACK,
        void 0,
        "primary-light"
      );
    }
  }
}
function logActionYieldTime(startTime2, endTime, suspendedFiber) {
  if (supportsUserTiming) {
    const debugTask = suspendedFiber._debugTask;
    if (false) {
      debugTask.run(
        // $FlowFixMe[method-unbinding]
        console.timeStamp.bind(
          console,
          "Action",
          startTime2,
          endTime,
          COMPONENTS_TRACK,
          void 0,
          "primary-light"
        )
      );
    } else {
      console.timeStamp(
        "Action",
        startTime2,
        endTime,
        COMPONENTS_TRACK,
        void 0,
        "primary-light"
      );
    }
  }
}
function logBlockingStart(updateTime, eventTime, eventType, eventIsRepeat, isSpawnedUpdate, renderStartTime2, lanes, debugTask) {
  if (supportsUserTiming) {
    currentTrack = "Blocking";
    if (eventTime > 0 && eventType !== null) {
      const color = eventIsRepeat ? "secondary-light" : "warning";
      if (false) {
        debugTask.run(
          // $FlowFixMe[method-unbinding]
          console.timeStamp.bind(
            console,
            eventIsRepeat ? "" : "Event: " + eventType,
            eventTime,
            updateTime > 0 ? updateTime : renderStartTime2,
            currentTrack,
            LANES_TRACK_GROUP,
            color
          )
        );
      } else {
        console.timeStamp(
          eventIsRepeat ? "" : "Event: " + eventType,
          eventTime,
          updateTime > 0 ? updateTime : renderStartTime2,
          currentTrack,
          LANES_TRACK_GROUP,
          color
        );
      }
    }
    if (updateTime > 0) {
      const color = isSpawnedUpdate ? "error" : includesOnlyHydrationOrOffscreenLanes(lanes) ? "tertiary-light" : "primary-light";
      if (false) {
        debugTask.run(
          // $FlowFixMe[method-unbinding]
          console.timeStamp.bind(
            console,
            isSpawnedUpdate ? "Cascading Update" : renderStartTime2 - updateTime > 5 ? "Update Blocked" : "Update",
            updateTime,
            renderStartTime2,
            currentTrack,
            LANES_TRACK_GROUP,
            color
          )
        );
      } else {
        console.timeStamp(
          isSpawnedUpdate ? "Cascading Update" : renderStartTime2 - updateTime > 5 ? "Update Blocked" : "Update",
          updateTime,
          renderStartTime2,
          currentTrack,
          LANES_TRACK_GROUP,
          color
        );
      }
    }
  }
}
function logTransitionStart(startTime2, updateTime, eventTime, eventType, eventIsRepeat, renderStartTime2, debugTask) {
  if (supportsUserTiming) {
    currentTrack = "Transition";
    if (eventTime > 0 && eventType !== null) {
      const color = eventIsRepeat ? "secondary-light" : "warning";
      const endTime = startTime2 > 0 ? startTime2 : updateTime > 0 ? updateTime : renderStartTime2;
      if (false) {
        debugTask.run(
          // $FlowFixMe[method-unbinding]
          console.timeStamp.bind(
            console,
            eventIsRepeat ? "" : "Event: " + eventType,
            eventTime,
            endTime,
            currentTrack,
            LANES_TRACK_GROUP,
            color
          )
        );
      } else {
        console.timeStamp(
          eventIsRepeat ? "" : "Event: " + eventType,
          eventTime,
          endTime,
          currentTrack,
          LANES_TRACK_GROUP,
          color
        );
      }
    }
    if (startTime2 > 0) {
      if (false) {
        debugTask.run(
          // $FlowFixMe[method-unbinding]
          console.timeStamp.bind(
            console,
            "Action",
            startTime2,
            updateTime > 0 ? updateTime : renderStartTime2,
            currentTrack,
            LANES_TRACK_GROUP,
            "primary-dark"
          )
        );
      } else {
        console.timeStamp(
          "Action",
          startTime2,
          updateTime > 0 ? updateTime : renderStartTime2,
          currentTrack,
          LANES_TRACK_GROUP,
          "primary-dark"
        );
      }
    }
    if (updateTime > 0) {
      if (false) {
        debugTask.run(
          // $FlowFixMe[method-unbinding]
          console.timeStamp.bind(
            console,
            renderStartTime2 - updateTime > 5 ? "Update Blocked" : "Update",
            updateTime,
            renderStartTime2,
            currentTrack,
            LANES_TRACK_GROUP,
            "primary-light"
          )
        );
      } else {
        console.timeStamp(
          renderStartTime2 - updateTime > 5 ? "Update Blocked" : "Update",
          updateTime,
          renderStartTime2,
          currentTrack,
          LANES_TRACK_GROUP,
          "primary-light"
        );
      }
    }
  }
}
function logRenderPhase(startTime2, endTime, lanes) {
  if (supportsUserTiming) {
    const color = includesOnlyHydrationOrOffscreenLanes(lanes) ? "tertiary-dark" : "primary-dark";
    console.timeStamp(
      includesOnlyOffscreenLanes(lanes) ? "Prepared" : includesOnlyHydrationLanes(lanes) ? "Hydrated" : "Render",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      color
    );
  }
}
function logInterruptedRenderPhase(startTime2, endTime, lanes) {
  if (supportsUserTiming) {
    const color = includesOnlyHydrationOrOffscreenLanes(lanes) ? "tertiary-dark" : "primary-dark";
    console.timeStamp(
      includesOnlyOffscreenLanes(lanes) ? "Prewarm" : includesOnlyHydrationLanes(lanes) ? "Interrupted Hydration" : "Interrupted Render",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      color
    );
  }
}
function logSuspendedRenderPhase(startTime2, endTime, lanes) {
  if (supportsUserTiming) {
    const color = includesOnlyHydrationOrOffscreenLanes(lanes) ? "tertiary-dark" : "primary-dark";
    console.timeStamp(
      "Prewarm",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      color
    );
  }
}
function logSuspendedWithDelayPhase(startTime2, endTime, lanes) {
  if (supportsUserTiming) {
    const color = includesOnlyHydrationOrOffscreenLanes(lanes) ? "tertiary-dark" : "primary-dark";
    console.timeStamp(
      "Suspended",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      color
    );
  }
}
function logRecoveredRenderPhase(startTime2, endTime, lanes, recoverableErrors, hydrationFailed) {
  if (supportsUserTiming) {
    if (false) {
      const properties = [];
      for (let i = 0; i < recoverableErrors.length; i++) {
        const capturedValue = recoverableErrors[i];
        const error = capturedValue.value;
        const message = typeof error === "object" && error !== null && typeof error.message === "string" ? (
          // eslint-disable-next-line react-internal/safe-string-coercion
          String(error.message)
        ) : (
          // eslint-disable-next-line react-internal/safe-string-coercion
          String(error)
        );
        properties.push(["Recoverable Error", message]);
      }
      performance.measure("Recovered", {
        start: startTime2,
        end: endTime,
        detail: {
          devtools: {
            color: "primary-dark",
            track: currentTrack,
            trackGroup: LANES_TRACK_GROUP,
            tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
            properties
          }
        }
      });
    } else {
      console.timeStamp(
        "Recovered",
        startTime2,
        endTime,
        currentTrack,
        LANES_TRACK_GROUP,
        "error"
      );
    }
  }
}
function logErroredRenderPhase(startTime2, endTime, lanes) {
  if (supportsUserTiming) {
    console.timeStamp(
      "Errored",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      "error"
    );
  }
}
function logInconsistentRender(startTime2, endTime) {
  if (supportsUserTiming) {
    console.timeStamp(
      "Teared Render",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      "error"
    );
  }
}
function logSuspenseThrottlePhase(startTime2, endTime) {
  if (supportsUserTiming) {
    console.timeStamp(
      "Throttled",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      "secondary-light"
    );
  }
}
function logSuspendedCommitPhase(startTime2, endTime) {
  if (supportsUserTiming) {
    console.timeStamp(
      "Suspended on CSS or Images",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      "secondary-light"
    );
  }
}
function logCommitErrored(startTime2, endTime, errors, passive) {
  if (supportsUserTiming) {
    if (false) {
      const properties = [];
      for (let i = 0; i < errors.length; i++) {
        const capturedValue = errors[i];
        const error = capturedValue.value;
        const message = typeof error === "object" && error !== null && typeof error.message === "string" ? (
          // eslint-disable-next-line react-internal/safe-string-coercion
          String(error.message)
        ) : (
          // eslint-disable-next-line react-internal/safe-string-coercion
          String(error)
        );
        properties.push(["Error", message]);
      }
      performance.measure("Errored", {
        start: startTime2,
        end: endTime,
        detail: {
          devtools: {
            color: "error",
            track: currentTrack,
            trackGroup: LANES_TRACK_GROUP,
            tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
            properties
          }
        }
      });
    } else {
      console.timeStamp(
        "Errored",
        startTime2,
        endTime,
        currentTrack,
        LANES_TRACK_GROUP,
        "error"
      );
    }
  }
}
function logCommitPhase(startTime2, endTime, errors) {
  if (errors !== null) {
    logCommitErrored(startTime2, endTime, errors, false);
    return;
  }
  if (supportsUserTiming) {
    reusableLaneOptions.start = startTime2;
    reusableLaneOptions.end = endTime;
    console.timeStamp(
      "Commit",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      "secondary-dark"
    );
  }
}
function logPaintYieldPhase(startTime2, endTime, delayedUntilPaint) {
  if (supportsUserTiming) {
    console.timeStamp(
      delayedUntilPaint ? "Waiting for Paint" : "",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      "secondary-light"
    );
  }
}
function logPassiveCommitPhase(startTime2, endTime, errors) {
  if (errors !== null) {
    logCommitErrored(startTime2, endTime, errors, true);
    return;
  }
  if (supportsUserTiming) {
    console.timeStamp(
      "Remaining Effects",
      startTime2,
      endTime,
      currentTrack,
      LANES_TRACK_GROUP,
      "secondary-dark"
    );
  }
}

// dist/react-reconciler/src/ReactFiberShellHydration.js
function isRootDehydrated(root2) {
  const currentState = root2.current.memoizedState;
  return currentState.isDehydrated;
}

// dist/shared/ConsolePatchingDev.js
function disabledLog() {
}
disabledLog.__reactDisabledLog = true;

// dist/shared/DefaultPrepareStackTrace.js
var DefaultPrepareStackTrace_default = void 0;

// dist/shared/ReactComponentStackFrame.js
var prefix;
var suffix;
function describeBuiltInComponentFrame(name) {
  if (prefix === void 0) {
    try {
      throw Error();
    } catch (x) {
      const match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = x.stack.indexOf("\n    at") > -1 ? (
        // V8
        " (<anonymous>)"
      ) : (
        // JSC/Spidermonkey
        x.stack.indexOf("@") > -1 ? "@unknown:0:0" : (
          // Other
          ""
        )
      );
    }
  }
  return "\n" + prefix + name + suffix;
}
var reentry = false;
if (false) {
  const PossiblyWeakMap2 = typeof WeakMap === "function" ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap2();
}
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry) {
    return "";
  }
  if (false) {
    const frame = componentFrameCache.get(fn);
    if (frame !== void 0) {
      return frame;
    }
  }
  reentry = true;
  const previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = DefaultPrepareStackTrace_default;
  let previousDispatcher2 = null;
  if (false) {
    previousDispatcher2 = ReactSharedInternals_default.H;
    ReactSharedInternals_default.H = null;
    disableLogs();
  }
  try {
    const RunInRootFrame = {
      DetermineComponentFrameRoot() {
        let control;
        try {
          if (construct) {
            const Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            const maybePromise = fn();
            if (maybePromise && typeof maybePromise.catch === "function") {
              maybePromise.catch(() => {
              });
            }
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            return [sample.stack, control.stack];
          }
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
    const namePropDescriptor = Object.getOwnPropertyDescriptor(
      RunInRootFrame.DetermineComponentFrameRoot,
      "name"
    );
    if (namePropDescriptor && namePropDescriptor.configurable) {
      Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        // Configurable properties can be updated even if its writable descriptor
        // is set to `false`.
        // $FlowFixMe[cannot-write]
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
    }
    const [sampleStack, controlStack] = RunInRootFrame.DetermineComponentFrameRoot();
    if (sampleStack && controlStack) {
      const sampleLines = sampleStack.split("\n");
      const controlLines = controlStack.split("\n");
      let s = 0;
      let c = 0;
      while (s < sampleLines.length && !sampleLines[s].includes("DetermineComponentFrameRoot")) {
        s++;
      }
      while (c < controlLines.length && !controlLines[c].includes("DetermineComponentFrameRoot")) {
        c++;
      }
      if (s === sampleLines.length || c === controlLines.length) {
        s = sampleLines.length - 1;
        c = controlLines.length - 1;
        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
          c--;
        }
      }
      for (; s >= 1 && c >= 0; s--, c--) {
        if (sampleLines[s] !== controlLines[c]) {
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--;
              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                let frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                if (fn.displayName && frame.includes("<anonymous>")) {
                  frame = frame.replace("<anonymous>", fn.displayName);
                }
                if (false) {
                  if (typeof fn === "function") {
                    componentFrameCache.set(fn, frame);
                  }
                }
                return frame;
              }
            } while (s >= 1 && c >= 0);
          }
          break;
        }
      }
    }
  } finally {
    reentry = false;
    if (false) {
      ReactSharedInternals_default.H = previousDispatcher2;
      reenableLogs();
    }
    Error.prepareStackTrace = previousPrepareStackTrace;
  }
  const name = fn ? fn.displayName || fn.name : "";
  const syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
  if (false) {
    if (typeof fn === "function") {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }
  return syntheticFrame;
}
function describeClassComponentFrame(ctor) {
  return describeNativeComponentFrame(ctor, true);
}
function describeFunctionComponentFrame(fn) {
  return describeNativeComponentFrame(fn, false);
}

// dist/react-reconciler/src/ReactFiberComponentStack.js
function describeFiber(fiber) {
  switch (fiber.tag) {
    case HostHoistable:
    case HostSingleton:
    case HostComponent:
      return describeBuiltInComponentFrame(fiber.type);
    case LazyComponent:
      return describeBuiltInComponentFrame("Lazy");
    case SuspenseComponent:
      return describeBuiltInComponentFrame("Suspense");
    case SuspenseListComponent:
      return describeBuiltInComponentFrame("SuspenseList");
    case FunctionComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(fiber.type);
    case ForwardRef:
      return describeFunctionComponentFrame(fiber.type.render);
    case ClassComponent:
      return describeClassComponentFrame(fiber.type);
    case ActivityComponent:
      return describeBuiltInComponentFrame("Activity");
    case ViewTransitionComponent:
      if (enableViewTransition) {
        return describeBuiltInComponentFrame("ViewTransition");
      }
    // Fallthrough
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress2) {
  try {
    let info = "";
    let node = workInProgress2;
    do {
      info += describeFiber(node);
      if (false) {
        const debugInfo = node._debugInfo;
        if (debugInfo) {
          for (let i = debugInfo.length - 1; i >= 0; i--) {
            const entry = debugInfo[i];
            if (typeof entry.name === "string") {
              info += describeDebugInfoFrame(entry.name, entry.env);
            }
          }
        }
      }
      node = node.return;
    } while (node);
    return info;
  } catch (x) {
    return "\nError generating stack: " + x.message + "\n" + x.stack;
  }
}

// dist/react-reconciler/src/ReactCapturedValue.js
var CapturedStacks = /* @__PURE__ */ new WeakMap();
function createCapturedValueAtFiber(value, source) {
  if (typeof value === "object" && value !== null) {
    const existing = CapturedStacks.get(value);
    if (existing !== void 0) {
      return existing;
    }
    const captured = {
      value,
      source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, captured);
    return captured;
  } else {
    return {
      value,
      source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }
}
function createCapturedValueFromError(value, stack) {
  const captured = {
    value,
    source: null,
    stack
  };
  if (typeof stack === "string") {
    CapturedStacks.set(value, captured);
  }
  return captured;
}

// dist/react-reconciler/src/ReactFiberTreeContext.js
var forkStack = [];
var forkStackIndex = 0;
var treeForkProvider = null;
var treeForkCount = 0;
var idStack = [];
var idStackIndex = 0;
var treeContextProvider = null;
var treeContextId = 1;
var treeContextOverflow = "";
function isForkedChild(workInProgress2) {
  warnIfNotHydrating();
  return (workInProgress2.flags & Forked) !== NoFlags;
}
function getForksAtLevel(workInProgress2) {
  warnIfNotHydrating();
  return treeForkCount;
}
function getTreeId() {
  const overflow = treeContextOverflow;
  const idWithLeadingBit = treeContextId;
  const id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
  return id.toString(32) + overflow;
}
function pushTreeFork(workInProgress2, totalChildren) {
  warnIfNotHydrating();
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress2;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress2, totalChildren, index2) {
  warnIfNotHydrating();
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress2;
  const baseIdWithLeadingBit = treeContextId;
  const baseOverflow = treeContextOverflow;
  const baseLength = getBitLength(baseIdWithLeadingBit) - 1;
  const baseId = baseIdWithLeadingBit & ~(1 << baseLength);
  const slot = index2 + 1;
  const length = getBitLength(totalChildren) + baseLength;
  if (length > 30) {
    const numberOfOverflowBits = baseLength - baseLength % 5;
    const newOverflowBits = (1 << numberOfOverflowBits) - 1;
    const newOverflow = (baseId & newOverflowBits).toString(32);
    const restOfBaseId = baseId >> numberOfOverflowBits;
    const restOfBaseLength = baseLength - numberOfOverflowBits;
    const restOfLength = getBitLength(totalChildren) + restOfBaseLength;
    const restOfNewBits = slot << restOfBaseLength;
    const id = restOfNewBits | restOfBaseId;
    const overflow = newOverflow + baseOverflow;
    treeContextId = 1 << restOfLength | id;
    treeContextOverflow = overflow;
  } else {
    const newBits = slot << baseLength;
    const id = newBits | baseId;
    const overflow = baseOverflow;
    treeContextId = 1 << length | id;
    treeContextOverflow = overflow;
  }
}
function pushMaterializedTreeId(workInProgress2) {
  warnIfNotHydrating();
  const returnFiber = workInProgress2.return;
  if (returnFiber !== null) {
    const numberOfForks = 1;
    const slotIndex = 0;
    pushTreeFork(workInProgress2, numberOfForks);
    pushTreeId(workInProgress2, numberOfForks, slotIndex);
  }
}
function getBitLength(number) {
  return 32 - clz32(number);
}
function getLeadingBit(id) {
  return 1 << getBitLength(id) - 1;
}
function popTreeContext(workInProgress2) {
  while (workInProgress2 === treeForkProvider) {
    treeForkProvider = forkStack[--forkStackIndex];
    forkStack[forkStackIndex] = null;
    treeForkCount = forkStack[--forkStackIndex];
    forkStack[forkStackIndex] = null;
  }
  while (workInProgress2 === treeContextProvider) {
    treeContextProvider = idStack[--idStackIndex];
    idStack[idStackIndex] = null;
    treeContextOverflow = idStack[--idStackIndex];
    idStack[idStackIndex] = null;
    treeContextId = idStack[--idStackIndex];
    idStack[idStackIndex] = null;
  }
}
function getSuspendedTreeContext() {
  warnIfNotHydrating();
  if (treeContextProvider !== null) {
    return {
      id: treeContextId,
      overflow: treeContextOverflow
    };
  } else {
    return null;
  }
}
function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
  warnIfNotHydrating();
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextId = suspendedContext.id;
  treeContextOverflow = suspendedContext.overflow;
  treeContextProvider = workInProgress2;
}
function warnIfNotHydrating() {
  if (false) {
    if (!getIsHydrating()) {
      console.error(
        "Expected to be hydrating. This is a bug in React. Please file an issue."
      );
    }
  }
}

// dist/react-reconciler/src/ReactFiberHostContext.js
var contextStackCursor2 = createCursor(null);
var contextFiberStackCursor = createCursor(null);
var rootInstanceStackCursor = createCursor(null);
var hostTransitionProviderCursor = createCursor(null);
function requiredContext(c) {
  if (false) {
    if (c === null) {
      console.error(
        "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
      );
    }
  }
  return c;
}
function getRootHostContainer() {
  const rootInstance = requiredContext(rootInstanceStackCursor.current);
  return rootInstance;
}
function getHostTransitionProvider() {
  return hostTransitionProviderCursor.current;
}
function pushHostContainer(fiber, nextRootInstance) {
  push2(rootInstanceStackCursor, nextRootInstance, fiber);
  push2(contextFiberStackCursor, fiber, fiber);
  push2(contextStackCursor2, null, fiber);
  const nextRootContext = (void 0)(nextRootInstance);
  pop2(contextStackCursor2, fiber);
  push2(contextStackCursor2, nextRootContext, fiber);
}
function popHostContainer(fiber) {
  pop2(contextStackCursor2, fiber);
  pop2(contextFiberStackCursor, fiber);
  pop2(rootInstanceStackCursor, fiber);
}
function getHostContext() {
  const context = requiredContext(contextStackCursor2.current);
  return context;
}
function pushHostContext(fiber) {
  const stateHook = fiber.memoizedState;
  if (stateHook !== null) {
    push2(hostTransitionProviderCursor, fiber, fiber);
  }
  const context = requiredContext(contextStackCursor2.current);
  const nextContext = (void 0)(context, fiber.type);
  if (context !== nextContext) {
    push2(contextFiberStackCursor, fiber, fiber);
    push2(contextStackCursor2, nextContext, fiber);
  }
}
function popHostContext(fiber) {
  if (contextFiberStackCursor.current === fiber) {
    pop2(contextStackCursor2, fiber);
    pop2(contextFiberStackCursor, fiber);
  }
  if (hostTransitionProviderCursor.current === fiber) {
    pop2(hostTransitionProviderCursor, fiber);
    if (void 0) {
      (void 0)._currentValue = void 0;
    } else {
      (void 0)._currentValue2 = void 0;
    }
  }
}

// dist/react-reconciler/src/ReactFiberHydrationContext.js
var hydrationParentFiber = null;
var nextHydratableInstance = null;
var isHydrating = false;
var didSuspendOrErrorDEV = false;
var hydrationDiffRootDEV = null;
var hydrationErrors = null;
var rootOrSingletonContext = false;
function warnIfHydrating() {
  if (false) {
    if (isHydrating) {
      console.error(
        "We should not be hydrating here. This is a bug in React. Please file a bug."
      );
    }
  }
}
function markDidThrowWhileHydratingDEV() {
  if (false) {
    didSuspendOrErrorDEV = true;
  }
}
function enterHydrationState(fiber) {
  if (!void 0) {
    return false;
  }
  const parentInstance = fiber.stateNode.containerInfo;
  nextHydratableInstance = (void 0)(parentInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = true;
  return true;
}
function reenterHydrationStateFromDehydratedActivityInstance(fiber, activityInstance, treeContext) {
  if (!void 0) {
    return false;
  }
  nextHydratableInstance = (void 0)(activityInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = false;
  if (treeContext !== null) {
    restoreSuspendedTreeContext(fiber, treeContext);
  }
  return true;
}
function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
  if (!void 0) {
    return false;
  }
  nextHydratableInstance = (void 0)(suspenseInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  hydrationErrors = null;
  didSuspendOrErrorDEV = false;
  hydrationDiffRootDEV = null;
  rootOrSingletonContext = false;
  if (treeContext !== null) {
    restoreSuspendedTreeContext(fiber, treeContext);
  }
  return true;
}
function warnNonHydratedInstance(fiber, rejectedCandidate) {
  if (false) {
    if (didSuspendOrErrorDEV) {
      return;
    }
    const diffNode = buildHydrationDiffNode(fiber, 0);
    diffNode.serverProps = null;
    if (rejectedCandidate !== null) {
      const description = (void 0)(rejectedCandidate);
      diffNode.serverTail.push(description);
    }
  }
}
function tryHydrateInstance(fiber, nextInstance, hostContext) {
  const instance = (void 0)(
    nextInstance,
    fiber.type,
    fiber.pendingProps,
    rootOrSingletonContext
  );
  if (instance !== null) {
    fiber.stateNode = instance;
    if (false) {
      if (!didSuspendOrErrorDEV) {
        const differences = (void 0)(
          instance,
          fiber.type,
          fiber.pendingProps,
          hostContext
        );
        if (differences !== null) {
          const diffNode = buildHydrationDiffNode(fiber, 0);
          diffNode.serverProps = differences;
        }
      }
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = (void 0)(instance);
    rootOrSingletonContext = false;
    return true;
  }
  return false;
}
function tryHydrateText(fiber, nextInstance) {
  const text = fiber.pendingProps;
  const textInstance = (void 0)(
    nextInstance,
    text,
    rootOrSingletonContext
  );
  if (textInstance !== null) {
    fiber.stateNode = textInstance;
    hydrationParentFiber = fiber;
    nextHydratableInstance = null;
    return true;
  }
  return false;
}
function tryHydrateActivity(fiber, nextInstance) {
  const activityInstance = (void 0)(
    nextInstance,
    rootOrSingletonContext
  );
  if (activityInstance !== null) {
    const activityState = {
      dehydrated: activityInstance,
      treeContext: getSuspendedTreeContext(),
      retryLane: OffscreenLane,
      hydrationErrors: null
    };
    fiber.memoizedState = activityState;
    const dehydratedFragment = createFiberFromDehydratedFragment(activityInstance);
    dehydratedFragment.return = fiber;
    fiber.child = dehydratedFragment;
    hydrationParentFiber = fiber;
    nextHydratableInstance = null;
  }
  return activityInstance;
}
function tryHydrateSuspense(fiber, nextInstance) {
  const suspenseInstance = (void 0)(
    nextInstance,
    rootOrSingletonContext
  );
  if (suspenseInstance !== null) {
    const suspenseState = {
      dehydrated: suspenseInstance,
      treeContext: getSuspendedTreeContext(),
      retryLane: OffscreenLane,
      hydrationErrors: null
    };
    fiber.memoizedState = suspenseState;
    const dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
    dehydratedFragment.return = fiber;
    fiber.child = dehydratedFragment;
    hydrationParentFiber = fiber;
    nextHydratableInstance = null;
  }
  return suspenseInstance;
}
var HydrationMismatchException = new Error(
  "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
);
function throwOnHydrationMismatch(fiber, fromText = false) {
  let diff = "";
  if (false) {
    const diffRoot = hydrationDiffRootDEV;
    if (diffRoot !== null) {
      hydrationDiffRootDEV = null;
      diff = describeDiff(diffRoot);
    }
  }
  const error = new Error(
    `Hydration failed because the server rendered ${fromText ? "text" : "HTML"} didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + diff
  );
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function claimHydratableSingleton(fiber) {
  if (void 0) {
    if (!isHydrating) {
      return;
    }
    const currentRootContainer = getRootHostContainer();
    const currentHostContext = getHostContext();
    const instance = fiber.stateNode = (void 0)(
      fiber.type,
      fiber.pendingProps,
      currentRootContainer,
      currentHostContext,
      false
    );
    if (false) {
      if (!didSuspendOrErrorDEV) {
        const differences = (void 0)(
          instance,
          fiber.type,
          fiber.pendingProps,
          currentHostContext
        );
        if (differences !== null) {
          const diffNode = buildHydrationDiffNode(fiber, 0);
          diffNode.serverProps = differences;
        }
      }
    }
    hydrationParentFiber = fiber;
    rootOrSingletonContext = true;
    nextHydratableInstance = (void 0)(
      fiber.type,
      instance,
      nextHydratableInstance
    );
  }
}
function tryToClaimNextHydratableInstance(fiber) {
  if (!isHydrating) {
    return;
  }
  const currentHostContext = getHostContext();
  const shouldKeepWarning = (void 0)(
    fiber.type,
    fiber.pendingProps,
    currentHostContext
  );
  const nextInstance = nextHydratableInstance;
  if (!nextInstance || !tryHydrateInstance(fiber, nextInstance, currentHostContext)) {
    if (shouldKeepWarning) {
      warnNonHydratedInstance(fiber, nextInstance);
    }
    throwOnHydrationMismatch(fiber);
  }
}
function tryToClaimNextHydratableTextInstance(fiber) {
  if (!isHydrating) {
    return;
  }
  const text = fiber.pendingProps;
  let shouldKeepWarning = true;
  const currentHostContext = getHostContext();
  shouldKeepWarning = (void 0)(text, currentHostContext);
  const nextInstance = nextHydratableInstance;
  if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {
    if (shouldKeepWarning) {
      warnNonHydratedInstance(fiber, nextInstance);
    }
    throwOnHydrationMismatch(fiber);
  }
}
function claimNextHydratableActivityInstance(fiber) {
  const nextInstance = nextHydratableInstance;
  const activityInstance = nextInstance ? tryHydrateActivity(fiber, nextInstance) : null;
  if (activityInstance === null) {
    warnNonHydratedInstance(fiber, nextInstance);
    throw throwOnHydrationMismatch(fiber);
  }
  return activityInstance;
}
function claimNextHydratableSuspenseInstance(fiber) {
  const nextInstance = nextHydratableInstance;
  const suspenseInstance = nextInstance ? tryHydrateSuspense(fiber, nextInstance) : null;
  if (suspenseInstance === null) {
    warnNonHydratedInstance(fiber, nextInstance);
    throw throwOnHydrationMismatch(fiber);
  }
  return suspenseInstance;
}
function tryToClaimNextHydratableFormMarkerInstance(fiber) {
  if (!isHydrating) {
    return false;
  }
  if (nextHydratableInstance) {
    const markerInstance = (void 0)(
      nextHydratableInstance,
      rootOrSingletonContext
    );
    if (markerInstance) {
      nextHydratableInstance = (void 0)(markerInstance);
      return (void 0)(markerInstance);
    }
  }
  throwOnHydrationMismatch(fiber);
  return false;
}
function prepareToHydrateHostInstance(fiber, hostContext) {
  if (!void 0) {
    throw new Error(
      "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  const instance = fiber.stateNode;
  const didHydrate = (void 0)(
    instance,
    fiber.type,
    fiber.memoizedProps,
    hostContext,
    fiber
  );
  if (!didHydrate && favorSafetyOverHydrationPerf) {
    throwOnHydrationMismatch(fiber, true);
  }
}
function prepareToHydrateHostTextInstance(fiber) {
  if (!void 0) {
    throw new Error(
      "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  const textInstance = fiber.stateNode;
  const textContent = fiber.memoizedProps;
  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
  let parentProps = null;
  const returnFiber = hydrationParentFiber;
  if (returnFiber !== null) {
    switch (returnFiber.tag) {
      case HostRoot: {
        if (false) {
          if (shouldWarnIfMismatchDev) {
            const difference = (void 0)(
              textInstance,
              textContent,
              parentProps
            );
            if (difference !== null) {
              const diffNode = buildHydrationDiffNode(fiber, 0);
              diffNode.serverProps = difference;
            }
          }
        }
        break;
      }
      case HostSingleton:
      case HostComponent: {
        parentProps = returnFiber.memoizedProps;
        if (false) {
          if (shouldWarnIfMismatchDev) {
            const difference = (void 0)(
              textInstance,
              textContent,
              parentProps
            );
            if (difference !== null) {
              const diffNode = buildHydrationDiffNode(fiber, 0);
              diffNode.serverProps = difference;
            }
          }
        }
        break;
      }
    }
  }
  const didHydrate = (void 0)(
    textInstance,
    textContent,
    fiber,
    parentProps
  );
  if (!didHydrate && favorSafetyOverHydrationPerf) {
    throwOnHydrationMismatch(fiber, true);
  }
}
function prepareToHydrateHostActivityInstance(fiber) {
  if (!void 0) {
    throw new Error(
      "Expected prepareToHydrateHostActivityInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  const activityState = fiber.memoizedState;
  const activityInstance = activityState !== null ? activityState.dehydrated : null;
  if (!activityInstance) {
    throw new Error(
      "Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  (void 0)(activityInstance, fiber);
}
function prepareToHydrateHostSuspenseInstance(fiber) {
  if (!void 0) {
    throw new Error(
      "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  const suspenseState = fiber.memoizedState;
  const suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
  if (!suspenseInstance) {
    throw new Error(
      "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  (void 0)(suspenseInstance, fiber);
}
function skipPastDehydratedActivityInstance(fiber) {
  const activityState = fiber.memoizedState;
  const activityInstance = activityState !== null ? activityState.dehydrated : null;
  if (!activityInstance) {
    throw new Error(
      "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  return (void 0)(activityInstance);
}
function skipPastDehydratedSuspenseInstance(fiber) {
  if (!void 0) {
    throw new Error(
      "Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  const suspenseState = fiber.memoizedState;
  const suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
  if (!suspenseInstance) {
    throw new Error(
      "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  return (void 0)(suspenseInstance);
}
function popToNextHostParent(fiber) {
  hydrationParentFiber = fiber.return;
  while (hydrationParentFiber) {
    switch (hydrationParentFiber.tag) {
      case HostComponent:
      case ActivityComponent:
      case SuspenseComponent:
        rootOrSingletonContext = false;
        return;
      case HostSingleton:
      case HostRoot:
        rootOrSingletonContext = true;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
  }
}
function popHydrationState(fiber) {
  if (!void 0) {
    return false;
  }
  if (fiber !== hydrationParentFiber) {
    return false;
  }
  if (!isHydrating) {
    popToNextHostParent(fiber);
    isHydrating = true;
    return false;
  }
  const tag = fiber.tag;
  if (void 0) {
    if (tag !== HostRoot && tag !== HostSingleton && !(tag === HostComponent && (!(void 0)(fiber.type) || (void 0)(fiber.type, fiber.memoizedProps)))) {
      const nextInstance = nextHydratableInstance;
      if (nextInstance) {
        warnIfUnhydratedTailNodes(fiber);
        throwOnHydrationMismatch(fiber);
      }
    }
  } else {
    if (tag !== HostRoot && (tag !== HostComponent || (void 0)(fiber.type) && !(void 0)(fiber.type, fiber.memoizedProps))) {
      const nextInstance = nextHydratableInstance;
      if (nextInstance) {
        warnIfUnhydratedTailNodes(fiber);
        throwOnHydrationMismatch(fiber);
      }
    }
  }
  popToNextHostParent(fiber);
  if (tag === SuspenseComponent) {
    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
  } else if (tag === ActivityComponent) {
    nextHydratableInstance = skipPastDehydratedActivityInstance(fiber);
  } else if (void 0 && tag === HostSingleton) {
    nextHydratableInstance = (void 0)(
      fiber.type,
      nextHydratableInstance
    );
  } else {
    nextHydratableInstance = hydrationParentFiber ? (void 0)(fiber.stateNode) : null;
  }
  return true;
}
function warnIfUnhydratedTailNodes(fiber) {
  if (false) {
    let nextInstance = nextHydratableInstance;
    while (nextInstance) {
      const diffNode = buildHydrationDiffNode(fiber, 0);
      const description = (void 0)(nextInstance);
      diffNode.serverTail.push(description);
      if (description.type === "Suspense") {
        const suspenseInstance = nextInstance;
        nextInstance = (void 0)(suspenseInstance);
      } else {
        nextInstance = (void 0)(nextInstance);
      }
    }
  }
}
function resetHydrationState() {
  if (!void 0) {
    return;
  }
  hydrationParentFiber = null;
  nextHydratableInstance = null;
  isHydrating = false;
  didSuspendOrErrorDEV = false;
}
function upgradeHydrationErrorsToRecoverable() {
  const queuedErrors = hydrationErrors;
  if (queuedErrors !== null) {
    queueRecoverableErrors(queuedErrors);
    hydrationErrors = null;
  }
  return queuedErrors;
}
function getIsHydrating() {
  return isHydrating;
}
function queueHydrationError(error) {
  if (hydrationErrors === null) {
    hydrationErrors = [error];
  } else {
    hydrationErrors.push(error);
  }
}
function emitPendingHydrationWarnings() {
  if (false) {
    const diffRoot = hydrationDiffRootDEV;
    if (diffRoot !== null) {
      hydrationDiffRootDEV = null;
      const diff = describeDiff(diffRoot);
      let diffOwner = diffRoot;
      while (diffOwner.children.length > 0) {
        diffOwner = diffOwner.children[0];
      }
      runWithFiberInDEV(diffOwner.fiber, () => {
        console.error(
          "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
          "https://react.dev/link/hydration-mismatch",
          diff
        );
      });
    }
  }
}

// dist/react-reconciler/src/ReactTypeOfMode.js
var NoMode = (
  /*                         */
  0
);
var ConcurrentMode = (
  /*                 */
  1
);
var ProfileMode = (
  /*                    */
  2
);
var StrictLegacyMode = (
  /*               */
  8
);
var StrictEffectsMode = (
  /*              */
  16
);
var NoStrictPassiveEffectsMode = (
  /*     */
  64
);
var SuspenseyImagesMode = (
  /*            */
  32
);

// dist/react-reconciler/src/ReactFiberNewContext.js
var valueCursor = createCursor(null);
if (false) {
  rendererCursorDEV = createCursor(null);
}
if (false) {
  renderer2CursorDEV = createCursor(null);
}
if (false) {
  rendererSigil = {};
}
var currentlyRenderingFiber = null;
var lastContextDependency = null;
function resetContextDependencies() {
  currentlyRenderingFiber = null;
  lastContextDependency = null;
  if (false) {
    isDisallowedContextReadInDEV = false;
  }
}
function pushProvider(providerFiber, context, nextValue) {
  if (void 0) {
    push2(valueCursor, context._currentValue, providerFiber);
    context._currentValue = nextValue;
    if (false) {
      push2(rendererCursorDEV, context._currentRenderer, providerFiber);
      if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
        console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        );
      }
      context._currentRenderer = rendererSigil;
    }
  } else {
    push2(valueCursor, context._currentValue2, providerFiber);
    context._currentValue2 = nextValue;
    if (false) {
      push2(renderer2CursorDEV, context._currentRenderer2, providerFiber);
      if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
        console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        );
      }
      context._currentRenderer2 = rendererSigil;
    }
  }
}
function popProvider(context, providerFiber) {
  const currentValue = valueCursor.current;
  if (void 0) {
    context._currentValue = currentValue;
    if (false) {
      const currentRenderer = rendererCursorDEV.current;
      pop2(rendererCursorDEV, providerFiber);
      context._currentRenderer = currentRenderer;
    }
  } else {
    context._currentValue2 = currentValue;
    if (false) {
      const currentRenderer2 = renderer2CursorDEV.current;
      pop2(renderer2CursorDEV, providerFiber);
      context._currentRenderer2 = currentRenderer2;
    }
  }
  pop2(valueCursor, providerFiber);
}
function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
  let node = parent;
  while (node !== null) {
    const alternate = node.alternate;
    if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
      node.childLanes = mergeLanes(node.childLanes, renderLanes2);
      if (alternate !== null) {
        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
      }
    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
    } else {
    }
    if (node === propagationRoot) {
      break;
    }
    node = node.return;
  }
  if (false) {
    if (node !== propagationRoot) {
      console.error(
        "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
      );
    }
  }
}
function propagateContextChange(workInProgress2, context, renderLanes2) {
  const forcePropagateEntireTree = true;
  propagateContextChanges(
    workInProgress2,
    [context],
    renderLanes2,
    forcePropagateEntireTree
  );
}
function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
  let fiber = workInProgress2.child;
  if (fiber !== null) {
    fiber.return = workInProgress2;
  }
  while (fiber !== null) {
    let nextFiber;
    const list = fiber.dependencies;
    if (list !== null) {
      nextFiber = fiber.child;
      let dep = list.firstContext;
      findChangedDep: while (dep !== null) {
        const dependency = dep;
        const consumer = fiber;
        findContext: for (let i = 0; i < contexts.length; i++) {
          const context = contexts[i];
          if (dependency.context === context) {
            consumer.lanes = mergeLanes(consumer.lanes, renderLanes2);
            const alternate = consumer.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(
              consumer.return,
              renderLanes2,
              workInProgress2
            );
            if (!forcePropagateEntireTree) {
              nextFiber = null;
            }
            break findChangedDep;
          }
        }
        dep = dependency.next;
      }
    } else if (fiber.tag === DehydratedFragment) {
      const parentSuspense = fiber.return;
      if (parentSuspense === null) {
        throw new Error(
          "We just came from a parent so we must have had a parent. This is a bug in React."
        );
      }
      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
      const alternate = parentSuspense.alternate;
      if (alternate !== null) {
        alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
      }
      scheduleContextWorkOnParentPath(
        parentSuspense,
        renderLanes2,
        workInProgress2
      );
      nextFiber = null;
    } else {
      nextFiber = fiber.child;
    }
    if (nextFiber !== null) {
      nextFiber.return = fiber;
    } else {
      nextFiber = fiber;
      while (nextFiber !== null) {
        if (nextFiber === workInProgress2) {
          nextFiber = null;
          break;
        }
        const sibling = nextFiber.sibling;
        if (sibling !== null) {
          sibling.return = nextFiber.return;
          nextFiber = sibling;
          break;
        }
        nextFiber = nextFiber.return;
      }
    }
    fiber = nextFiber;
  }
}
function lazilyPropagateParentContextChanges(current2, workInProgress2, renderLanes2) {
  const forcePropagateEntireTree = false;
  propagateParentContextChanges(
    current2,
    workInProgress2,
    renderLanes2,
    forcePropagateEntireTree
  );
}
function propagateParentContextChangesToDeferredTree(current2, workInProgress2, renderLanes2) {
  const forcePropagateEntireTree = true;
  propagateParentContextChanges(
    current2,
    workInProgress2,
    renderLanes2,
    forcePropagateEntireTree
  );
}
function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
  let contexts = null;
  let parent = workInProgress2;
  let isInsidePropagationBailout = false;
  while (parent !== null) {
    if (!isInsidePropagationBailout) {
      if ((parent.flags & NeedsPropagation) !== NoFlags) {
        isInsidePropagationBailout = true;
      } else if ((parent.flags & DidPropagateContext) !== NoFlags) {
        break;
      }
    }
    if (parent.tag === ContextProvider) {
      const currentParent = parent.alternate;
      if (currentParent === null) {
        throw new Error("Should have a current fiber. This is a bug in React.");
      }
      const oldProps = currentParent.memoizedProps;
      if (oldProps !== null) {
        let context;
        if (enableRenderableContext) {
          context = parent.type;
        } else {
          context = parent.type._context;
        }
        const newProps = parent.pendingProps;
        const newValue = newProps.value;
        const oldValue = oldProps.value;
        if (!objectIs_default(newValue, oldValue)) {
          if (contexts !== null) {
            contexts.push(context);
          } else {
            contexts = [context];
          }
        }
      }
    } else if (parent === getHostTransitionProvider()) {
      const currentParent = parent.alternate;
      if (currentParent === null) {
        throw new Error("Should have a current fiber. This is a bug in React.");
      }
      const oldStateHook = currentParent.memoizedState;
      const oldState = oldStateHook.memoizedState;
      const newStateHook = parent.memoizedState;
      const newState = newStateHook.memoizedState;
      if (oldState !== newState) {
        if (contexts !== null) {
          contexts.push(void 0);
        } else {
          contexts = [void 0];
        }
      }
    }
    parent = parent.return;
  }
  if (contexts !== null) {
    propagateContextChanges(
      workInProgress2,
      contexts,
      renderLanes2,
      forcePropagateEntireTree
    );
  }
  workInProgress2.flags |= DidPropagateContext;
}
function checkIfContextChanged(currentDependencies) {
  let dependency = currentDependencies.firstContext;
  while (dependency !== null) {
    const context = dependency.context;
    const newValue = void 0 ? context._currentValue : context._currentValue2;
    const oldValue = dependency.memoizedValue;
    if (!objectIs_default(newValue, oldValue)) {
      return true;
    }
    dependency = dependency.next;
  }
  return false;
}
function prepareToReadContext(workInProgress2, renderLanes2) {
  currentlyRenderingFiber = workInProgress2;
  lastContextDependency = null;
  const dependencies = workInProgress2.dependencies;
  if (dependencies !== null) {
    dependencies.firstContext = null;
  }
}
function readContext(context) {
  if (false) {
    if (isDisallowedContextReadInDEV) {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
  }
  return readContextForConsumer(currentlyRenderingFiber, context);
}
function readContextDuringReconciliation(consumer, context, renderLanes2) {
  if (currentlyRenderingFiber === null) {
    prepareToReadContext(consumer, renderLanes2);
  }
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  const value = void 0 ? context._currentValue : context._currentValue2;
  const contextItem = {
    context,
    memoizedValue: value,
    next: null
  };
  if (lastContextDependency === null) {
    if (consumer === null) {
      throw new Error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    lastContextDependency = contextItem;
    consumer.dependencies = false ? {
      lanes: NoLanes,
      firstContext: contextItem,
      _debugThenableState: null
    } : {
      lanes: NoLanes,
      firstContext: contextItem
    };
    consumer.flags |= NeedsPropagation;
  } else {
    lastContextDependency = lastContextDependency.next = contextItem;
  }
  return value;
}

// dist/react-reconciler/src/ReactFiberCacheComponent.js
var AbortControllerLocal = typeof AbortController !== "undefined" ? AbortController : (
  // $FlowFixMe[missing-this-annot]
  // $FlowFixMe[prop-missing]
  function AbortControllerShim() {
    const listeners = [];
    const signal = this.signal = {
      aborted: false,
      addEventListener: (type, listener) => {
        listeners.push(listener);
      }
    };
    this.abort = () => {
      signal.aborted = true;
      listeners.forEach((listener) => listener());
    };
  }
);
var {
  unstable_scheduleCallback: scheduleCallback2,
  unstable_NormalPriority: NormalPriority3
} = scheduler_exports;
var CacheContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  // We don't use Consumer/Provider for Cache components. So we'll cheat.
  Consumer: null,
  Provider: null,
  // We'll initialize these at the root.
  _currentValue: null,
  _currentValue2: null,
  _threadCount: 0
};
if (false) {
  CacheContext._currentRenderer = null;
  CacheContext._currentRenderer2 = null;
}
function createCache() {
  return {
    controller: new AbortControllerLocal(),
    data: /* @__PURE__ */ new Map(),
    refCount: 0
  };
}
function retainCache(cache3) {
  if (false) {
    if (cache3.controller.signal.aborted) {
      console.warn(
        "A cache instance was retained after it was already freed. This likely indicates a bug in React."
      );
    }
  }
  cache3.refCount++;
}
function releaseCache(cache3) {
  cache3.refCount--;
  if (false) {
    if (cache3.refCount < 0) {
      console.warn(
        "A cache instance was released after it was already freed. This likely indicates a bug in React."
      );
    }
  }
  if (cache3.refCount === 0) {
    scheduleCallback2(NormalPriority3, () => {
      cache3.controller.abort();
    });
  }
}
function pushCacheProvider(workInProgress2, cache3) {
  pushProvider(workInProgress2, CacheContext, cache3);
}
function popCacheProvider(workInProgress2, cache3) {
  popProvider(CacheContext, workInProgress2);
}

// dist/react-reconciler/src/ReactFiberTransitionTypes.js
function queueTransitionTypes(root2, transitionTypes) {
  if (enableViewTransition) {
    if (includesTransitionLane(root2.pendingLanes)) {
      let queued = root2.transitionTypes;
      if (queued === null) {
        queued = root2.transitionTypes = [];
      }
      for (let i = 0; i < transitionTypes.length; i++) {
        const transitionType = transitionTypes[i];
        if (queued.indexOf(transitionType) === -1) {
          queued.push(transitionType);
        }
      }
    }
  }
}
var entangledTransitionTypes = null;
function entangleAsyncTransitionTypes(transitionTypes) {
  if (enableViewTransition) {
    let queued = entangledTransitionTypes;
    if (queued === null) {
      queued = entangledTransitionTypes = [];
    }
    for (let i = 0; i < transitionTypes.length; i++) {
      const transitionType = transitionTypes[i];
      if (queued.indexOf(transitionType) === -1) {
        queued.push(transitionType);
      }
    }
  }
}
function clearEntangledAsyncTransitionTypes() {
  entangledTransitionTypes = null;
}
function claimQueuedTransitionTypes(root2) {
  const claimed = root2.transitionTypes;
  root2.transitionTypes = null;
  return claimed;
}

// dist/react-reconciler/src/ReactProfilerTimer.js
var { unstable_now: now2 } = scheduler_exports;
var createTask2 = (
  // eslint-disable-next-line react-internal/no-production-logging
  false ? (
    // eslint-disable-next-line react-internal/no-production-logging
    console.createTask
  ) : (name) => null
);
var renderStartTime = -0;
var commitStartTime = -0;
var commitEndTime = -0;
var commitErrors = null;
var profilerStartTime = -1.1;
var profilerEffectDuration = -0;
var componentEffectDuration = -0;
var componentEffectStartTime = -1.1;
var componentEffectEndTime = -1.1;
var componentEffectErrors = null;
var blockingClampTime = -0;
var blockingUpdateTime = -1.1;
var blockingUpdateTask = null;
var blockingEventTime = -1.1;
var blockingEventType = null;
var blockingEventIsRepeat = false;
var blockingSpawnedUpdate = false;
var blockingSuspendedTime = -1.1;
var transitionClampTime = -0;
var transitionStartTime = -1.1;
var transitionUpdateTime = -1.1;
var transitionUpdateTask = null;
var transitionEventTime = -1.1;
var transitionEventType = null;
var transitionEventIsRepeat = false;
var transitionSuspendedTime = -1.1;
var yieldReason = 0;
var yieldStartTime = -1.1;
function startYieldTimer(reason) {
  if (!enableProfilerTimer || !enableComponentPerformanceTrack) {
    return;
  }
  yieldStartTime = now2();
  yieldReason = reason;
}
function startUpdateTimerByLane(lane, method) {
  if (!enableProfilerTimer || !enableComponentPerformanceTrack) {
    return;
  }
  if (isSyncLane(lane) || isBlockingLane(lane)) {
    if (blockingUpdateTime < 0) {
      blockingUpdateTime = now2();
      blockingUpdateTask = createTask2(method);
      if (isAlreadyRendering()) {
        blockingSpawnedUpdate = true;
      }
      const newEventTime = (void 0)();
      const newEventType = (void 0)();
      if (newEventTime !== blockingEventTime || newEventType !== blockingEventType) {
        blockingEventIsRepeat = false;
      } else if (newEventType !== null) {
        blockingSpawnedUpdate = true;
      }
      blockingEventTime = newEventTime;
      blockingEventType = newEventType;
    }
  } else if (isTransitionLane(lane)) {
    if (transitionUpdateTime < 0) {
      transitionUpdateTime = now2();
      transitionUpdateTask = createTask2(method);
      if (transitionStartTime < 0) {
        const newEventTime = (void 0)();
        const newEventType = (void 0)();
        if (newEventTime !== transitionEventTime || newEventType !== transitionEventType) {
          transitionEventIsRepeat = false;
        }
        transitionEventTime = newEventTime;
        transitionEventType = newEventType;
      }
    }
  }
}
function startPingTimerByLanes(lanes) {
  if (!enableProfilerTimer || !enableComponentPerformanceTrack) {
    return;
  }
  if (includesSyncLane(lanes) || includesBlockingLane(lanes)) {
    if (blockingUpdateTime < 0) {
      blockingClampTime = blockingUpdateTime = now2();
    }
  } else if (includesTransitionLane(lanes)) {
    if (transitionUpdateTime < 0) {
      transitionClampTime = transitionUpdateTime = now2();
    }
  }
}
function trackSuspendedTime(lanes, renderEndTime) {
  if (!enableProfilerTimer || !enableComponentPerformanceTrack) {
    return;
  }
  if (includesSyncLane(lanes) || includesBlockingLane(lanes)) {
    blockingSuspendedTime = renderEndTime;
  } else if (includesTransitionLane(lanes)) {
    transitionSuspendedTime = renderEndTime;
  }
}
function clearBlockingTimers() {
  blockingUpdateTime = -1.1;
  blockingUpdateTask = null;
  blockingSuspendedTime = -1.1;
  blockingEventIsRepeat = true;
  blockingSpawnedUpdate = false;
}
function startAsyncTransitionTimer() {
  if (!enableProfilerTimer || !enableComponentPerformanceTrack) {
    return;
  }
  if (transitionStartTime < 0 && transitionUpdateTime < 0) {
    transitionStartTime = now2();
    const newEventTime = (void 0)();
    const newEventType = (void 0)();
    if (newEventTime !== transitionEventTime || newEventType !== transitionEventType) {
      transitionEventIsRepeat = false;
    }
    transitionEventTime = newEventTime;
    transitionEventType = newEventType;
  }
}
function hasScheduledTransitionWork() {
  return transitionUpdateTime > -1;
}
function clearAsyncTransitionTimer() {
  transitionStartTime = -1.1;
}
function clearTransitionTimers() {
  transitionStartTime = -1.1;
  transitionUpdateTime = -1.1;
  transitionUpdateTask = null;
  transitionSuspendedTime = -1.1;
  transitionEventIsRepeat = true;
}
function clampBlockingTimers(finalTime) {
  if (!enableProfilerTimer || !enableComponentPerformanceTrack) {
    return;
  }
  blockingClampTime = finalTime;
}
function clampTransitionTimers(finalTime) {
  if (!enableProfilerTimer || !enableComponentPerformanceTrack) {
    return;
  }
  transitionClampTime = finalTime;
}
function pushNestedEffectDurations() {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return 0;
  }
  const prevEffectDuration = profilerEffectDuration;
  profilerEffectDuration = 0;
  return prevEffectDuration;
}
function popNestedEffectDurations(prevEffectDuration) {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return 0;
  }
  const elapsedTime = profilerEffectDuration;
  profilerEffectDuration = prevEffectDuration;
  return elapsedTime;
}
function bubbleNestedEffectDurations(prevEffectDuration) {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return 0;
  }
  const elapsedTime = profilerEffectDuration;
  profilerEffectDuration += prevEffectDuration;
  return elapsedTime;
}
function resetComponentEffectTimers() {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return;
  }
  componentEffectStartTime = -1.1;
  componentEffectEndTime = -1.1;
}
function pushComponentEffectStart() {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return 0;
  }
  const prevEffectStart = componentEffectStartTime;
  componentEffectStartTime = -1.1;
  return prevEffectStart;
}
function popComponentEffectStart(prevEffectStart) {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return;
  }
  if (prevEffectStart >= 0) {
    componentEffectStartTime = prevEffectStart;
  }
}
function pushComponentEffectDuration() {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return 0;
  }
  const prevEffectDuration = componentEffectDuration;
  componentEffectDuration = -0;
  return prevEffectDuration;
}
function popComponentEffectDuration(prevEffectDuration) {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return;
  }
  if (prevEffectDuration >= 0) {
    componentEffectDuration = prevEffectDuration;
  }
}
function pushComponentEffectErrors() {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return null;
  }
  const prevErrors = componentEffectErrors;
  componentEffectErrors = null;
  return prevErrors;
}
function popComponentEffectErrors(prevErrors) {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return;
  }
  componentEffectErrors = prevErrors;
}
var currentUpdateIsNested = false;
var nestedUpdateScheduled = false;
function isCurrentUpdateNested() {
  return currentUpdateIsNested;
}
function markNestedUpdateScheduled() {
  if (enableProfilerNestedUpdatePhase) {
    nestedUpdateScheduled = true;
  }
}
function resetNestedUpdateFlag() {
  if (enableProfilerNestedUpdatePhase) {
    currentUpdateIsNested = false;
    nestedUpdateScheduled = false;
  }
}
function syncNestedUpdateFlag() {
  if (enableProfilerNestedUpdatePhase) {
    currentUpdateIsNested = nestedUpdateScheduled;
    nestedUpdateScheduled = false;
  }
}
function recordRenderTime() {
  if (!enableProfilerTimer || !enableComponentPerformanceTrack) {
    return;
  }
  renderStartTime = now2();
}
function recordCommitTime() {
  if (!enableProfilerTimer) {
    return;
  }
  commitStartTime = now2();
}
function recordCommitEndTime() {
  if (!enableProfilerTimer) {
    return;
  }
  commitEndTime = now2();
}
function startProfilerTimer(fiber) {
  if (!enableProfilerTimer) {
    return;
  }
  profilerStartTime = now2();
  if (fiber.actualStartTime < 0) {
    fiber.actualStartTime = profilerStartTime;
  }
}
function stopProfilerTimerIfRunning(fiber) {
  if (!enableProfilerTimer) {
    return;
  }
  profilerStartTime = -1;
}
function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
  if (!enableProfilerTimer) {
    return;
  }
  if (profilerStartTime >= 0) {
    const elapsedTime = now2() - profilerStartTime;
    fiber.actualDuration += elapsedTime;
    fiber.selfBaseDuration = elapsedTime;
    profilerStartTime = -1;
  }
}
function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
  if (!enableProfilerTimer) {
    return;
  }
  if (profilerStartTime >= 0) {
    const elapsedTime = now2() - profilerStartTime;
    fiber.actualDuration += elapsedTime;
    profilerStartTime = -1;
  }
}
function recordEffectDuration(fiber) {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return;
  }
  if (profilerStartTime >= 0) {
    const endTime = now2();
    const elapsedTime = endTime - profilerStartTime;
    profilerStartTime = -1;
    profilerEffectDuration += elapsedTime;
    componentEffectDuration += elapsedTime;
    componentEffectEndTime = endTime;
  }
}
function recordEffectError(errorInfo) {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return;
  }
  if (componentEffectErrors === null) {
    componentEffectErrors = [];
  }
  componentEffectErrors.push(errorInfo);
  if (commitErrors === null) {
    commitErrors = [];
  }
  commitErrors.push(errorInfo);
}
function resetCommitErrors() {
  commitErrors = null;
}
function startEffectTimer() {
  if (!enableProfilerTimer || !enableProfilerCommitHooks) {
    return;
  }
  profilerStartTime = now2();
  if (componentEffectStartTime < 0) {
    componentEffectStartTime = profilerStartTime;
  }
}
function transferActualDuration(fiber) {
  let child = fiber.child;
  while (child) {
    fiber.actualDuration += child.actualDuration;
    child = child.sibling;
  }
}

// dist/react-reconciler/src/ReactFiberRootScheduler.js
var firstScheduledRoot = null;
var lastScheduledRoot = null;
var didScheduleMicrotask = false;
var mightHavePendingSyncWork = false;
var isFlushingWork = false;
var currentEventTransitionLane = NoLane;
function ensureRootIsScheduled(root2) {
  if (root2 === lastScheduledRoot || root2.next !== null) {
  } else {
    if (lastScheduledRoot === null) {
      firstScheduledRoot = lastScheduledRoot = root2;
    } else {
      lastScheduledRoot.next = root2;
      lastScheduledRoot = root2;
    }
  }
  mightHavePendingSyncWork = true;
  ensureScheduleIsScheduled();
  if (false) {
    ReactSharedInternals_default.didScheduleLegacyUpdate = true;
  }
}
function ensureScheduleIsScheduled() {
  if (false) {
    if (!didScheduleMicrotask_act) {
      didScheduleMicrotask_act = true;
      scheduleImmediateRootScheduleTask();
    }
  } else {
    if (!didScheduleMicrotask) {
      didScheduleMicrotask = true;
      scheduleImmediateRootScheduleTask();
    }
  }
}
function flushSyncWorkOnAllRoots() {
  flushSyncWorkAcrossRoots_impl(NoLanes, false);
}
function flushSyncWorkOnLegacyRootsOnly() {
  if (!disableLegacyMode) {
    flushSyncWorkAcrossRoots_impl(NoLanes, true);
  }
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (isFlushingWork) {
    return;
  }
  if (!mightHavePendingSyncWork) {
    return;
  }
  let didPerformSomeWork;
  isFlushingWork = true;
  do {
    didPerformSomeWork = false;
    let root2 = firstScheduledRoot;
    while (root2 !== null) {
      if (onlyLegacy && (disableLegacyMode || root2.tag !== LegacyRoot)) {
      } else {
        if (syncTransitionLanes !== NoLanes) {
          const nextLanes = getNextLanesToFlushSync(root2, syncTransitionLanes);
          if (nextLanes !== NoLanes) {
            didPerformSomeWork = true;
            performSyncWorkOnRoot(root2, nextLanes);
          }
        } else {
          const workInProgressRoot2 = getWorkInProgressRoot();
          const workInProgressRootRenderLanes2 = getWorkInProgressRootRenderLanes();
          const rootHasPendingCommit = root2.cancelPendingCommit !== null || root2.timeoutHandle !== void 0;
          const nextLanes = getNextLanes(
            root2,
            root2 === workInProgressRoot2 ? workInProgressRootRenderLanes2 : NoLanes,
            rootHasPendingCommit
          );
          if ((includesSyncLane(nextLanes) || enableGestureTransition && isGestureRender(nextLanes)) && !checkIfRootIsPrerendering(root2, nextLanes)) {
            didPerformSomeWork = true;
            performSyncWorkOnRoot(root2, nextLanes);
          }
        }
      }
      root2 = root2.next;
    }
  } while (didPerformSomeWork);
  isFlushingWork = false;
}
function processRootScheduleInImmediateTask() {
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    (void 0)();
  }
  processRootScheduleInMicrotask();
}
function processRootScheduleInMicrotask() {
  didScheduleMicrotask = false;
  if (false) {
    didScheduleMicrotask_act = false;
  }
  mightHavePendingSyncWork = false;
  let syncTransitionLanes = NoLanes;
  if (currentEventTransitionLane !== NoLane) {
    if ((void 0)()) {
      syncTransitionLanes = currentEventTransitionLane;
    } else if (enableDefaultTransitionIndicator) {
      syncTransitionLanes = DefaultLane;
    }
  }
  const currentTime = now();
  let prev = null;
  let root2 = firstScheduledRoot;
  while (root2 !== null) {
    const next = root2.next;
    const nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
    if (nextLanes === NoLane) {
      root2.next = null;
      if (prev === null) {
        firstScheduledRoot = next;
      } else {
        prev.next = next;
      }
      if (next === null) {
        lastScheduledRoot = prev;
      }
    } else {
      prev = root2;
      if (
        // Skip the optimization if syncTransitionLanes is set
        syncTransitionLanes !== NoLanes || // Common case: we're not treating any extra lanes as synchronous, so we
        // can just check if the next lanes are sync.
        includesSyncLane(nextLanes) || enableGestureTransition && isGestureRender(nextLanes)
      ) {
        mightHavePendingSyncWork = true;
      }
    }
    root2 = next;
  }
  if (!hasPendingCommitEffects()) {
    flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
  }
  if (currentEventTransitionLane !== NoLane) {
    currentEventTransitionLane = NoLane;
    startDefaultTransitionIndicatorIfNeeded();
  }
}
function startDefaultTransitionIndicatorIfNeeded() {
  if (!enableDefaultTransitionIndicator) {
    return;
  }
  startIsomorphicDefaultIndicatorIfNeeded();
  let root2 = firstScheduledRoot;
  while (root2 !== null) {
    if (root2.indicatorLanes !== NoLanes && root2.pendingIndicator === null) {
      if (hasOngoingIsomorphicIndicator()) {
        root2.pendingIndicator = retainIsomorphicIndicator();
      } else {
        try {
          const onDefaultTransitionIndicator = root2.onDefaultTransitionIndicator;
          root2.pendingIndicator = onDefaultTransitionIndicator() || noop;
        } catch (x) {
          root2.pendingIndicator = noop;
          reportGlobalError_default(x);
        }
      }
    }
    root2 = root2.next;
  }
}
function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
  markStarvedLanesAsExpired(root2, currentTime);
  const rootWithPendingPassiveEffects = getRootWithPendingPassiveEffects();
  const pendingPassiveEffectsLanes = getPendingPassiveEffectsLanes();
  const workInProgressRoot2 = getWorkInProgressRoot();
  const workInProgressRootRenderLanes2 = getWorkInProgressRootRenderLanes();
  const rootHasPendingCommit = root2.cancelPendingCommit !== null || root2.timeoutHandle !== void 0;
  const nextLanes = enableYieldingBeforePassive && root2 === rootWithPendingPassiveEffects ? (
    // This will schedule the callback at the priority of the lane but we used to
    // always schedule it at NormalPriority. Discrete will flush it sync anyway.
    // So the only difference is Idle and it doesn't seem necessarily right for that
    // to get upgraded beyond something important just because we're past commit.
    pendingPassiveEffectsLanes
  ) : getNextLanes(
    root2,
    root2 === workInProgressRoot2 ? workInProgressRootRenderLanes2 : NoLanes,
    rootHasPendingCommit
  );
  const existingCallbackNode = root2.callbackNode;
  if (
    // Check if there's nothing to work on
    nextLanes === NoLanes || // If this root is currently suspended and waiting for data to resolve, don't
    // schedule a task to render it. We'll either wait for a ping, or wait to
    // receive an update.
    //
    // Suspended render phase
    root2 === workInProgressRoot2 && isWorkLoopSuspendedOnData() || // Suspended commit phase
    root2.cancelPendingCommit !== null
  ) {
    if (existingCallbackNode !== null) {
      cancelCallback2(existingCallbackNode);
    }
    root2.callbackNode = null;
    root2.callbackPriority = NoLane;
    return NoLane;
  }
  if (includesSyncLane(nextLanes) && // If we're prerendering, then we should use the concurrent work loop
  // even if the lanes are synchronous, so that prerendering never blocks
  // the main thread.
  !checkIfRootIsPrerendering(root2, nextLanes)) {
    if (existingCallbackNode !== null) {
      cancelCallback2(existingCallbackNode);
    }
    root2.callbackPriority = SyncLane;
    root2.callbackNode = null;
    return SyncLane;
  } else {
    const existingCallbackPriority = root2.callbackPriority;
    const newCallbackPriority = getHighestPriorityLane(nextLanes);
    if (newCallbackPriority === existingCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
    // Scheduler task, rather than an `act` task, cancel it and re-schedule
    // on the `act` queue.
    true) {
      return newCallbackPriority;
    } else {
      cancelCallback2(existingCallbackNode);
    }
    let schedulerPriorityLevel;
    switch (lanesToEventPriority(nextLanes)) {
      // Scheduler does have an "ImmediatePriority", but now that we use
      // microtasks for sync work we no longer use that. Any sync work that
      // reaches this path is meant to be time sliced.
      case DiscreteEventPriority:
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingPriority2;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalPriority2;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdlePriority2;
        break;
      default:
        schedulerPriorityLevel = NormalPriority2;
        break;
    }
    const newCallbackNode = scheduleCallback3(
      schedulerPriorityLevel,
      performWorkOnRootViaSchedulerTask.bind(null, root2)
    );
    root2.callbackPriority = newCallbackPriority;
    root2.callbackNode = newCallbackNode;
    return newCallbackPriority;
  }
}
function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {
    resetNestedUpdateFlag();
  }
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    (void 0)();
  }
  if (hasPendingCommitEffects()) {
    root2.callbackNode = null;
    root2.callbackPriority = NoLane;
    return null;
  }
  const originalCallbackNode = root2.callbackNode;
  const didFlushPassiveEffects = flushPendingEffects(true);
  if (didFlushPassiveEffects) {
    if (root2.callbackNode !== originalCallbackNode) {
      return null;
    } else {
    }
  }
  const workInProgressRoot2 = getWorkInProgressRoot();
  const workInProgressRootRenderLanes2 = getWorkInProgressRootRenderLanes();
  const rootHasPendingCommit = root2.cancelPendingCommit !== null || root2.timeoutHandle !== void 0;
  const lanes = getNextLanes(
    root2,
    root2 === workInProgressRoot2 ? workInProgressRootRenderLanes2 : NoLanes,
    rootHasPendingCommit
  );
  if (lanes === NoLanes) {
    return null;
  }
  const forceSync = !disableSchedulerTimeoutInWorkLoop && didTimeout;
  performWorkOnRoot(root2, lanes, forceSync);
  scheduleTaskForRootDuringMicrotask(root2, now());
  if (root2.callbackNode != null && root2.callbackNode === originalCallbackNode) {
    return performWorkOnRootViaSchedulerTask.bind(null, root2);
  }
  return null;
}
function performSyncWorkOnRoot(root2, lanes) {
  const didFlushPassiveEffects = flushPendingEffects();
  if (didFlushPassiveEffects) {
    return null;
  }
  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {
    syncNestedUpdateFlag();
  }
  const forceSync = true;
  performWorkOnRoot(root2, lanes, forceSync);
}
function scheduleCallback3(priorityLevel, callback) {
  if (false) {
    ReactSharedInternals_default.actQueue.push(callback);
    return fakeActCallbackNode;
  } else {
    return scheduleCallback(priorityLevel, callback);
  }
}
function cancelCallback2(callbackNode) {
  if (false) {
  } else if (callbackNode !== null) {
    cancelCallback(callbackNode);
  }
}
function scheduleImmediateRootScheduleTask() {
  if (false) {
    ReactSharedInternals_default.actQueue.push(() => {
      processRootScheduleInMicrotask();
      return null;
    });
  }
  if (void 0) {
    (void 0)(() => {
      const executionContext2 = getExecutionContext();
      if ((executionContext2 & (RenderContext | CommitContext)) !== NoContext) {
        scheduleCallback(
          ImmediatePriority2,
          processRootScheduleInImmediateTask
        );
        return;
      }
      processRootScheduleInMicrotask();
    });
  } else {
    scheduleCallback(
      ImmediatePriority2,
      processRootScheduleInImmediateTask
    );
  }
}
function requestTransitionLane(transition) {
  if (currentEventTransitionLane === NoLane) {
    const actionScopeLane = peekEntangledActionLane();
    currentEventTransitionLane = actionScopeLane !== NoLane ? (
      // We're inside an async action scope. Reuse the same lane.
      actionScopeLane
    ) : (
      // We may or may not be inside an async action scope. If we are, this
      // is the first update in that scope. Either way, we need to get a
      // fresh transition lane.
      claimNextTransitionLane()
    );
  }
  return currentEventTransitionLane;
}
function didCurrentEventScheduleTransition() {
  return currentEventTransitionLane !== NoLane;
}
function markIndicatorHandled(root2) {
  if (enableDefaultTransitionIndicator) {
    root2.indicatorLanes &= ~currentEventTransitionLane;
    markIsomorphicIndicatorHandled();
  }
}

// dist/react-reconciler/src/ReactFiberAsyncAction.js
var currentEntangledListeners = null;
var currentEntangledPendingCount = 0;
var currentEntangledLane = NoLane;
var currentEntangledActionThenable = null;
var isomorphicDefaultTransitionIndicator = void 0;
var pendingIsomorphicIndicator = null;
var pendingEntangledRoots = 0;
var needsIsomorphicIndicator = false;
function entangleAsyncAction(transition, thenable) {
  if (currentEntangledListeners === null) {
    const entangledListeners = currentEntangledListeners = [];
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane(transition);
    const entangledThenable = {
      status: "pending",
      value: void 0,
      then(resolve) {
        entangledListeners.push(resolve);
      }
    };
    currentEntangledActionThenable = entangledThenable;
    if (enableDefaultTransitionIndicator) {
      needsIsomorphicIndicator = true;
      ensureScheduleIsScheduled();
    }
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (--currentEntangledPendingCount === 0) {
    if (enableProfilerTimer && enableComponentPerformanceTrack) {
      if (!hasScheduledTransitionWork()) {
        clearAsyncTransitionTimer();
      }
    }
    clearEntangledAsyncTransitionTypes();
    if (pendingEntangledRoots === 0) {
      stopIsomorphicDefaultIndicator();
    }
    if (currentEntangledListeners !== null) {
      if (currentEntangledActionThenable !== null) {
        const fulfilledThenable = currentEntangledActionThenable;
        fulfilledThenable.status = "fulfilled";
      }
      const listeners = currentEntangledListeners;
      currentEntangledListeners = null;
      currentEntangledLane = NoLane;
      currentEntangledActionThenable = null;
      needsIsomorphicIndicator = false;
      for (let i = 0; i < listeners.length; i++) {
        const listener = listeners[i];
        listener();
      }
    }
  }
}
function chainThenableValue(thenable, result) {
  const listeners = [];
  const thenableWithOverride = {
    status: "pending",
    value: null,
    reason: null,
    then(resolve) {
      listeners.push(resolve);
    }
  };
  thenable.then(
    (value) => {
      const fulfilledThenable = thenableWithOverride;
      fulfilledThenable.status = "fulfilled";
      fulfilledThenable.value = result;
      for (let i = 0; i < listeners.length; i++) {
        const listener = listeners[i];
        listener(result);
      }
    },
    (error) => {
      const rejectedThenable = thenableWithOverride;
      rejectedThenable.status = "rejected";
      rejectedThenable.reason = error;
      for (let i = 0; i < listeners.length; i++) {
        const listener = listeners[i];
        listener(void 0);
      }
    }
  );
  return thenableWithOverride;
}
function peekEntangledActionLane() {
  return currentEntangledLane;
}
function peekEntangledActionThenable() {
  return currentEntangledActionThenable;
}
function registerDefaultIndicator(onDefaultTransitionIndicator) {
  if (!enableDefaultTransitionIndicator) {
    return;
  }
  if (isomorphicDefaultTransitionIndicator === void 0) {
    isomorphicDefaultTransitionIndicator = onDefaultTransitionIndicator;
  } else if (isomorphicDefaultTransitionIndicator !== onDefaultTransitionIndicator) {
    isomorphicDefaultTransitionIndicator = null;
    stopIsomorphicDefaultIndicator();
  }
}
function startIsomorphicDefaultIndicatorIfNeeded() {
  if (!enableDefaultTransitionIndicator) {
    return;
  }
  if (!needsIsomorphicIndicator) {
    return;
  }
  if (isomorphicDefaultTransitionIndicator != null && pendingIsomorphicIndicator === null) {
    try {
      pendingIsomorphicIndicator = isomorphicDefaultTransitionIndicator() || noop;
    } catch (x) {
      pendingIsomorphicIndicator = noop;
      reportGlobalError_default(x);
    }
  }
}
function stopIsomorphicDefaultIndicator() {
  if (!enableDefaultTransitionIndicator) {
    return;
  }
  if (pendingIsomorphicIndicator !== null) {
    const cleanup = pendingIsomorphicIndicator;
    pendingIsomorphicIndicator = null;
    cleanup();
  }
}
function releaseIsomorphicIndicator() {
  if (--pendingEntangledRoots === 0) {
    stopIsomorphicDefaultIndicator();
  }
}
function hasOngoingIsomorphicIndicator() {
  return pendingIsomorphicIndicator !== null;
}
function retainIsomorphicIndicator() {
  pendingEntangledRoots++;
  return releaseIsomorphicIndicator;
}
function markIsomorphicIndicatorHandled() {
  needsIsomorphicIndicator = false;
}

// dist/react-reconciler/src/ReactFiberGestureScheduler.js
function scheduleGesture(root2, provider) {
  let prev = root2.pendingGestures;
  while (prev !== null) {
    if (prev.provider === provider) {
      return prev;
    }
    const next = prev.next;
    if (next === null) {
      break;
    }
    prev = next;
  }
  const gesture = {
    provider,
    count: 0,
    rangeStart: 0,
    // Uninitialized
    rangeEnd: 100,
    // Uninitialized
    types: null,
    running: null,
    prev,
    next: null
  };
  if (prev === null) {
    root2.pendingGestures = gesture;
  } else {
    prev.next = gesture;
  }
  ensureRootIsScheduled(root2);
  return gesture;
}
function startScheduledGesture(root2, gestureTimeline, gestureOptions, transitionTypes) {
  const rangeStart = gestureOptions && gestureOptions.rangeStart != null ? gestureOptions.rangeStart : (void 0)(gestureTimeline);
  const rangeEnd = gestureOptions && gestureOptions.rangeEnd != null ? gestureOptions.rangeEnd : rangeStart < 50 ? 100 : 0;
  let prev = root2.pendingGestures;
  while (prev !== null) {
    if (prev.provider === gestureTimeline) {
      prev.count++;
      prev.rangeStart = rangeStart;
      prev.rangeEnd = rangeEnd;
      if (transitionTypes !== null) {
        let scheduledTypes = prev.types;
        if (scheduledTypes === null) {
          scheduledTypes = prev.types = [];
        }
        for (let i = 0; i < transitionTypes.length; i++) {
          const transitionType = transitionTypes[i];
          if (scheduledTypes.indexOf(transitionType) === -1) {
            scheduledTypes.push(transitionType);
          }
        }
      }
      return prev;
    }
    const next = prev.next;
    if (next === null) {
      break;
    }
    prev = next;
  }
  return null;
}
function cancelScheduledGesture(root2, gesture) {
  gesture.count--;
  if (gesture.count === 0) {
    deleteScheduledGesture(root2, gesture);
    const runningTransition = gesture.running;
    if (runningTransition !== null) {
      const pendingLanesExcludingGestureLane = root2.pendingLanes & ~GestureLane;
      if (includesBlockingLane(pendingLanesExcludingGestureLane) || includesTransitionLane(pendingLanesExcludingGestureLane)) {
        const existing = root2.stoppingGestures;
        if (existing !== null) {
          gesture.next = existing;
          existing.prev = gesture;
        }
        root2.stoppingGestures = gesture;
      } else {
        gesture.running = null;
        (void 0)(runningTransition);
      }
    }
  }
}
function deleteScheduledGesture(root2, gesture) {
  if (gesture.prev === null) {
    if (root2.pendingGestures === gesture) {
      root2.pendingGestures = gesture.next;
      if (root2.pendingGestures === null) {
        root2.pendingLanes &= ~GestureLane;
      }
    }
    if (root2.stoppingGestures === gesture) {
      root2.stoppingGestures = gesture.next;
    }
  } else {
    gesture.prev.next = gesture.next;
    if (gesture.next !== null) {
      gesture.next.prev = gesture.prev;
    }
    gesture.prev = null;
    gesture.next = null;
  }
}
function stopCompletedGestures(root2) {
  let gesture = root2.stoppingGestures;
  root2.stoppingGestures = null;
  while (gesture !== null) {
    if (gesture.running !== null) {
      (void 0)(gesture.running);
      gesture.running = null;
    }
    const nextGesture = gesture.next;
    gesture.next = null;
    gesture.prev = null;
    gesture = nextGesture;
  }
}

// dist/react-reconciler/src/ReactFiberTransition.js
var prevOnStartTransitionFinish = ReactSharedInternals_default.S;
ReactSharedInternals_default.S = function onStartTransitionFinishForReconciler(transition, returnValue) {
  if (typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function") {
    startAsyncTransitionTimer();
    const thenable = returnValue;
    entangleAsyncAction(transition, thenable);
  }
  if (enableViewTransition) {
    if (entangledTransitionTypes !== null) {
      let root2 = firstScheduledRoot;
      while (root2 !== null) {
        queueTransitionTypes(root2, entangledTransitionTypes);
        root2 = root2.next;
      }
    }
    const transitionTypes = transition.types;
    if (transitionTypes !== null) {
      let root2 = firstScheduledRoot;
      while (root2 !== null) {
        queueTransitionTypes(root2, transitionTypes);
        root2 = root2.next;
      }
      if (peekEntangledActionLane() !== NoLane) {
        entangleAsyncTransitionTypes(transitionTypes);
      }
    }
  }
  if (prevOnStartTransitionFinish !== null) {
    prevOnStartTransitionFinish(transition, returnValue);
  }
};
function chainGestureCancellation(root2, scheduledGesture, prevCancel) {
  return function cancelGesture() {
    if (scheduledGesture !== null) {
      cancelScheduledGesture(root2, scheduledGesture);
    }
    if (prevCancel !== null) {
      prevCancel();
    }
  };
}
if (enableGestureTransition) {
  const prevOnStartGestureTransitionFinish = ReactSharedInternals_default.G;
  ReactSharedInternals_default.G = function onStartGestureTransitionFinishForReconciler(transition, provider, options) {
    let cancel = null;
    if (prevOnStartGestureTransitionFinish !== null) {
      cancel = prevOnStartGestureTransitionFinish(
        transition,
        provider,
        options
      );
    }
    let root2 = firstScheduledRoot;
    while (root2 !== null) {
      const scheduledGesture = startScheduledGesture(
        root2,
        provider,
        options,
        transition.types
      );
      if (scheduledGesture !== null) {
        cancel = chainGestureCancellation(root2, scheduledGesture, cancel);
      }
      root2 = root2.next;
    }
    if (cancel !== null) {
      return cancel;
    }
    return function cancelGesture() {
    };
  };
}
function requestCurrentTransition() {
  return ReactSharedInternals_default.T;
}
var resumedCache = createCursor(null);
var transitionStack = createCursor(null);
function peekCacheFromPool() {
  const cacheResumedFromPreviousRender = resumedCache.current;
  if (cacheResumedFromPreviousRender !== null) {
    return cacheResumedFromPreviousRender;
  }
  const root2 = getWorkInProgressRoot();
  const cacheFromRootCachePool = root2.pooledCache;
  return cacheFromRootCachePool;
}
function requestCacheFromPool(renderLanes2) {
  const cacheFromPool = peekCacheFromPool();
  if (cacheFromPool !== null) {
    return cacheFromPool;
  }
  const root2 = getWorkInProgressRoot();
  const freshCache = createCache();
  root2.pooledCache = freshCache;
  retainCache(freshCache);
  if (freshCache !== null) {
    root2.pooledCacheLanes |= renderLanes2;
  }
  return freshCache;
}
function pushRootTransition(workInProgress2, root2, renderLanes2) {
  if (enableTransitionTracing) {
    const rootTransitions = getWorkInProgressTransitions();
    push2(transitionStack, rootTransitions, workInProgress2);
  }
}
function popRootTransition(workInProgress2, root2, renderLanes2) {
  if (enableTransitionTracing) {
    pop2(transitionStack, workInProgress2);
  }
}
function pushTransition(offscreenWorkInProgress, prevCachePool, newTransitions) {
  if (prevCachePool === null) {
    push2(resumedCache, resumedCache.current, offscreenWorkInProgress);
  } else {
    push2(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
  }
  if (enableTransitionTracing) {
    if (transitionStack.current === null) {
      push2(transitionStack, newTransitions, offscreenWorkInProgress);
    } else if (newTransitions === null) {
      push2(transitionStack, transitionStack.current, offscreenWorkInProgress);
    } else {
      push2(
        transitionStack,
        transitionStack.current.concat(newTransitions),
        offscreenWorkInProgress
      );
    }
  }
}
function popTransition(workInProgress2, current2) {
  if (current2 !== null) {
    if (enableTransitionTracing) {
      pop2(transitionStack, workInProgress2);
    }
    pop2(resumedCache, workInProgress2);
  }
}
function getPendingTransitions() {
  if (!enableTransitionTracing) {
    return null;
  }
  return transitionStack.current;
}
function getSuspendedCache() {
  const cacheFromPool = peekCacheFromPool();
  if (cacheFromPool === null) {
    return null;
  }
  return {
    // We must also save the parent, so that when we resume we can detect
    // a refresh.
    parent: void 0 ? CacheContext._currentValue : CacheContext._currentValue2,
    pool: cacheFromPool
  };
}
function getOffscreenDeferredCache() {
  const cacheFromPool = peekCacheFromPool();
  if (cacheFromPool === null) {
    return null;
  }
  return {
    // We must also store the parent, so that when we resume we can detect
    // a refresh.
    parent: void 0 ? CacheContext._currentValue : CacheContext._currentValue2,
    pool: cacheFromPool
  };
}

// dist/shared/shallowEqual.js
function shallowEqual(objA, objB) {
  if (objectIs_default(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    const currentKey = keysA[i];
    if (!hasOwnProperty_default.call(objB, currentKey) || // $FlowFixMe[incompatible-use] lost refinement of `objB`
    !objectIs_default(objA[currentKey], objB[currentKey])) {
      return false;
    }
  }
  return true;
}
var shallowEqual_default = shallowEqual;

// dist/react-reconciler/src/ReactStrictModeWarnings.js
if (false) {
  const findStrictRoot = (fiber) => {
    let maybeStrictRoot = null;
    let node = fiber;
    while (node !== null) {
      if (node.mode & StrictLegacyMode) {
        maybeStrictRoot = node;
      }
      node = node.return;
    }
    return maybeStrictRoot;
  };
  const setToSortedString = (set2) => {
    const array = [];
    set2.forEach((value) => {
      array.push(value);
    });
    return array.sort().join(", ");
  };
  let pendingComponentWillMountWarnings = [];
  let pendingUNSAFE_ComponentWillMountWarnings = [];
  let pendingComponentWillReceivePropsWarnings = [];
  let pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
  let pendingComponentWillUpdateWarnings = [];
  let pendingUNSAFE_ComponentWillUpdateWarnings = [];
  const didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = (fiber, instance) => {
    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
      return;
    }
    if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
    instance.componentWillMount.__suppressDeprecationWarning !== true) {
      pendingComponentWillMountWarnings.push(fiber);
    }
    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
    }
    if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
      pendingComponentWillReceivePropsWarnings.push(fiber);
    }
    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
    }
    if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
      pendingComponentWillUpdateWarnings.push(fiber);
    }
    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
    }
  };
  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = () => {
    const componentWillMountUniqueNames = /* @__PURE__ */ new Set();
    if (pendingComponentWillMountWarnings.length > 0) {
      pendingComponentWillMountWarnings.forEach((fiber) => {
        componentWillMountUniqueNames.add(
          getComponentNameFromFiber(fiber) || "Component"
        );
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillMountWarnings = [];
    }
    const UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
      pendingUNSAFE_ComponentWillMountWarnings.forEach((fiber) => {
        UNSAFE_componentWillMountUniqueNames.add(
          getComponentNameFromFiber(fiber) || "Component"
        );
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillMountWarnings = [];
    }
    const componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
    if (pendingComponentWillReceivePropsWarnings.length > 0) {
      pendingComponentWillReceivePropsWarnings.forEach((fiber) => {
        componentWillReceivePropsUniqueNames.add(
          getComponentNameFromFiber(fiber) || "Component"
        );
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillReceivePropsWarnings = [];
    }
    const UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach((fiber) => {
        UNSAFE_componentWillReceivePropsUniqueNames.add(
          getComponentNameFromFiber(fiber) || "Component"
        );
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    }
    const componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
    if (pendingComponentWillUpdateWarnings.length > 0) {
      pendingComponentWillUpdateWarnings.forEach((fiber) => {
        componentWillUpdateUniqueNames.add(
          getComponentNameFromFiber(fiber) || "Component"
        );
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillUpdateWarnings = [];
    }
    const UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
      pendingUNSAFE_ComponentWillUpdateWarnings.forEach((fiber) => {
        UNSAFE_componentWillUpdateUniqueNames.add(
          getComponentNameFromFiber(fiber) || "Component"
        );
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
    }
    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
      const sortedNames = setToSortedString(
        UNSAFE_componentWillMountUniqueNames
      );
      console.error(
        "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
        sortedNames
      );
    }
    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
      const sortedNames = setToSortedString(
        UNSAFE_componentWillReceivePropsUniqueNames
      );
      console.error(
        "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
        sortedNames
      );
    }
    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
      const sortedNames = setToSortedString(
        UNSAFE_componentWillUpdateUniqueNames
      );
      console.error(
        "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
        sortedNames
      );
    }
    if (componentWillMountUniqueNames.size > 0) {
      const sortedNames = setToSortedString(componentWillMountUniqueNames);
      console.warn(
        "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
        sortedNames
      );
    }
    if (componentWillReceivePropsUniqueNames.size > 0) {
      const sortedNames = setToSortedString(
        componentWillReceivePropsUniqueNames
      );
      console.warn(
        "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
        sortedNames
      );
    }
    if (componentWillUpdateUniqueNames.size > 0) {
      const sortedNames = setToSortedString(componentWillUpdateUniqueNames);
      console.warn(
        "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
        sortedNames
      );
    }
  };
  let pendingLegacyContextWarning = /* @__PURE__ */ new Map();
  const didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
  ReactStrictModeWarnings.recordLegacyContextWarning = (fiber, instance) => {
    const strictRoot = findStrictRoot(fiber);
    if (strictRoot === null) {
      console.error(
        "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
      );
      return;
    }
    if (didWarnAboutLegacyContext.has(fiber.type)) {
      return;
    }
    let warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
      if (warningsForRoot === void 0) {
        warningsForRoot = [];
        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
      }
      warningsForRoot.push(fiber);
    }
  };
  ReactStrictModeWarnings.flushLegacyContextWarning = () => {
    pendingLegacyContextWarning.forEach(
      (fiberArray, strictRoot) => {
        if (fiberArray.length === 0) {
          return;
        }
        const firstFiber = fiberArray[0];
        const uniqueNames = /* @__PURE__ */ new Set();
        fiberArray.forEach((fiber) => {
          uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
          didWarnAboutLegacyContext.add(fiber.type);
        });
        const sortedNames = setToSortedString(uniqueNames);
        runWithFiberInDEV(firstFiber, () => {
          console.error(
            "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
            sortedNames
          );
        });
      }
    );
  };
  ReactStrictModeWarnings.discardPendingWarnings = () => {
    pendingComponentWillMountWarnings = [];
    pendingUNSAFE_ComponentWillMountWarnings = [];
    pendingComponentWillReceivePropsWarnings = [];
    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    pendingComponentWillUpdateWarnings = [];
    pendingUNSAFE_ComponentWillUpdateWarnings = [];
    pendingLegacyContextWarning = /* @__PURE__ */ new Map();
  };
}

// dist/react-reconciler/src/ReactFiberThenable.js
function getThenablesFromState(state) {
  if (false) {
    const devState = state;
    return devState.thenables;
  } else {
    const prodState = state;
    return prodState;
  }
}
var SuspenseException = new Error(
  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
);
var SuspenseyCommitException = new Error(
  "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
);
var SuspenseActionException = new Error(
  "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
);
var noopSuspenseyCommitThenable = {
  then() {
    if (false) {
      console.error(
        'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
      );
    }
  }
};
function createThenableState() {
  if (false) {
    return {
      didWarnAboutUncachedPromise: false,
      thenables: []
    };
  } else {
    return [];
  }
}
function isThenableResolved(thenable) {
  const status = thenable.status;
  return status === "fulfilled" || status === "rejected";
}
function trackUsedThenable(thenableState3, thenable, index2) {
  if (false) {
    ReactSharedInternals_default.didUsePromise = true;
  }
  const trackedThenables = getThenablesFromState(thenableState3);
  const previous = trackedThenables[index2];
  if (previous === void 0) {
    trackedThenables.push(thenable);
  } else {
    if (previous !== thenable) {
      if (false) {
        const thenableStateDev = thenableState3;
        if (!thenableStateDev.didWarnAboutUncachedPromise) {
          thenableStateDev.didWarnAboutUncachedPromise = true;
          console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          );
        }
      }
      thenable.then(noop, noop);
      thenable = previous;
    }
  }
  switch (thenable.status) {
    case "fulfilled": {
      const fulfilledValue = thenable.value;
      return fulfilledValue;
    }
    case "rejected": {
      const rejectedError = thenable.reason;
      checkIfUseWrappedInAsyncCatch(rejectedError);
      throw rejectedError;
    }
    default: {
      if (typeof thenable.status === "string") {
        thenable.then(noop, noop);
      } else {
        const root2 = getWorkInProgressRoot();
        if (root2 !== null && root2.shellSuspendCounter > 100) {
          throw new Error(
            "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
          );
        }
        const pendingThenable = thenable;
        pendingThenable.status = "pending";
        pendingThenable.then(
          (fulfilledValue) => {
            if (thenable.status === "pending") {
              const fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          (error) => {
            if (thenable.status === "pending") {
              const rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          }
        );
      }
      switch (thenable.status) {
        case "fulfilled": {
          const fulfilledThenable = thenable;
          return fulfilledThenable.value;
        }
        case "rejected": {
          const rejectedThenable = thenable;
          const rejectedError = rejectedThenable.reason;
          checkIfUseWrappedInAsyncCatch(rejectedError);
          throw rejectedError;
        }
      }
      suspendedThenable = thenable;
      if (false) {
        needsToResetSuspendedThenableDEV = true;
      }
      throw SuspenseException;
    }
  }
}
function suspendCommit() {
  suspendedThenable = noopSuspenseyCommitThenable;
  throw SuspenseyCommitException;
}
var suspendedThenable = null;
function getSuspendedThenable() {
  if (suspendedThenable === null) {
    throw new Error(
      "Expected a suspended thenable. This is a bug in React. Please file an issue."
    );
  }
  const thenable = suspendedThenable;
  suspendedThenable = null;
  if (false) {
    needsToResetSuspendedThenableDEV = false;
  }
  return thenable;
}
function checkIfUseWrappedInAsyncCatch(rejectedReason) {
  if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) {
    throw new Error(
      "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
    );
  }
}

// dist/react-reconciler/src/ReactFiberCallUserSpace.js
var callComponentInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callComponent["react-stack-bottom-frame"].bind(callComponent)
) : null;
var callRenderInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callRender["react-stack-bottom-frame"].bind(callRender)
) : null;
var callComponentDidMountInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callComponentDidMount["react-stack-bottom-frame"].bind(
    callComponentDidMount
  )
) : null;
var callComponentDidUpdateInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callComponentDidUpdate["react-stack-bottom-frame"].bind(
    callComponentDidUpdate
  )
) : null;
var callComponentDidCatchInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callComponentDidCatch["react-stack-bottom-frame"].bind(
    callComponentDidCatch
  )
) : null;
var callComponentWillUnmountInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callComponentWillUnmount["react-stack-bottom-frame"].bind(
    callComponentWillUnmount
  )
) : null;
var callCreateInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callCreate["react-stack-bottom-frame"].bind(callCreate)
) : null;
var callDestroyInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callDestroy["react-stack-bottom-frame"].bind(callDestroy)
) : null;
var callLazyInitInDEV = false ? (
  // We use this technique to trick minifiers to preserve the function name.
  callLazyInit["react-stack-bottom-frame"].bind(callLazyInit)
) : null;

// dist/react-reconciler/src/ReactChildFiber.js
var thenableState = null;
var thenableIndexCounter = 0;
var currentDebugInfo = null;
function pushDebugInfo(debugInfo) {
  if (true) {
    return null;
  }
  const previousDebugInfo = currentDebugInfo;
  if (debugInfo == null) {
  } else if (previousDebugInfo === null) {
    currentDebugInfo = debugInfo;
  } else {
    currentDebugInfo = previousDebugInfo.concat(debugInfo);
  }
  return previousDebugInfo;
}
if (false) {
  didWarnAboutMaps = false;
  didWarnAboutGenerators = false;
  ownerHasKeyUseWarning = {};
  ownerHasFunctionTypeWarning = {};
  ownerHasSymbolTypeWarning = {};
  warnForMissingKey = (returnFiber, workInProgress2, child) => {
    if (child === null || typeof child !== "object") {
      return;
    }
    if (!child._store || (child._store.validated || child.key != null) && child._store.validated !== 2) {
      return;
    }
    if (typeof child._store !== "object") {
      throw new Error(
        "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    child._store.validated = 1;
    const componentName = getComponentNameFromFiber(returnFiber);
    const componentKey = componentName || "null";
    if (ownerHasKeyUseWarning[componentKey]) {
      return;
    }
    ownerHasKeyUseWarning[componentKey] = true;
    const childOwner = child._owner;
    const parentOwner = returnFiber._debugOwner;
    let currentComponentErrorInfo = "";
    if (parentOwner && typeof parentOwner.tag === "number") {
      const name = getComponentNameFromFiber(parentOwner);
      if (name) {
        currentComponentErrorInfo = "\n\nCheck the render method of `" + name + "`.";
      }
    }
    if (!currentComponentErrorInfo) {
      if (componentName) {
        currentComponentErrorInfo = `

Check the top-level render call using <${componentName}>.`;
      }
    }
    let childOwnerAppendix = "";
    if (childOwner != null && parentOwner !== childOwner) {
      let ownerName = null;
      if (typeof childOwner.tag === "number") {
        ownerName = getComponentNameFromFiber(childOwner);
      } else if (typeof childOwner.name === "string") {
        ownerName = childOwner.name;
      }
      if (ownerName) {
        childOwnerAppendix = ` It was passed a child from ${ownerName}.`;
      }
    }
    runWithFiberInDEV(workInProgress2, () => {
      console.error(
        'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
        currentComponentErrorInfo,
        childOwnerAppendix
      );
    });
  };
}
function validateFragmentProps(element, fiber, returnFiber) {
  if (false) {
    const keys = Object.keys(element.props);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key !== "children" && key !== "key" && (enableFragmentRefs ? key !== "ref" : true)) {
        if (fiber === null) {
          fiber = createFiberFromElement(element, returnFiber.mode, 0);
          if (false) {
            fiber._debugInfo = currentDebugInfo;
          }
          fiber.return = returnFiber;
        }
        runWithFiberInDEV(
          fiber,
          (erroredKey) => {
            if (enableFragmentRefs) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key`, `ref`, and `children` props.",
                erroredKey
              );
            } else {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                erroredKey
              );
            }
          },
          key
        );
        break;
      }
    }
  }
}
function unwrapThenable(thenable) {
  const index2 = thenableIndexCounter;
  thenableIndexCounter += 1;
  if (thenableState === null) {
    thenableState = createThenableState();
  }
  return trackUsedThenable(thenableState, thenable, index2);
}
function coerceRef(workInProgress2, element) {
  const refProp = element.props.ref;
  workInProgress2.ref = refProp !== void 0 ? refProp : null;
}
function throwOnInvalidObjectType(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) {
    throw new Error(
      'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
    );
  }
  const childString = Object.prototype.toString.call(newChild);
  throw new Error(
    `Objects are not valid as a React child (found: ${childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString}). If you meant to render a collection of children, use an array instead.`
  );
}
function resolveLazy(lazyType) {
  if (false) {
    return callLazyInitInDEV(lazyType);
  }
  const payload = lazyType._payload;
  const init = lazyType._init;
  return init(payload);
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      return;
    }
    const deletions = returnFiber.deletions;
    if (deletions === null) {
      returnFiber.deletions = [childToDelete];
      returnFiber.flags |= ChildDeletion;
    } else {
      deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      return null;
    }
    let childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    const existingChildren = /* @__PURE__ */ new Map();
    let existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    const clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      newFiber.flags |= Forked;
      return lastPlacedIndex;
    }
    const current2 = newFiber.alternate;
    if (current2 !== null) {
      const oldIndex = current2.index;
      if (oldIndex < lastPlacedIndex) {
        newFiber.flags |= Placement | PlacementDEV;
        return lastPlacedIndex;
      } else {
        return oldIndex;
      }
    } else {
      newFiber.flags |= Placement | PlacementDEV;
      return lastPlacedIndex;
    }
  }
  function placeSingleChild(newFiber) {
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.flags |= Placement | PlacementDEV;
    }
    return newFiber;
  }
  function updateTextNode(returnFiber, current2, textContent, lanes) {
    if (current2 === null || current2.tag !== HostText) {
      const created = createFiberFromText(textContent, returnFiber.mode, lanes);
      created.return = returnFiber;
      if (false) {
        created._debugOwner = returnFiber;
        created._debugTask = returnFiber._debugTask;
        created._debugInfo = currentDebugInfo;
      }
      return created;
    } else {
      const existing = useFiber(current2, textContent);
      existing.return = returnFiber;
      if (false) {
        existing._debugInfo = currentDebugInfo;
      }
      return existing;
    }
  }
  function updateElement(returnFiber, current2, element, lanes) {
    const elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE) {
      const updated = updateFragment2(
        returnFiber,
        current2,
        element.props.children,
        lanes,
        element.key
      );
      if (enableFragmentRefs) {
        coerceRef(updated, element);
      }
      validateFragmentProps(element, updated, returnFiber);
      return updated;
    }
    if (current2 !== null) {
      if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
      (false ? isCompatibleFamilyForHotReloading(current2, element) : false) || // Lazy types should reconcile their resolved type.
      // We need to do this after the Hot Reloading check above,
      // because hot reloading has different semantics than prod because
      // it doesn't resuspend. So we can't let the call below suspend.
      typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
        const existing = useFiber(current2, element.props);
        coerceRef(existing, element);
        existing.return = returnFiber;
        if (false) {
          existing._debugOwner = element._owner;
          existing._debugInfo = currentDebugInfo;
        }
        return existing;
      }
    }
    const created = createFiberFromElement(element, returnFiber.mode, lanes);
    coerceRef(created, element);
    created.return = returnFiber;
    if (false) {
      created._debugInfo = currentDebugInfo;
    }
    return created;
  }
  function updatePortal(returnFiber, current2, portal, lanes) {
    if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
      const created = createFiberFromPortal(portal, returnFiber.mode, lanes);
      created.return = returnFiber;
      if (false) {
        created._debugInfo = currentDebugInfo;
      }
      return created;
    } else {
      const existing = useFiber(current2, portal.children || []);
      existing.return = returnFiber;
      if (false) {
        existing._debugInfo = currentDebugInfo;
      }
      return existing;
    }
  }
  function updateFragment2(returnFiber, current2, fragment, lanes, key) {
    if (current2 === null || current2.tag !== Fragment) {
      const created = createFiberFromFragment(
        fragment,
        returnFiber.mode,
        lanes,
        key
      );
      created.return = returnFiber;
      if (false) {
        created._debugOwner = returnFiber;
        created._debugTask = returnFiber._debugTask;
        created._debugInfo = currentDebugInfo;
      }
      return created;
    } else {
      const existing = useFiber(current2, fragment);
      existing.return = returnFiber;
      if (false) {
        existing._debugInfo = currentDebugInfo;
      }
      return existing;
    }
  }
  function createChild(returnFiber, newChild, lanes) {
    if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint") {
      const created = createFiberFromText(
        // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
        "" + newChild,
        returnFiber.mode,
        lanes
      );
      created.return = returnFiber;
      if (false) {
        created._debugOwner = returnFiber;
        created._debugTask = returnFiber._debugTask;
        created._debugInfo = currentDebugInfo;
      }
      return created;
    }
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const created = createFiberFromElement(
            newChild,
            returnFiber.mode,
            lanes
          );
          coerceRef(created, newChild);
          created.return = returnFiber;
          if (false) {
            const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            created._debugInfo = currentDebugInfo;
            currentDebugInfo = prevDebugInfo;
          }
          return created;
        }
        case REACT_PORTAL_TYPE: {
          const created = createFiberFromPortal(
            newChild,
            returnFiber.mode,
            lanes
          );
          created.return = returnFiber;
          if (false) {
            created._debugInfo = currentDebugInfo;
          }
          return created;
        }
        case REACT_LAZY_TYPE: {
          const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
          let resolvedChild;
          if (false) {
            resolvedChild = callLazyInitInDEV(newChild);
          } else {
            const payload = newChild._payload;
            const init = newChild._init;
            resolvedChild = init(payload);
          }
          const created = createChild(returnFiber, resolvedChild, lanes);
          currentDebugInfo = prevDebugInfo;
          return created;
        }
      }
      if (isArray_default(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren && typeof newChild[ASYNC_ITERATOR] === "function") {
        const created = createFiberFromFragment(
          newChild,
          returnFiber.mode,
          lanes,
          null
        );
        created.return = returnFiber;
        if (false) {
          created._debugOwner = returnFiber;
          created._debugTask = returnFiber._debugTask;
          const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
          created._debugInfo = currentDebugInfo;
          currentDebugInfo = prevDebugInfo;
        }
        return created;
      }
      if (typeof newChild.then === "function") {
        const thenable = newChild;
        const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
        const created = createChild(
          returnFiber,
          unwrapThenable(thenable),
          lanes
        );
        currentDebugInfo = prevDebugInfo;
        return created;
      }
      if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
        const context = newChild;
        return createChild(
          returnFiber,
          readContextDuringReconciliation(returnFiber, context, lanes),
          lanes
        );
      }
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    if (false) {
      if (typeof newChild === "function") {
        warnOnFunctionType(returnFiber, newChild);
      }
      if (typeof newChild === "symbol") {
        warnOnSymbolType(returnFiber, newChild);
      }
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    const key = oldFiber !== null ? oldFiber.key : null;
    if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint") {
      if (key !== null) {
        return null;
      }
      return updateTextNode(
        returnFiber,
        oldFiber,
        // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
        "" + newChild,
        lanes
      );
    }
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          if (newChild.key === key) {
            const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            const updated = updateElement(
              returnFiber,
              oldFiber,
              newChild,
              lanes
            );
            currentDebugInfo = prevDebugInfo;
            return updated;
          } else {
            return null;
          }
        }
        case REACT_PORTAL_TYPE: {
          if (newChild.key === key) {
            return updatePortal(returnFiber, oldFiber, newChild, lanes);
          } else {
            return null;
          }
        }
        case REACT_LAZY_TYPE: {
          const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
          let resolvedChild;
          if (false) {
            resolvedChild = callLazyInitInDEV(newChild);
          } else {
            const payload = newChild._payload;
            const init = newChild._init;
            resolvedChild = init(payload);
          }
          const updated = updateSlot(
            returnFiber,
            oldFiber,
            resolvedChild,
            lanes
          );
          currentDebugInfo = prevDebugInfo;
          return updated;
        }
      }
      if (isArray_default(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren && typeof newChild[ASYNC_ITERATOR] === "function") {
        if (key !== null) {
          return null;
        }
        const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
        const updated = updateFragment2(
          returnFiber,
          oldFiber,
          newChild,
          lanes,
          null
        );
        currentDebugInfo = prevDebugInfo;
        return updated;
      }
      if (typeof newChild.then === "function") {
        const thenable = newChild;
        const prevDebugInfo = pushDebugInfo(thenable._debugInfo);
        const updated = updateSlot(
          returnFiber,
          oldFiber,
          unwrapThenable(thenable),
          lanes
        );
        currentDebugInfo = prevDebugInfo;
        return updated;
      }
      if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
        const context = newChild;
        return updateSlot(
          returnFiber,
          oldFiber,
          readContextDuringReconciliation(returnFiber, context, lanes),
          lanes
        );
      }
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    if (false) {
      if (typeof newChild === "function") {
        warnOnFunctionType(returnFiber, newChild);
      }
      if (typeof newChild === "symbol") {
        warnOnSymbolType(returnFiber, newChild);
      }
    }
    return null;
  }
  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
    if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint") {
      const matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(
        returnFiber,
        matchedFiber,
        // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
        "" + newChild,
        lanes
      );
    }
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const matchedFiber = existingChildren.get(
            newChild.key === null ? newIdx : newChild.key
          ) || null;
          const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
          const updated = updateElement(
            returnFiber,
            matchedFiber,
            newChild,
            lanes
          );
          currentDebugInfo = prevDebugInfo;
          return updated;
        }
        case REACT_PORTAL_TYPE: {
          const matchedFiber = existingChildren.get(
            newChild.key === null ? newIdx : newChild.key
          ) || null;
          return updatePortal(returnFiber, matchedFiber, newChild, lanes);
        }
        case REACT_LAZY_TYPE: {
          const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
          let resolvedChild;
          if (false) {
            resolvedChild = callLazyInitInDEV(newChild);
          } else {
            const payload = newChild._payload;
            const init = newChild._init;
            resolvedChild = init(payload);
          }
          const updated = updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            resolvedChild,
            lanes
          );
          currentDebugInfo = prevDebugInfo;
          return updated;
        }
      }
      if (isArray_default(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren && typeof newChild[ASYNC_ITERATOR] === "function") {
        const matchedFiber = existingChildren.get(newIdx) || null;
        const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
        const updated = updateFragment2(
          returnFiber,
          matchedFiber,
          newChild,
          lanes,
          null
        );
        currentDebugInfo = prevDebugInfo;
        return updated;
      }
      if (typeof newChild.then === "function") {
        const thenable = newChild;
        const prevDebugInfo = pushDebugInfo(thenable._debugInfo);
        const updated = updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          unwrapThenable(thenable),
          lanes
        );
        currentDebugInfo = prevDebugInfo;
        return updated;
      }
      if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
        const context = newChild;
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          readContextDuringReconciliation(returnFiber, context, lanes),
          lanes
        );
      }
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    if (false) {
      if (typeof newChild === "function") {
        warnOnFunctionType(returnFiber, newChild);
      }
      if (typeof newChild === "symbol") {
        warnOnSymbolType(returnFiber, newChild);
      }
    }
    return null;
  }
  function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
    if (false) {
      if (typeof child !== "object" || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(returnFiber, workInProgress2, child);
          const key = child.key;
          if (typeof key !== "string") {
            break;
          }
          if (knownKeys === null) {
            knownKeys = /* @__PURE__ */ new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          runWithFiberInDEV(workInProgress2, () => {
            console.error(
              "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
              key
            );
          });
          break;
        case REACT_LAZY_TYPE: {
          let resolvedChild;
          if (false) {
            resolvedChild = callLazyInitInDEV(child);
          } else {
            const payload = child._payload;
            const init = child._init;
            resolvedChild = init(payload);
          }
          warnOnInvalidKey(
            returnFiber,
            workInProgress2,
            resolvedChild,
            knownKeys
          );
          break;
        }
        default:
          break;
      }
    }
    return knownKeys;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    let knownKeys = null;
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let oldFiber = currentFirstChild;
    let lastPlacedIndex = 0;
    let newIdx = 0;
    let nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      const newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes
      );
      if (newFiber === null) {
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (false) {
        knownKeys = warnOnInvalidKey(
          returnFiber,
          newFiber,
          newChildren[newIdx],
          knownKeys
        );
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length) {
      deleteRemainingChildren(returnFiber, oldFiber);
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }
    if (oldFiber === null) {
      for (; newIdx < newChildren.length; newIdx++) {
        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
        if (newFiber === null) {
          continue;
        }
        if (false) {
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            newChildren[newIdx],
            knownKeys
          );
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }
    const existingChildren = mapRemainingChildren(oldFiber);
    for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes
      );
      if (newFiber !== null) {
        if (false) {
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            newChildren[newIdx],
            knownKeys
          );
        }
        if (shouldTrackSideEffects) {
          if (newFiber.alternate !== null) {
            existingChildren.delete(
              newFiber.key === null ? newIdx : newFiber.key
            );
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
    if (shouldTrackSideEffects) {
      existingChildren.forEach((child) => deleteChild(returnFiber, child));
    }
    if (getIsHydrating()) {
      const numberOfForks = newIdx;
      pushTreeFork(returnFiber, numberOfForks);
    }
    return resultingFirstChild;
  }
  function reconcileChildrenIteratable(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
    const iteratorFn = getIteratorFn(newChildrenIterable);
    if (typeof iteratorFn !== "function") {
      throw new Error(
        "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    const newChildren = iteratorFn.call(newChildrenIterable);
    if (false) {
      if (newChildren === newChildrenIterable) {
        const isGeneratorComponent = returnFiber.tag === FunctionComponent && // $FlowFixMe[method-unbinding]
        Object.prototype.toString.call(returnFiber.type) === "[object GeneratorFunction]" && // $FlowFixMe[method-unbinding]
        Object.prototype.toString.call(newChildren) === "[object Generator]";
        if (!isGeneratorComponent) {
          if (!didWarnAboutGenerators) {
            console.error(
              "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
            );
          }
          didWarnAboutGenerators = true;
        }
      } else if (newChildrenIterable.entries === iteratorFn) {
        if (!didWarnAboutMaps) {
          console.error(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          );
          didWarnAboutMaps = true;
        }
      }
    }
    return reconcileChildrenIterator(
      returnFiber,
      currentFirstChild,
      newChildren,
      lanes
    );
  }
  function reconcileChildrenAsyncIteratable(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
    const newChildren = newChildrenIterable[ASYNC_ITERATOR]();
    if (false) {
      if (newChildren === newChildrenIterable) {
        const isGeneratorComponent = returnFiber.tag === FunctionComponent && // $FlowFixMe[method-unbinding]
        Object.prototype.toString.call(returnFiber.type) === "[object AsyncGeneratorFunction]" && // $FlowFixMe[method-unbinding]
        Object.prototype.toString.call(newChildren) === "[object AsyncGenerator]";
        if (!isGeneratorComponent) {
          if (!didWarnAboutGenerators) {
            console.error(
              "Using AsyncIterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You can use an AsyncIterable that can iterate multiple times over the same items."
            );
          }
          didWarnAboutGenerators = true;
        }
      }
    }
    if (newChildren == null) {
      throw new Error("An iterable object provided no iterator.");
    }
    const iterator = {
      next() {
        return unwrapThenable(newChildren.next());
      }
    };
    return reconcileChildrenIterator(
      returnFiber,
      currentFirstChild,
      iterator,
      lanes
    );
  }
  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
    if (newChildren == null) {
      throw new Error("An iterable object provided no iterator.");
    }
    let resultingFirstChild = null;
    let previousNewFiber = null;
    let oldFiber = currentFirstChild;
    let lastPlacedIndex = 0;
    let newIdx = 0;
    let nextOldFiber = null;
    let knownKeys = null;
    let step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      const newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (newFiber === null) {
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (false) {
        knownKeys = warnOnInvalidKey(
          returnFiber,
          newFiber,
          step.value,
          knownKeys
        );
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done) {
      deleteRemainingChildren(returnFiber, oldFiber);
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }
    if (oldFiber === null) {
      for (; !step.done; newIdx++, step = newChildren.next()) {
        const newFiber = createChild(returnFiber, step.value, lanes);
        if (newFiber === null) {
          continue;
        }
        if (false) {
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            step.value,
            knownKeys
          );
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
      if (getIsHydrating()) {
        const numberOfForks = newIdx;
        pushTreeFork(returnFiber, numberOfForks);
      }
      return resultingFirstChild;
    }
    const existingChildren = mapRemainingChildren(oldFiber);
    for (; !step.done; newIdx++, step = newChildren.next()) {
      const newFiber = updateFromMap(
        existingChildren,
        returnFiber,
        newIdx,
        step.value,
        lanes
      );
      if (newFiber !== null) {
        if (false) {
          knownKeys = warnOnInvalidKey(
            returnFiber,
            newFiber,
            step.value,
            knownKeys
          );
        }
        if (shouldTrackSideEffects) {
          if (newFiber.alternate !== null) {
            existingChildren.delete(
              newFiber.key === null ? newIdx : newFiber.key
            );
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = newFiber;
        } else {
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
      }
    }
    if (shouldTrackSideEffects) {
      existingChildren.forEach((child) => deleteChild(returnFiber, child));
    }
    if (getIsHydrating()) {
      const numberOfForks = newIdx;
      pushTreeFork(returnFiber, numberOfForks);
    }
    return resultingFirstChild;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      const existing = useFiber(currentFirstChild, textContent);
      existing.return = returnFiber;
      return existing;
    }
    deleteRemainingChildren(returnFiber, currentFirstChild);
    const created = createFiberFromText(textContent, returnFiber.mode, lanes);
    created.return = returnFiber;
    if (false) {
      created._debugOwner = returnFiber;
      created._debugTask = returnFiber._debugTask;
      created._debugInfo = currentDebugInfo;
    }
    return created;
  }
  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key === key) {
        const elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE) {
          if (child.tag === Fragment) {
            deleteRemainingChildren(returnFiber, child.sibling);
            const existing = useFiber(child, element.props.children);
            if (enableFragmentRefs) {
              coerceRef(existing, element);
            }
            existing.return = returnFiber;
            if (false) {
              existing._debugOwner = element._owner;
              existing._debugInfo = currentDebugInfo;
            }
            validateFragmentProps(element, existing, returnFiber);
            return existing;
          }
        } else {
          if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
          (false ? isCompatibleFamilyForHotReloading(child, element) : false) || // Lazy types should reconcile their resolved type.
          // We need to do this after the Hot Reloading check above,
          // because hot reloading has different semantics than prod because
          // it doesn't resuspend. So we can't let the call below suspend.
          typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
            deleteRemainingChildren(returnFiber, child.sibling);
            const existing = useFiber(child, element.props);
            coerceRef(existing, element);
            existing.return = returnFiber;
            if (false) {
              existing._debugOwner = element._owner;
              existing._debugInfo = currentDebugInfo;
            }
            return existing;
          }
        }
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    if (element.type === REACT_FRAGMENT_TYPE) {
      const created = createFiberFromFragment(
        element.props.children,
        returnFiber.mode,
        lanes,
        element.key
      );
      if (enableFragmentRefs) {
        coerceRef(created, element);
      }
      created.return = returnFiber;
      if (false) {
        created._debugOwner = returnFiber;
        created._debugTask = returnFiber._debugTask;
        created._debugInfo = currentDebugInfo;
      }
      validateFragmentProps(element, created, returnFiber);
      return created;
    } else {
      const created = createFiberFromElement(element, returnFiber.mode, lanes);
      coerceRef(created, element);
      created.return = returnFiber;
      if (false) {
        created._debugInfo = currentDebugInfo;
      }
      return created;
    }
  }
  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
    const key = portal.key;
    let child = currentFirstChild;
    while (child !== null) {
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          const existing = useFiber(child, portal.children || []);
          existing.return = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }
    const created = createFiberFromPortal(portal, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  }
  function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
    const isUnkeyedUnrefedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null && (enableFragmentRefs ? newChild.props.ref === void 0 : true);
    if (isUnkeyedUnrefedTopLevelFragment) {
      validateFragmentProps(newChild, null, returnFiber);
      newChild = newChild.props.children;
    }
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE: {
          const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
          const firstChild = placeSingleChild(
            reconcileSingleElement(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            )
          );
          currentDebugInfo = prevDebugInfo;
          return firstChild;
        }
        case REACT_PORTAL_TYPE:
          return placeSingleChild(
            reconcileSinglePortal(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            )
          );
        case REACT_LAZY_TYPE: {
          const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
          let result;
          if (false) {
            result = callLazyInitInDEV(newChild);
          } else {
            const payload = newChild._payload;
            const init = newChild._init;
            result = init(payload);
          }
          const firstChild = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            result,
            lanes
          );
          currentDebugInfo = prevDebugInfo;
          return firstChild;
        }
      }
      if (isArray_default(newChild)) {
        const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
        const firstChild = reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
        currentDebugInfo = prevDebugInfo;
        return firstChild;
      }
      if (getIteratorFn(newChild)) {
        const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
        const firstChild = reconcileChildrenIteratable(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
        currentDebugInfo = prevDebugInfo;
        return firstChild;
      }
      if (enableAsyncIterableChildren && typeof newChild[ASYNC_ITERATOR] === "function") {
        const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
        const firstChild = reconcileChildrenAsyncIteratable(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
        currentDebugInfo = prevDebugInfo;
        return firstChild;
      }
      if (typeof newChild.then === "function") {
        const thenable = newChild;
        const prevDebugInfo = pushDebugInfo(thenable._debugInfo);
        const firstChild = reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          unwrapThenable(thenable),
          lanes
        );
        currentDebugInfo = prevDebugInfo;
        return firstChild;
      }
      if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
        const context = newChild;
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          readContextDuringReconciliation(returnFiber, context, lanes),
          lanes
        );
      }
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint") {
      return placeSingleChild(
        reconcileSingleTextNode(
          returnFiber,
          currentFirstChild,
          // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
          "" + newChild,
          lanes
        )
      );
    }
    if (false) {
      if (typeof newChild === "function") {
        warnOnFunctionType(returnFiber, newChild);
      }
      if (typeof newChild === "symbol") {
        warnOnSymbolType(returnFiber, newChild);
      }
    }
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
    const prevDebugInfo = currentDebugInfo;
    currentDebugInfo = null;
    try {
      thenableIndexCounter = 0;
      const firstChildFiber = reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
      thenableState = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException || x === SuspenseActionException || !disableLegacyMode && (returnFiber.mode & ConcurrentMode) === NoMode && typeof x === "object" && x !== null && typeof x.then === "function") {
        throw x;
      }
      const throwFiber = createFiberFromThrow(x, returnFiber.mode, lanes);
      throwFiber.return = returnFiber;
      if (false) {
        const debugInfo = throwFiber._debugInfo = currentDebugInfo;
        throwFiber._debugOwner = returnFiber._debugOwner;
        throwFiber._debugTask = returnFiber._debugTask;
        if (debugInfo != null) {
          for (let i = debugInfo.length - 1; i >= 0; i--) {
            if (typeof debugInfo[i].stack === "string") {
              throwFiber._debugOwner = debugInfo[i];
              throwFiber._debugTask = debugInfo[i].debugTask;
              break;
            }
          }
        }
      }
      return throwFiber;
    } finally {
      currentDebugInfo = prevDebugInfo;
    }
  }
  return reconcileChildFibers2;
}
var reconcileChildFibers = createChildReconciler(true);
var mountChildFibers = createChildReconciler(false);
function resetChildReconcilerOnUnwind() {
  thenableState = null;
  thenableIndexCounter = 0;
}
function cloneChildFibers(current2, workInProgress2) {
  if (current2 !== null && workInProgress2.child !== current2.child) {
    throw new Error("Resuming work not yet implemented.");
  }
  if (workInProgress2.child === null) {
    return;
  }
  let currentChild = workInProgress2.child;
  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
  workInProgress2.child = newChild;
  newChild.return = workInProgress2;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(
      currentChild,
      currentChild.pendingProps
    );
    newChild.return = workInProgress2;
  }
  newChild.sibling = null;
}
function resetChildFibers(workInProgress2, lanes) {
  let child = workInProgress2.child;
  while (child !== null) {
    resetWorkInProgress(child, lanes);
    child = child.sibling;
  }
}

// dist/react-reconciler/src/ReactFiberConcurrentUpdates.js
var concurrentQueues = [];
var concurrentQueuesIndex = 0;
var concurrentlyUpdatedLanes = NoLanes;
function finishQueueingConcurrentUpdates() {
  const endIndex = concurrentQueuesIndex;
  concurrentQueuesIndex = 0;
  concurrentlyUpdatedLanes = NoLanes;
  let i = 0;
  while (i < endIndex) {
    const fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    const queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    const update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    const lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (queue !== null && update !== null) {
      const pending = queue.pending;
      if (pending === null) {
        update.next = update;
      } else {
        update.next = pending.next;
        pending.next = update;
      }
      queue.pending = update;
    }
    if (lane !== NoLane) {
      markUpdateLaneFromFiberToRoot(fiber, update, lane);
    }
  }
}
function getConcurrentlyUpdatedLanes() {
  return concurrentlyUpdatedLanes;
}
function enqueueUpdate(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane);
  fiber.lanes = mergeLanes(fiber.lanes, lane);
  const alternate = fiber.alternate;
  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  const concurrentQueue = queue;
  const concurrentUpdate = update;
  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update) {
  const lane = NoLane;
  const concurrentQueue = queue;
  const concurrentUpdate = update;
  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);
  const isConcurrentlyRendering = getWorkInProgressRoot() !== null;
  if (!isConcurrentlyRendering) {
    finishQueueingConcurrentUpdates();
  }
}
function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
  const concurrentQueue = queue;
  const concurrentUpdate = update;
  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function unsafe_markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
  const root2 = getRootForUpdatedFiber(sourceFiber);
  markUpdateLaneFromFiberToRoot(sourceFiber, null, lane);
  return root2;
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
  let alternate = sourceFiber.alternate;
  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }
  let isHidden = false;
  let parent = sourceFiber.return;
  let node = sourceFiber;
  while (parent !== null) {
    parent.childLanes = mergeLanes(parent.childLanes, lane);
    alternate = parent.alternate;
    if (alternate !== null) {
      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
    }
    if (parent.tag === OffscreenComponent) {
      const offscreenInstance = parent.stateNode;
      if (offscreenInstance !== null && !(offscreenInstance._visibility & OffscreenVisible)) {
        isHidden = true;
      }
    }
    node = parent;
    parent = parent.return;
  }
  if (node.tag === HostRoot) {
    const root2 = node.stateNode;
    if (isHidden && update !== null) {
      markHiddenUpdate(root2, update, lane);
    }
    return root2;
  }
  return null;
}
function getRootForUpdatedFiber(sourceFiber) {
  throwIfInfiniteUpdateLoopDetected();
  detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);
  let node = sourceFiber;
  let parent = node.return;
  while (parent !== null) {
    detectUpdateOnUnmountedFiber(sourceFiber, node);
    node = parent;
    parent = node.return;
  }
  return node.tag === HostRoot ? node.stateNode : null;
}
function detectUpdateOnUnmountedFiber(sourceFiber, parent) {
  if (false) {
    const alternate = parent.alternate;
    if (alternate === null && (parent.flags & (Placement | Hydrating)) !== NoFlags) {
      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
    }
  }
}

// dist/react-reconciler/src/ReactFiberClassUpdateQueue.js
var UpdateState = 0;
var ReplaceState = 1;
var ForceUpdate = 2;
var CaptureUpdate = 3;
var hasForceUpdate = false;
if (false) {
  didWarnUpdateInsideUpdate = false;
  currentlyProcessingQueue = null;
  resetCurrentlyProcessingQueue = () => {
    currentlyProcessingQueue = null;
  };
}
function initializeUpdateQueue(fiber) {
  const queue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      lanes: NoLanes,
      hiddenCallbacks: null
    },
    callbacks: null
  };
  fiber.updateQueue = queue;
}
function cloneUpdateQueue(current2, workInProgress2) {
  const queue = workInProgress2.updateQueue;
  const currentQueue = current2.updateQueue;
  if (queue === currentQueue) {
    const clone = {
      baseState: currentQueue.baseState,
      firstBaseUpdate: currentQueue.firstBaseUpdate,
      lastBaseUpdate: currentQueue.lastBaseUpdate,
      shared: currentQueue.shared,
      callbacks: null
    };
    workInProgress2.updateQueue = clone;
  }
}
function createUpdate(lane) {
  const update = {
    lane,
    tag: UpdateState,
    payload: null,
    callback: null,
    next: null
  };
  return update;
}
function enqueueUpdate2(fiber, update, lane) {
  const updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return null;
  }
  const sharedQueue = updateQueue.shared;
  if (false) {
    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
      const componentName = getComponentNameFromFiber(fiber);
      console.error(
        "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
        componentName
      );
      didWarnUpdateInsideUpdate = true;
    }
  }
  if (isUnsafeClassRenderPhaseUpdate(fiber)) {
    const pending = sharedQueue.pending;
    if (pending === null) {
      update.next = update;
    } else {
      update.next = pending.next;
      pending.next = update;
    }
    sharedQueue.pending = update;
    return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
  } else {
    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
  }
}
function entangleTransitions(root2, fiber, lane) {
  const updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return;
  }
  const sharedQueue = updateQueue.shared;
  if (isTransitionLane(lane)) {
    let queueLanes = sharedQueue.lanes;
    queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
    const newQueueLanes = mergeLanes(queueLanes, lane);
    sharedQueue.lanes = newQueueLanes;
    markRootEntangled(root2, newQueueLanes);
  }
}
function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
  let queue = workInProgress2.updateQueue;
  const current2 = workInProgress2.alternate;
  if (current2 !== null) {
    const currentQueue = current2.updateQueue;
    if (queue === currentQueue) {
      let newFirst = null;
      let newLast = null;
      const firstBaseUpdate = queue.firstBaseUpdate;
      if (firstBaseUpdate !== null) {
        let update = firstBaseUpdate;
        do {
          const clone = {
            lane: update.lane,
            tag: update.tag,
            payload: update.payload,
            // When this update is rebased, we should not fire its
            // callback again.
            callback: null,
            next: null
          };
          if (newLast === null) {
            newFirst = newLast = clone;
          } else {
            newLast.next = clone;
            newLast = clone;
          }
          update = update.next;
        } while (update !== null);
        if (newLast === null) {
          newFirst = newLast = capturedUpdate;
        } else {
          newLast.next = capturedUpdate;
          newLast = capturedUpdate;
        }
      } else {
        newFirst = newLast = capturedUpdate;
      }
      queue = {
        baseState: currentQueue.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: currentQueue.shared,
        callbacks: currentQueue.callbacks
      };
      workInProgress2.updateQueue = queue;
      return;
    }
  }
  const lastBaseUpdate = queue.lastBaseUpdate;
  if (lastBaseUpdate === null) {
    queue.firstBaseUpdate = capturedUpdate;
  } else {
    lastBaseUpdate.next = capturedUpdate;
  }
  queue.lastBaseUpdate = capturedUpdate;
}
function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
  switch (update.tag) {
    case ReplaceState: {
      const payload = update.payload;
      if (typeof payload === "function") {
        if (false) {
          enterDisallowedContextReadInDEV();
        }
        const nextState = payload.call(instance, prevState, nextProps);
        if (false) {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              payload.call(instance, prevState, nextProps);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          exitDisallowedContextReadInDEV();
        }
        return nextState;
      }
      return payload;
    }
    case CaptureUpdate: {
      workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
    }
    // Intentional fallthrough
    case UpdateState: {
      const payload = update.payload;
      let partialState;
      if (typeof payload === "function") {
        if (false) {
          enterDisallowedContextReadInDEV();
        }
        partialState = payload.call(instance, prevState, nextProps);
        if (false) {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              payload.call(instance, prevState, nextProps);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          exitDisallowedContextReadInDEV();
        }
      } else {
        partialState = payload;
      }
      if (partialState === null || partialState === void 0) {
        return prevState;
      }
      return assign_default({}, prevState, partialState);
    }
    case ForceUpdate: {
      hasForceUpdate = true;
      return prevState;
    }
  }
  return prevState;
}
var didReadFromEntangledAsyncAction = false;
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    const entangledActionThenable = peekEntangledActionThenable();
    if (entangledActionThenable !== null) {
      throw entangledActionThenable;
    }
  }
}
function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
  didReadFromEntangledAsyncAction = false;
  const queue = workInProgress2.updateQueue;
  hasForceUpdate = false;
  if (false) {
    currentlyProcessingQueue = queue.shared;
  }
  let firstBaseUpdate = queue.firstBaseUpdate;
  let lastBaseUpdate = queue.lastBaseUpdate;
  let pendingQueue = queue.shared.pending;
  if (pendingQueue !== null) {
    queue.shared.pending = null;
    const lastPendingUpdate = pendingQueue;
    const firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    if (lastBaseUpdate === null) {
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }
    lastBaseUpdate = lastPendingUpdate;
    const current2 = workInProgress2.alternate;
    if (current2 !== null) {
      const currentQueue = current2.updateQueue;
      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;
      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          currentLastBaseUpdate.next = firstPendingUpdate;
        }
        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  }
  if (firstBaseUpdate !== null) {
    let newState = queue.baseState;
    let newLanes = NoLanes;
    let newBaseState = null;
    let newFirstBaseUpdate = null;
    let newLastBaseUpdate = null;
    let update = firstBaseUpdate;
    do {
      const updateLane = removeLanes(update.lane, OffscreenLane);
      const isHiddenUpdate = updateLane !== update.lane;
      const shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes2, updateLane);
      if (shouldSkipUpdate) {
        const clone = {
          lane: updateLane,
          tag: update.tag,
          payload: update.payload,
          callback: update.callback,
          next: null
        };
        if (newLastBaseUpdate === null) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        if (updateLane !== NoLane && updateLane === peekEntangledActionLane()) {
          didReadFromEntangledAsyncAction = true;
        }
        if (newLastBaseUpdate !== null) {
          const clone = {
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            tag: update.tag,
            payload: update.payload,
            // When this update is rebased, we should not fire its
            // callback again.
            callback: null,
            next: null
          };
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        newState = getStateFromUpdate(
          workInProgress2,
          queue,
          update,
          newState,
          props,
          instance
        );
        const callback = update.callback;
        if (callback !== null) {
          workInProgress2.flags |= Callback;
          if (isHiddenUpdate) {
            workInProgress2.flags |= Visibility;
          }
          const callbacks2 = queue.callbacks;
          if (callbacks2 === null) {
            queue.callbacks = [callback];
          } else {
            callbacks2.push(callback);
          }
        }
      }
      update = update.next;
      if (update === null) {
        pendingQueue = queue.shared.pending;
        if (pendingQueue === null) {
          break;
        } else {
          const lastPendingUpdate = pendingQueue;
          const firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          update = firstPendingUpdate;
          queue.lastBaseUpdate = lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);
    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }
    queue.baseState = newBaseState;
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate;
    if (firstBaseUpdate === null) {
      queue.shared.lanes = NoLanes;
    }
    markSkippedUpdateLanes(newLanes);
    workInProgress2.lanes = newLanes;
    workInProgress2.memoizedState = newState;
  }
  if (false) {
    currentlyProcessingQueue = null;
  }
}
function callCallback(callback, context) {
  if (typeof callback !== "function") {
    throw new Error(
      `Invalid argument passed as callback. Expected a function. Instead received: ${callback}`
    );
  }
  callback.call(context);
}
function resetHasForceUpdateBeforeProcessing() {
  hasForceUpdate = false;
}
function checkHasForceUpdateAfterProcessing() {
  return hasForceUpdate;
}
function deferHiddenCallbacks(updateQueue) {
  const newHiddenCallbacks = updateQueue.callbacks;
  if (newHiddenCallbacks !== null) {
    const existingHiddenCallbacks = updateQueue.shared.hiddenCallbacks;
    if (existingHiddenCallbacks === null) {
      updateQueue.shared.hiddenCallbacks = newHiddenCallbacks;
    } else {
      updateQueue.shared.hiddenCallbacks = existingHiddenCallbacks.concat(newHiddenCallbacks);
    }
  }
}
function commitHiddenCallbacks(updateQueue, context) {
  const hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
  if (hiddenCallbacks !== null) {
    updateQueue.shared.hiddenCallbacks = null;
    for (let i = 0; i < hiddenCallbacks.length; i++) {
      const callback = hiddenCallbacks[i];
      callCallback(callback, context);
    }
  }
}
function commitCallbacks(updateQueue, context) {
  const callbacks2 = updateQueue.callbacks;
  if (callbacks2 !== null) {
    updateQueue.callbacks = null;
    for (let i = 0; i < callbacks2.length; i++) {
      const callback = callbacks2[i];
      callCallback(callback, context);
    }
  }
}

// dist/react-reconciler/src/ReactFiberHiddenContext.js
var currentTreeHiddenStackCursor = createCursor(null);
var prevEntangledRenderLanesCursor = createCursor(NoLanes);
function pushHiddenContext(fiber, context) {
  const prevEntangledRenderLanes = getEntangledRenderLanes();
  push2(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
  push2(currentTreeHiddenStackCursor, context, fiber);
  setEntangledRenderLanes(
    mergeLanes(prevEntangledRenderLanes, context.baseLanes)
  );
}
function reuseHiddenContextOnStack(fiber) {
  push2(prevEntangledRenderLanesCursor, getEntangledRenderLanes(), fiber);
  push2(
    currentTreeHiddenStackCursor,
    currentTreeHiddenStackCursor.current,
    fiber
  );
}
function popHiddenContext(fiber) {
  setEntangledRenderLanes(prevEntangledRenderLanesCursor.current);
  pop2(currentTreeHiddenStackCursor, fiber);
  pop2(prevEntangledRenderLanesCursor, fiber);
}
function isCurrentTreeHidden() {
  return currentTreeHiddenStackCursor.current !== null;
}

// dist/react-reconciler/src/ReactFiberSuspenseContext.js
var suspenseHandlerStackCursor = createCursor(null);
var shellBoundary = null;
function getShellBoundary() {
  return shellBoundary;
}
function pushPrimaryTreeSuspenseHandler(handler) {
  const current2 = handler.alternate;
  const props = handler.pendingProps;
  pushSuspenseListContext(
    handler,
    setDefaultShallowSuspenseListContext(suspenseStackCursor.current)
  );
  if (enableSuspenseAvoidThisFallback && props.unstable_avoidThisFallback === true && // If an avoided boundary is already visible, it behaves identically to
  // a regular Suspense boundary.
  (current2 === null || isCurrentTreeHidden())) {
    if (shellBoundary === null) {
      push2(suspenseHandlerStackCursor, handler, handler);
    } else {
      const handlerOnStack = suspenseHandlerStackCursor.current;
      push2(suspenseHandlerStackCursor, handlerOnStack, handler);
    }
    return;
  }
  push2(suspenseHandlerStackCursor, handler, handler);
  if (shellBoundary === null) {
    if (current2 === null || isCurrentTreeHidden()) {
      shellBoundary = handler;
    } else {
      const prevState = current2.memoizedState;
      if (prevState !== null) {
        shellBoundary = handler;
      }
    }
  }
}
function pushFallbackTreeSuspenseHandler(fiber) {
  reuseSuspenseHandlerOnStack(fiber);
}
function pushDehydratedActivitySuspenseHandler(fiber) {
  pushSuspenseListContext(fiber, suspenseStackCursor.current);
  push2(suspenseHandlerStackCursor, fiber, fiber);
  if (shellBoundary === null) {
    shellBoundary = fiber;
  }
}
function pushOffscreenSuspenseHandler(fiber) {
  if (fiber.tag === OffscreenComponent) {
    pushSuspenseListContext(fiber, suspenseStackCursor.current);
    push2(suspenseHandlerStackCursor, fiber, fiber);
    if (shellBoundary === null) {
      shellBoundary = fiber;
    }
  } else {
    reuseSuspenseHandlerOnStack(fiber);
  }
}
function reuseSuspenseHandlerOnStack(fiber) {
  pushSuspenseListContext(fiber, suspenseStackCursor.current);
  push2(suspenseHandlerStackCursor, getSuspenseHandler(), fiber);
}
function getSuspenseHandler() {
  return suspenseHandlerStackCursor.current;
}
function popSuspenseHandler(fiber) {
  pop2(suspenseHandlerStackCursor, fiber);
  if (shellBoundary === fiber) {
    shellBoundary = null;
  }
  popSuspenseListContext(fiber);
}
var DefaultSuspenseContext = 0;
var SubtreeSuspenseContextMask = 1;
var ForceSuspenseFallback = 2;
var suspenseStackCursor = createCursor(
  DefaultSuspenseContext
);
function hasSuspenseListContext(parentContext, flag) {
  return (parentContext & flag) !== 0;
}
function setDefaultShallowSuspenseListContext(parentContext) {
  return parentContext & SubtreeSuspenseContextMask;
}
function setShallowSuspenseListContext(parentContext, shallowContext) {
  return parentContext & SubtreeSuspenseContextMask | shallowContext;
}
function pushSuspenseListContext(fiber, newContext) {
  push2(suspenseStackCursor, newContext, fiber);
}
function popSuspenseListContext(fiber) {
  pop2(suspenseStackCursor, fiber);
}

// dist/react-reconciler/src/ReactFiberSuspenseComponent.js
function findFirstSuspended(row) {
  let node = row;
  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      const state = node.memoizedState;
      if (state !== null) {
        const dehydrated = state.dehydrated;
        if (dehydrated === null || (void 0)(dehydrated) || (void 0)(dehydrated)) {
          return node;
        }
      }
    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
    // keep track of whether it suspended or not.
    node.memoizedProps.revealOrder !== void 0) {
      const didSuspend = (node.flags & DidCapture) !== NoFlags;
      if (didSuspend) {
        return node;
      }
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row) {
      return null;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === row) {
        return null;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}

// dist/react-reconciler/src/ReactHookEffectTags.js
var NoFlags2 = (
  /*   */
  0
);
var HasEffect = (
  /* */
  1
);
var Insertion = (
  /* */
  2
);
var Layout = (
  /*    */
  4
);
var Passive2 = (
  /*   */
  8
);

// dist/react-reconciler/src/ReactFiberHooks.js
if (false) {
  didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
  didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
  didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
  didWarnAboutUseFormState = /* @__PURE__ */ new Set();
}
var renderLanes = NoLanes;
var currentlyRenderingFiber2 = null;
var currentHook = null;
var workInProgressHook = null;
var didScheduleRenderPhaseUpdate = false;
var didScheduleRenderPhaseUpdateDuringThisPass = false;
var shouldDoubleInvokeUserFnsInHooksDEV = false;
var localIdCounter = 0;
var thenableIndexCounter2 = 0;
var thenableState2 = null;
var globalClientIdCounter2 = 0;
var RE_RENDER_LIMIT = 25;
function throwInvalidHookError() {
  throw new Error(
    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
  );
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (false) {
    if (ignorePreviousDependencies) {
      return false;
    }
  }
  if (prevDeps === null) {
    if (false) {
      console.error(
        "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
        currentHookNameInDev
      );
    }
    return false;
  }
  if (false) {
    if (nextDeps.length !== prevDeps.length) {
      console.error(
        "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
        currentHookNameInDev,
        `[${prevDeps.join(", ")}]`,
        `[${nextDeps.join(", ")}]`
      );
    }
  }
  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (objectIs_default(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }
  return true;
}
function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber2 = workInProgress2;
  if (false) {
    hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
    hookTypesUpdateIndexDev = -1;
    ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
    warnIfAsyncClientComponent(Component2);
  }
  workInProgress2.memoizedState = null;
  workInProgress2.updateQueue = null;
  workInProgress2.lanes = NoLanes;
  if (false) {
    if (current2 !== null && current2.memoizedState !== null) {
      ReactSharedInternals_default.H = HooksDispatcherOnUpdateInDEV;
    } else if (hookTypesDev !== null) {
      ReactSharedInternals_default.H = HooksDispatcherOnMountWithHookTypesInDEV;
    } else {
      ReactSharedInternals_default.H = HooksDispatcherOnMountInDEV;
    }
  } else {
    ReactSharedInternals_default.H = current2 === null || current2.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
  }
  const shouldDoubleRenderDEV = false;
  shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;
  let children = false ? callComponentInDEV(Component2, props, secondArg) : Component2(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = false;
  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    children = renderWithHooksAgain(
      workInProgress2,
      Component2,
      props,
      secondArg
    );
  }
  if (shouldDoubleRenderDEV) {
    setIsStrictModeForDevtools(true);
    try {
      children = renderWithHooksAgain(
        workInProgress2,
        Component2,
        props,
        secondArg
      );
    } finally {
      setIsStrictModeForDevtools(false);
    }
  }
  finishRenderingHooks(current2, workInProgress2, Component2);
  return children;
}
function finishRenderingHooks(current2, workInProgress2, Component2) {
  if (false) {
    workInProgress2._debugHookTypes = hookTypesDev;
    if (workInProgress2.dependencies === null) {
      if (thenableState2 !== null) {
        workInProgress2.dependencies = {
          lanes: NoLanes,
          firstContext: null,
          _debugThenableState: thenableState2
        };
      }
    } else {
      workInProgress2.dependencies._debugThenableState = thenableState2;
    }
  }
  ReactSharedInternals_default.H = ContextOnlyDispatcher;
  const didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
  renderLanes = NoLanes;
  currentlyRenderingFiber2 = null;
  currentHook = null;
  workInProgressHook = null;
  if (false) {
    currentHookNameInDev = null;
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
    if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
    // and creates false positives. To make this work in legacy mode, we'd
    // need to mark fibers that commit in an incomplete state, somehow. For
    // now I'll disable the warning that most of the bugs that would trigger
    // it are either exclusive to concurrent mode or exist in both.
    (disableLegacyMode || (current2.mode & ConcurrentMode) !== NoMode)) {
      console.error(
        "Internal React error: Expected static flag was missing. Please notify the React team."
      );
    }
  }
  didScheduleRenderPhaseUpdate = false;
  thenableIndexCounter2 = 0;
  thenableState2 = null;
  if (didRenderTooFewHooks) {
    throw new Error(
      "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
    );
  }
  if (current2 !== null) {
    if (!checkIfWorkInProgressReceivedUpdate()) {
      const currentDependencies = current2.dependencies;
      if (currentDependencies !== null && checkIfContextChanged(currentDependencies)) {
        markWorkInProgressReceivedUpdate();
      }
    }
  }
  if (false) {
    if (checkIfUseWrappedInTryCatch()) {
      const componentName = getComponentNameFromFiber(workInProgress2) || "Unknown";
      if (!didWarnAboutUseWrappedInTryCatch.has(componentName) && // This warning also fires if you suspend with `use` inside an
      // async component. Since we warn for that above, we'll silence this
      // second warning by checking here.
      !didWarnAboutAsyncClientComponent.has(componentName)) {
        didWarnAboutUseWrappedInTryCatch.add(componentName);
        console.error(
          "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
        );
      }
    }
  }
}
function replaySuspendedComponentWithHooks(current2, workInProgress2, Component2, props, secondArg) {
  if (false) {
    hookTypesUpdateIndexDev = -1;
    ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
  }
  workInProgress2.updateQueue = null;
  const children = renderWithHooksAgain(
    workInProgress2,
    Component2,
    props,
    secondArg
  );
  finishRenderingHooks(current2, workInProgress2, Component2);
  return children;
}
function renderWithHooksAgain(workInProgress2, Component2, props, secondArg) {
  currentlyRenderingFiber2 = workInProgress2;
  let numberOfReRenders = 0;
  let children;
  do {
    if (didScheduleRenderPhaseUpdateDuringThisPass) {
      thenableState2 = null;
    }
    thenableIndexCounter2 = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = false;
    if (numberOfReRenders >= RE_RENDER_LIMIT) {
      throw new Error(
        "Too many re-renders. React limits the number of renders to prevent an infinite loop."
      );
    }
    numberOfReRenders += 1;
    if (false) {
      ignorePreviousDependencies = false;
    }
    currentHook = null;
    workInProgressHook = null;
    if (workInProgress2.updateQueue != null) {
      resetFunctionComponentUpdateQueue(workInProgress2.updateQueue);
    }
    if (false) {
      hookTypesUpdateIndexDev = -1;
    }
    ReactSharedInternals_default.H = false ? HooksDispatcherOnRerenderInDEV : HooksDispatcherOnRerender;
    children = false ? callComponentInDEV(Component2, props, secondArg) : Component2(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function renderTransitionAwareHostComponentWithHooks(current2, workInProgress2, lanes) {
  return renderWithHooks(
    current2,
    workInProgress2,
    TransitionAwareHostComponent,
    null,
    null,
    lanes
  );
}
function TransitionAwareHostComponent() {
  const dispatcher = ReactSharedInternals_default.H;
  const [maybeThenable] = dispatcher.useState();
  let nextState;
  if (typeof maybeThenable.then === "function") {
    const thenable = maybeThenable;
    nextState = useThenable(thenable);
  } else {
    const status = maybeThenable;
    nextState = status;
  }
  const [nextResetState] = dispatcher.useState();
  const prevResetState = currentHook !== null ? currentHook.memoizedState : null;
  if (prevResetState !== nextResetState) {
    currentlyRenderingFiber2.flags |= FormReset;
  }
  return nextState;
}
function checkDidRenderIdHook() {
  const didRenderIdHook = localIdCounter !== 0;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current2, workInProgress2, lanes) {
  workInProgress2.updateQueue = current2.updateQueue;
  if (false) {
    workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
  } else {
    workInProgress2.flags &= ~(Passive | Update);
  }
  current2.lanes = removeLanes(current2.lanes, lanes);
}
function resetHooksAfterThrow() {
  currentlyRenderingFiber2 = null;
  ReactSharedInternals_default.H = ContextOnlyDispatcher;
}
function resetHooksOnUnwind(workInProgress2) {
  if (didScheduleRenderPhaseUpdate) {
    let hook = workInProgress2.memoizedState;
    while (hook !== null) {
      const queue = hook.queue;
      if (queue !== null) {
        queue.pending = null;
      }
      hook = hook.next;
    }
    didScheduleRenderPhaseUpdate = false;
  }
  renderLanes = NoLanes;
  currentlyRenderingFiber2 = null;
  currentHook = null;
  workInProgressHook = null;
  if (false) {
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
    currentHookNameInDev = null;
  }
  didScheduleRenderPhaseUpdateDuringThisPass = false;
  localIdCounter = 0;
  thenableIndexCounter2 = 0;
  thenableState2 = null;
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  if (workInProgressHook === null) {
    currentlyRenderingFiber2.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook === null) {
    const current2 = currentlyRenderingFiber2.alternate;
    if (current2 !== null) {
      nextCurrentHook = current2.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }
  let nextWorkInProgressHook;
  if (workInProgressHook === null) {
    nextWorkInProgressHook = currentlyRenderingFiber2.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }
  if (nextWorkInProgressHook !== null) {
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    if (nextCurrentHook === null) {
      const currentFiber = currentlyRenderingFiber2.alternate;
      if (currentFiber === null) {
        throw new Error(
          "Update hook called on initial render. This is likely a bug in React. Please file an issue."
        );
      } else {
        throw new Error("Rendered more hooks than during the previous render.");
      }
    }
    currentHook = nextCurrentHook;
    const newHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    if (workInProgressHook === null) {
      currentlyRenderingFiber2.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}
function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null,
    events: null,
    stores: null,
    memoCache: null
  };
}
function resetFunctionComponentUpdateQueue(updateQueue) {
  updateQueue.lastEffect = null;
  updateQueue.events = null;
  updateQueue.stores = null;
  if (updateQueue.memoCache != null) {
    updateQueue.memoCache.index = 0;
  }
}
function useThenable(thenable) {
  const index2 = thenableIndexCounter2;
  thenableIndexCounter2 += 1;
  if (thenableState2 === null) {
    thenableState2 = createThenableState();
  }
  const result = trackUsedThenable(thenableState2, thenable, index2);
  const workInProgressFiber = currentlyRenderingFiber2;
  const nextWorkInProgressHook = workInProgressHook === null ? (
    // We're at the beginning of the list, so read from the first hook from
    // the fiber.
    workInProgressFiber.memoizedState
  ) : workInProgressHook.next;
  if (nextWorkInProgressHook !== null) {
  } else {
    const currentFiber = workInProgressFiber.alternate;
    if (false) {
      if (currentFiber !== null && currentFiber.memoizedState !== null) {
        ReactSharedInternals_default.H = HooksDispatcherOnUpdateInDEV;
      } else {
        ReactSharedInternals_default.H = HooksDispatcherOnMountInDEV;
      }
    } else {
      ReactSharedInternals_default.H = currentFiber === null || currentFiber.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
    }
  }
  return result;
}
function use2(usable) {
  if (usable !== null && typeof usable === "object") {
    if (typeof usable.then === "function") {
      const thenable = usable;
      return useThenable(thenable);
    } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
      const context = usable;
      return readContext(context);
    }
  }
  throw new Error("An unsupported type was passed to use(): " + String(usable));
}
function useMemoCache2(size) {
  let memoCache = null;
  let updateQueue = currentlyRenderingFiber2.updateQueue;
  if (updateQueue !== null) {
    memoCache = updateQueue.memoCache;
  }
  if (memoCache == null) {
    const current2 = currentlyRenderingFiber2.alternate;
    if (current2 !== null) {
      const currentUpdateQueue = current2.updateQueue;
      if (currentUpdateQueue !== null) {
        const currentMemoCache = currentUpdateQueue.memoCache;
        if (currentMemoCache != null) {
          memoCache = {
            // When enableNoCloningMemoCache is enabled, instead of treating the
            // cache as copy-on-write, like we do with fibers, we share the same
            // cache instance across all render attempts, even if the component
            // is interrupted before it commits.
            //
            // If an update is interrupted, either because it suspended or
            // because of another update, we can reuse the memoized computations
            // from the previous attempt. We can do this because the React
            // Compiler performs atomic writes to the memo cache, i.e. it will
            // not record the inputs to a memoization without also recording its
            // output.
            //
            // This gives us a form of "resuming" within components and hooks.
            //
            // This only works when updating a component that already mounted.
            // It has no impact during initial render, because the memo cache is
            // stored on the fiber, and since we have not implemented resuming
            // for fibers, it's always a fresh memo cache, anyway.
            //
            // However, this alone is pretty useful — it happens whenever you
            // update the UI with fresh data after a mutation/action, which is
            // extremely common in a Suspense-driven (e.g. RSC or Relay) app.
            data: enableNoCloningMemoCache ? currentMemoCache.data : (
              // Clone the memo cache before each render (copy-on-write)
              currentMemoCache.data.map((array) => array.slice())
            ),
            index: 0
          };
        }
      }
    }
  }
  if (memoCache == null) {
    memoCache = {
      data: [],
      index: 0
    };
  }
  if (updateQueue === null) {
    updateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber2.updateQueue = updateQueue;
  }
  updateQueue.memoCache = memoCache;
  let data = memoCache.data[memoCache.index];
  if (data === void 0 || false) {
    data = memoCache.data[memoCache.index] = new Array(size);
    for (let i = 0; i < size; i++) {
      data[i] = REACT_MEMO_CACHE_SENTINEL;
    }
  } else if (data.length !== size) {
    if (false) {
      console.error(
        "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
        data.length,
        size
      );
    }
  }
  memoCache.index++;
  return data;
}
function basicStateReducer(state, action) {
  return typeof action === "function" ? action(state) : action;
}
function mountReducer(reducer, initialArg, init) {
  const hook = mountWorkInProgressHook();
  let initialState;
  if (init !== void 0) {
    initialState = init(initialArg);
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        init(initialArg);
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
  } else {
    initialState = initialArg;
  }
  hook.memoizedState = hook.baseState = initialState;
  const queue = {
    pending: null,
    lanes: NoLanes,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: initialState
  };
  hook.queue = queue;
  const dispatch = queue.dispatch = dispatchReducerAction.bind(
    null,
    currentlyRenderingFiber2,
    queue
  );
  return [hook.memoizedState, dispatch];
}
function updateReducer(reducer, initialArg, init) {
  const hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current2, reducer) {
  const queue = hook.queue;
  if (queue === null) {
    throw new Error(
      "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
    );
  }
  queue.lastRenderedReducer = reducer;
  let baseQueue = hook.baseQueue;
  const pendingQueue = queue.pending;
  if (pendingQueue !== null) {
    if (baseQueue !== null) {
      const baseFirst = baseQueue.next;
      const pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }
    if (false) {
      if (current2.baseQueue !== baseQueue) {
        console.error(
          "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
        );
      }
    }
    current2.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  const baseState = hook.baseState;
  if (baseQueue === null) {
    hook.memoizedState = baseState;
  } else {
    const first = baseQueue.next;
    let newState = baseState;
    let newBaseState = null;
    let newBaseQueueFirst = null;
    let newBaseQueueLast = null;
    let update = first;
    let didReadFromEntangledAsyncAction2 = false;
    do {
      const updateLane = removeLanes(update.lane, OffscreenLane);
      const isHiddenUpdate = updateLane !== update.lane;
      let shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);
      if (enableGestureTransition && updateLane === GestureLane) {
        const scheduledGesture = update.gesture;
        if (scheduledGesture !== null) {
          if (scheduledGesture.count === 0) {
            update = update.next;
            continue;
          } else if (!isGestureRender(renderLanes)) {
            shouldSkipUpdate = true;
          } else {
            const root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            }
            shouldSkipUpdate = root2.pendingGestures !== scheduledGesture;
          }
        }
      }
      if (shouldSkipUpdate) {
        const clone = {
          lane: updateLane,
          revertLane: update.revertLane,
          gesture: update.gesture,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        };
        if (newBaseQueueLast === null) {
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
        currentlyRenderingFiber2.lanes = mergeLanes(
          currentlyRenderingFiber2.lanes,
          updateLane
        );
        markSkippedUpdateLanes(updateLane);
      } else {
        const revertLane = update.revertLane;
        if (revertLane === NoLane) {
          if (newBaseQueueLast !== null) {
            const clone = {
              // This update is going to be committed so we never want uncommit
              // it. Using NoLane works because 0 is a subset of all bitmasks, so
              // this will never be skipped by the check above.
              lane: NoLane,
              revertLane: NoLane,
              gesture: null,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            };
            newBaseQueueLast = newBaseQueueLast.next = clone;
          }
          if (updateLane === peekEntangledActionLane()) {
            didReadFromEntangledAsyncAction2 = true;
          }
        } else {
          if (isSubsetOfLanes(renderLanes, revertLane)) {
            update = update.next;
            if (revertLane === peekEntangledActionLane()) {
              didReadFromEntangledAsyncAction2 = true;
            }
            continue;
          } else {
            const clone = {
              // Once we commit an optimistic update, we shouldn't uncommit it
              // until the transition it is associated with has finished
              // (represented by revertLane). Using NoLane here works because 0
              // is a subset of all bitmasks, so this will never be skipped by
              // the check above.
              lane: NoLane,
              // Reuse the same revertLane so we know when the transition
              // has finished.
              revertLane: update.revertLane,
              gesture: null,
              // If it commits, it's no longer a gesture update.
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            };
            if (newBaseQueueLast === null) {
              newBaseQueueFirst = newBaseQueueLast = clone;
              newBaseState = newState;
            } else {
              newBaseQueueLast = newBaseQueueLast.next = clone;
            }
            currentlyRenderingFiber2.lanes = mergeLanes(
              currentlyRenderingFiber2.lanes,
              revertLane
            );
            markSkippedUpdateLanes(revertLane);
          }
        }
        const action = update.action;
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          reducer(newState, action);
        }
        if (update.hasEagerState) {
          newState = update.eagerState;
        } else {
          newState = reducer(newState, action);
        }
      }
      update = update.next;
    } while (update !== null && update !== first);
    if (newBaseQueueLast === null) {
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    }
    if (!objectIs_default(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
      if (didReadFromEntangledAsyncAction2) {
        const entangledActionThenable = peekEntangledActionThenable();
        if (entangledActionThenable !== null) {
          throw entangledActionThenable;
        }
      }
    }
    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = newState;
  }
  if (baseQueue === null) {
    queue.lanes = NoLanes;
  }
  const dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}
function rerenderReducer(reducer, initialArg, init) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  if (queue === null) {
    throw new Error(
      "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
    );
  }
  queue.lastRenderedReducer = reducer;
  const dispatch = queue.dispatch;
  const lastRenderPhaseUpdate = queue.pending;
  let newState = hook.memoizedState;
  if (lastRenderPhaseUpdate !== null) {
    queue.pending = null;
    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
    let update = firstRenderPhaseUpdate;
    do {
      const action = update.action;
      newState = reducer(newState, action);
      update = update.next;
    } while (update !== firstRenderPhaseUpdate);
    if (!objectIs_default(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }
    hook.memoizedState = newState;
    if (hook.baseQueue === null) {
      hook.baseState = newState;
    }
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  const fiber = currentlyRenderingFiber2;
  const hook = mountWorkInProgressHook();
  let nextSnapshot;
  const isHydrating2 = getIsHydrating();
  if (isHydrating2) {
    if (getServerSnapshot === void 0) {
      throw new Error(
        "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
      );
    }
    nextSnapshot = getServerSnapshot();
    if (false) {
      if (!didWarnUncachedGetSnapshot) {
        if (nextSnapshot !== getServerSnapshot()) {
          console.error(
            "The result of getServerSnapshot should be cached to avoid an infinite loop"
          );
          didWarnUncachedGetSnapshot = true;
        }
      }
    }
  } else {
    nextSnapshot = getSnapshot();
    if (false) {
      if (!didWarnUncachedGetSnapshot) {
        const cachedSnapshot = getSnapshot();
        if (!objectIs_default(nextSnapshot, cachedSnapshot)) {
          console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          );
          didWarnUncachedGetSnapshot = true;
        }
      }
    }
    const root2 = getWorkInProgressRoot();
    if (root2 === null) {
      throw new Error(
        "Expected a work-in-progress root. This is a bug in React. Please file an issue."
      );
    }
    const rootRenderLanes = getWorkInProgressRootRenderLanes();
    if (!includesBlockingLane(rootRenderLanes)) {
      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
    }
  }
  hook.memoizedState = nextSnapshot;
  const inst = {
    value: nextSnapshot,
    getSnapshot
  };
  hook.queue = inst;
  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
  fiber.flags |= Passive;
  pushSimpleEffect(
    HasEffect | Passive2,
    createEffectInstance(),
    updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),
    null
  );
  return nextSnapshot;
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  const fiber = currentlyRenderingFiber2;
  const hook = updateWorkInProgressHook();
  let nextSnapshot;
  const isHydrating2 = getIsHydrating();
  if (isHydrating2) {
    if (getServerSnapshot === void 0) {
      throw new Error(
        "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
      );
    }
    nextSnapshot = getServerSnapshot();
  } else {
    nextSnapshot = getSnapshot();
    if (false) {
      if (!didWarnUncachedGetSnapshot) {
        const cachedSnapshot = getSnapshot();
        if (!objectIs_default(nextSnapshot, cachedSnapshot)) {
          console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          );
          didWarnUncachedGetSnapshot = true;
        }
      }
    }
  }
  const prevSnapshot = (currentHook || hook).memoizedState;
  const snapshotChanged = !objectIs_default(prevSnapshot, nextSnapshot);
  if (snapshotChanged) {
    hook.memoizedState = nextSnapshot;
    markWorkInProgressReceivedUpdate();
  }
  const inst = hook.queue;
  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
    subscribe
  ]);
  if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the subscribe function changed. We can save some memory by
  // checking whether we scheduled a subscription effect above.
  workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
    fiber.flags |= Passive;
    pushSimpleEffect(
      HasEffect | Passive2,
      createEffectInstance(),
      updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),
      null
    );
    const root2 = getWorkInProgressRoot();
    if (root2 === null) {
      throw new Error(
        "Expected a work-in-progress root. This is a bug in React. Please file an issue."
      );
    }
    if (!isHydrating2 && !includesBlockingLane(renderLanes)) {
      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
    }
  }
  return nextSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= StoreConsistency;
  const check = {
    getSnapshot,
    value: renderedSnapshot
  };
  let componentUpdateQueue = currentlyRenderingFiber2.updateQueue;
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber2.updateQueue = componentUpdateQueue;
    componentUpdateQueue.stores = [check];
  } else {
    const stores = componentUpdateQueue.stores;
    if (stores === null) {
      componentUpdateQueue.stores = [check];
    } else {
      stores.push(check);
    }
  }
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  if (checkIfSnapshotChanged(inst)) {
    forceStoreRerender(fiber);
  }
}
function subscribeToStore(fiber, inst, subscribe) {
  const handleStoreChange = () => {
    if (checkIfSnapshotChanged(inst)) {
      startUpdateTimerByLane(SyncLane, "updateSyncExternalStore()");
      forceStoreRerender(fiber);
    }
  };
  return subscribe(handleStoreChange);
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !objectIs_default(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}
function forceStoreRerender(fiber) {
  const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
  if (root2 !== null) {
    scheduleUpdateOnFiber(root2, fiber, SyncLane);
  }
}
function mountStateImpl(initialState) {
  const hook = mountWorkInProgressHook();
  if (typeof initialState === "function") {
    const initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  const queue = {
    pending: null,
    lanes: NoLanes,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  hook.queue = queue;
  return hook;
}
function mountState(initialState) {
  const hook = mountStateImpl(initialState);
  const queue = hook.queue;
  const dispatch = dispatchSetState.bind(
    null,
    currentlyRenderingFiber2,
    queue
  );
  queue.dispatch = dispatch;
  return [hook.memoizedState, dispatch];
}
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}
function rerenderState(initialState) {
  return rerenderReducer(basicStateReducer, initialState);
}
function mountOptimistic(passthrough, reducer) {
  const hook = mountWorkInProgressHook();
  hook.memoizedState = hook.baseState = passthrough;
  const queue = {
    pending: null,
    lanes: NoLanes,
    dispatch: null,
    // Optimistic state does not use the eager update optimization.
    lastRenderedReducer: null,
    lastRenderedState: null
  };
  hook.queue = queue;
  const dispatch = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber2,
    true,
    queue
  );
  queue.dispatch = dispatch;
  return [passthrough, dispatch];
}
function updateOptimistic(passthrough, reducer) {
  const hook = updateWorkInProgressHook();
  return updateOptimisticImpl(
    hook,
    currentHook,
    passthrough,
    reducer
  );
}
function updateOptimisticImpl(hook, current2, passthrough, reducer) {
  hook.baseState = passthrough;
  const resolvedReducer = typeof reducer === "function" ? reducer : basicStateReducer;
  return updateReducerImpl(hook, currentHook, resolvedReducer);
}
function rerenderOptimistic(passthrough, reducer) {
  const hook = updateWorkInProgressHook();
  if (currentHook !== null) {
    return updateOptimisticImpl(
      hook,
      currentHook,
      passthrough,
      reducer
    );
  }
  hook.baseState = passthrough;
  const dispatch = hook.queue.dispatch;
  return [passthrough, dispatch];
}
function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
  if (isRenderPhaseUpdate(fiber)) {
    throw new Error("Cannot update form state while rendering.");
  }
  const currentAction = actionQueue.action;
  if (currentAction === null) {
    return;
  }
  const actionNode = {
    payload,
    action: currentAction,
    next: null,
    // circular
    isTransition: true,
    status: "pending",
    value: null,
    reason: null,
    listeners: [],
    then(listener) {
      actionNode.listeners.push(listener);
    }
  };
  const prevTransition = ReactSharedInternals_default.T;
  if (prevTransition !== null) {
    setPendingState(true);
    setState(actionNode);
  } else {
    actionNode.isTransition = false;
    setState(actionNode);
  }
  const last = actionQueue.pending;
  if (last === null) {
    actionNode.next = actionQueue.pending = actionNode;
    runActionStateAction(actionQueue, actionNode);
  } else {
    const first = last.next;
    actionNode.next = first;
    actionQueue.pending = last.next = actionNode;
  }
}
function runActionStateAction(actionQueue, node) {
  const action = node.action;
  const payload = node.payload;
  const prevState = actionQueue.state;
  if (node.isTransition) {
    const prevTransition = ReactSharedInternals_default.T;
    const currentTransition = {};
    if (enableViewTransition) {
      currentTransition.types = prevTransition !== null ? (
        // If we're a nested transition, we should use the same set as the parent
        // since we're conceptually always joined into the same entangled transition.
        // In practice, this only matters if we add transition types in the inner
        // without setting state. In that case, the inner transition can finish
        // without waiting for the outer.
        prevTransition.types
      ) : null;
    }
    if (enableGestureTransition) {
      currentTransition.gesture = null;
    }
    if (enableTransitionTracing) {
      currentTransition.name = null;
      currentTransition.startTime = -1;
    }
    if (false) {
      currentTransition._updatedFibers = /* @__PURE__ */ new Set();
    }
    ReactSharedInternals_default.T = currentTransition;
    try {
      const returnValue = action(prevState, payload);
      const onStartTransitionFinish = ReactSharedInternals_default.S;
      if (onStartTransitionFinish !== null) {
        onStartTransitionFinish(currentTransition, returnValue);
      }
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      if (prevTransition !== null && currentTransition.types !== null) {
        if (false) {
          if (prevTransition.types !== null && prevTransition.types !== currentTransition.types) {
            console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            );
          }
        }
        prevTransition.types = currentTransition.types;
      }
      ReactSharedInternals_default.T = prevTransition;
      if (false) {
        if (prevTransition === null && currentTransition._updatedFibers) {
          const updatedFibersCount = currentTransition._updatedFibers.size;
          currentTransition._updatedFibers.clear();
          if (updatedFibersCount > 10) {
            console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            );
          }
        }
      }
    }
  } else {
    try {
      const returnValue = action(prevState, payload);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    }
  }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  if (returnValue !== null && typeof returnValue === "object" && // $FlowFixMe[method-unbinding]
  typeof returnValue.then === "function") {
    const thenable = returnValue;
    if (false) {
      ReactSharedInternals_default.asyncTransitions++;
      thenable.then(releaseAsyncTransition, releaseAsyncTransition);
    }
    thenable.then(
      (nextState) => {
        onActionSuccess(actionQueue, node, nextState);
      },
      (error) => onActionError(actionQueue, node, error)
    );
    if (false) {
      if (!node.isTransition) {
        console.error(
          "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
        );
      }
    }
  } else {
    const nextState = returnValue;
    onActionSuccess(actionQueue, node, nextState);
  }
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  const last = actionQueue.pending;
  if (last !== null) {
    const first = last.next;
    if (first === last) {
      actionQueue.pending = null;
    } else {
      const next = first.next;
      last.next = next;
      runActionStateAction(actionQueue, next);
    }
  }
}
function onActionError(actionQueue, actionNode, error) {
  const last = actionQueue.pending;
  actionQueue.pending = null;
  if (last !== null) {
    const first = last.next;
    do {
      actionNode.status = "rejected";
      actionNode.reason = error;
      notifyActionListeners(actionNode);
      actionNode = actionNode.next;
    } while (actionNode !== first);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  const listeners = actionNode.listeners;
  for (let i = 0; i < listeners.length; i++) {
    const listener = listeners[i];
    listener();
  }
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp, permalink) {
  let initialState = initialStateProp;
  if (getIsHydrating()) {
    const root2 = getWorkInProgressRoot();
    const ssrFormState = root2.formState;
    if (ssrFormState !== null) {
      const isMatching = tryToClaimNextHydratableFormMarkerInstance(
        currentlyRenderingFiber2
      );
      if (isMatching) {
        initialState = ssrFormState[0];
      }
    }
  }
  const stateHook = mountWorkInProgressHook();
  stateHook.memoizedState = stateHook.baseState = initialState;
  const stateQueue = {
    pending: null,
    lanes: NoLanes,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialState
  };
  stateHook.queue = stateQueue;
  const setState = dispatchSetState.bind(
    null,
    currentlyRenderingFiber2,
    stateQueue
  );
  stateQueue.dispatch = setState;
  const pendingStateHook = mountStateImpl(false);
  const setPendingState = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber2,
    false,
    pendingStateHook.queue
  );
  const actionQueueHook = mountWorkInProgressHook();
  const actionQueue = {
    state: initialState,
    dispatch: null,
    // circular
    action,
    pending: null
  };
  actionQueueHook.queue = actionQueue;
  const dispatch = dispatchActionState.bind(
    null,
    currentlyRenderingFiber2,
    actionQueue,
    setPendingState,
    setState
  );
  actionQueue.dispatch = dispatch;
  actionQueueHook.memoizedState = action;
  return [initialState, dispatch, false];
}
function updateActionState(action, initialState, permalink) {
  const stateHook = updateWorkInProgressHook();
  const currentStateHook = currentHook;
  return updateActionStateImpl(
    stateHook,
    currentStateHook,
    action,
    initialState,
    permalink
  );
}
function updateActionStateImpl(stateHook, currentStateHook, action, initialState, permalink) {
  const [actionResult] = updateReducerImpl(
    stateHook,
    currentStateHook,
    actionStateReducer
  );
  const [isPending] = updateState(false);
  let state;
  if (typeof actionResult === "object" && actionResult !== null && // $FlowFixMe[method-unbinding]
  typeof actionResult.then === "function") {
    try {
      state = useThenable(actionResult);
    } catch (x) {
      if (x === SuspenseException) {
        throw SuspenseActionException;
      } else {
        throw x;
      }
    }
  } else {
    state = actionResult;
  }
  const actionQueueHook = updateWorkInProgressHook();
  const actionQueue = actionQueueHook.queue;
  const dispatch = actionQueue.dispatch;
  const prevAction = actionQueueHook.memoizedState;
  if (action !== prevAction) {
    currentlyRenderingFiber2.flags |= Passive;
    pushSimpleEffect(
      HasEffect | Passive2,
      createEffectInstance(),
      actionStateActionEffect.bind(null, actionQueue, action),
      null
    );
  }
  return [state, dispatch, isPending];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action, initialState, permalink) {
  const stateHook = updateWorkInProgressHook();
  const currentStateHook = currentHook;
  if (currentStateHook !== null) {
    return updateActionStateImpl(
      stateHook,
      currentStateHook,
      action,
      initialState,
      permalink
    );
  }
  updateWorkInProgressHook();
  const state = stateHook.memoizedState;
  const actionQueueHook = updateWorkInProgressHook();
  const actionQueue = actionQueueHook.queue;
  const dispatch = actionQueue.dispatch;
  actionQueueHook.memoizedState = action;
  return [state, dispatch, false];
}
function pushSimpleEffect(tag, inst, create, deps) {
  const effect = {
    tag,
    create,
    deps,
    inst,
    // Circular
    next: null
  };
  return pushEffectImpl(effect);
}
function pushEffectImpl(effect) {
  let componentUpdateQueue = currentlyRenderingFiber2.updateQueue;
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber2.updateQueue = componentUpdateQueue;
  }
  const lastEffect = componentUpdateQueue.lastEffect;
  if (lastEffect === null) {
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const firstEffect = lastEffect.next;
    lastEffect.next = effect;
    effect.next = firstEffect;
    componentUpdateQueue.lastEffect = effect;
  }
  return effect;
}
function createEffectInstance() {
  return { destroy: void 0 };
}
function mountRef(initialValue) {
  const hook = mountWorkInProgressHook();
  const ref = { current: initialValue };
  hook.memoizedState = ref;
  return ref;
}
function updateRef(initialValue) {
  const hook = updateWorkInProgressHook();
  return hook.memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === void 0 ? null : deps;
  currentlyRenderingFiber2.flags |= fiberFlags;
  hook.memoizedState = pushSimpleEffect(
    HasEffect | hookFlags,
    createEffectInstance(),
    create,
    nextDeps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === void 0 ? null : deps;
  const effect = hook.memoizedState;
  const inst = effect.inst;
  if (currentHook !== null) {
    if (nextDeps !== null) {
      const prevEffect = currentHook.memoizedState;
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushSimpleEffect(
          hookFlags,
          inst,
          create,
          nextDeps
        );
        return;
      }
    }
  }
  currentlyRenderingFiber2.flags |= fiberFlags;
  hook.memoizedState = pushSimpleEffect(
    HasEffect | hookFlags,
    inst,
    create,
    nextDeps
  );
}
function mountEffect(create, deps) {
  if (false) {
    mountEffectImpl(
      MountPassiveDev | Passive | PassiveStatic,
      Passive2,
      create,
      deps
    );
  } else {
    mountEffectImpl(
      Passive | PassiveStatic,
      Passive2,
      create,
      deps
    );
  }
}
function updateEffect(create, deps) {
  updateEffectImpl(Passive, Passive2, create, deps);
}
function useEffectEventImpl(payload) {
  currentlyRenderingFiber2.flags |= Update;
  let componentUpdateQueue = currentlyRenderingFiber2.updateQueue;
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber2.updateQueue = componentUpdateQueue;
    componentUpdateQueue.events = [payload];
  } else {
    const events = componentUpdateQueue.events;
    if (events === null) {
      componentUpdateQueue.events = [payload];
    } else {
      events.push(payload);
    }
  }
}
function mountEvent(callback) {
  const hook = mountWorkInProgressHook();
  const ref = { impl: callback };
  hook.memoizedState = ref;
  return function eventFn() {
    if (isInvalidExecutionContextForEventFunction()) {
      throw new Error(
        "A function wrapped in useEffectEvent can't be called during rendering."
      );
    }
    return ref.impl.apply(void 0, arguments);
  };
}
function updateEvent(callback) {
  const hook = updateWorkInProgressHook();
  const ref = hook.memoizedState;
  useEffectEventImpl({ ref, nextImpl: callback });
  return function eventFn() {
    if (isInvalidExecutionContextForEventFunction()) {
      throw new Error(
        "A function wrapped in useEffectEvent can't be called during rendering."
      );
    }
    return ref.impl.apply(void 0, arguments);
  };
}
function mountInsertionEffect(create, deps) {
  mountEffectImpl(Update, Insertion, create, deps);
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(Update, Insertion, create, deps);
}
function mountLayoutEffect(create, deps) {
  let fiberFlags = Update | LayoutStatic;
  if (false) {
    fiberFlags |= MountLayoutDev;
  }
  return mountEffectImpl(fiberFlags, Layout, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(Update, Layout, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if (typeof ref === "function") {
    const refCallback = ref;
    const inst = create();
    const refCleanup = refCallback(inst);
    return () => {
      if (typeof refCleanup === "function") {
        refCleanup();
      } else {
        refCallback(null);
      }
    };
  } else if (ref !== null && ref !== void 0) {
    const refObject = ref;
    if (false) {
      if (!refObject.hasOwnProperty("current")) {
        console.error(
          "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
          "an object with keys {" + Object.keys(refObject).join(", ") + "}"
        );
      }
    }
    const inst = create();
    refObject.current = inst;
    return () => {
      refObject.current = null;
    };
  }
}
function mountImperativeHandle(ref, create, deps) {
  if (false) {
    if (typeof create !== "function") {
      console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        create !== null ? typeof create : "null"
      );
    }
  }
  const effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
  let fiberFlags = Update | LayoutStatic;
  if (false) {
    fiberFlags |= MountLayoutDev;
  }
  mountEffectImpl(
    fiberFlags,
    Layout,
    imperativeHandleEffect.bind(null, create, ref),
    effectDeps
  );
}
function updateImperativeHandle(ref, create, deps) {
  if (false) {
    if (typeof create !== "function") {
      console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        create !== null ? typeof create : "null"
      );
    }
  }
  const effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
  updateEffectImpl(
    Update,
    Layout,
    imperativeHandleEffect.bind(null, create, ref),
    effectDeps
  );
}
function mountDebugValue(value, formatterFn) {
}
var updateDebugValue = mountDebugValue;
function mountCallback(callback, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === void 0 ? null : deps;
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
function updateCallback(callback, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === void 0 ? null : deps;
  const prevState = hook.memoizedState;
  if (nextDeps !== null) {
    const prevDeps = prevState[1];
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return prevState[0];
    }
  }
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
function mountMemo(nextCreate, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === void 0 ? null : deps;
  const nextValue = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(true);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(false);
    }
  }
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}
function updateMemo(nextCreate, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === void 0 ? null : deps;
  const prevState = hook.memoizedState;
  if (nextDeps !== null) {
    const prevDeps = prevState[1];
    if (areHookInputsEqual(nextDeps, prevDeps)) {
      return prevState[0];
    }
  }
  const nextValue = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(true);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(false);
    }
  }
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}
function mountDeferredValue(value, initialValue) {
  const hook = mountWorkInProgressHook();
  return mountDeferredValueImpl(hook, value, initialValue);
}
function updateDeferredValue(value, initialValue) {
  const hook = updateWorkInProgressHook();
  const resolvedCurrentHook = currentHook;
  const prevValue = resolvedCurrentHook.memoizedState;
  return updateDeferredValueImpl(hook, prevValue, value, initialValue);
}
function rerenderDeferredValue(value, initialValue) {
  const hook = updateWorkInProgressHook();
  if (currentHook === null) {
    return mountDeferredValueImpl(hook, value, initialValue);
  } else {
    const prevValue = currentHook.memoizedState;
    return updateDeferredValueImpl(hook, prevValue, value, initialValue);
  }
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (
    // When `initialValue` is provided, we defer the initial render even if the
    // current render is not synchronous.
    initialValue !== void 0 && // However, to avoid waterfalls, we do not defer if this render
    // was itself spawned by an earlier useDeferredValue. Check if DeferredLane
    // is part of the render lanes.
    !includesSomeLane(renderLanes, DeferredLane)
  ) {
    hook.memoizedState = initialValue;
    const deferredLane = requestDeferredLane();
    currentlyRenderingFiber2.lanes = mergeLanes(
      currentlyRenderingFiber2.lanes,
      deferredLane
    );
    markSkippedUpdateLanes(deferredLane);
    return initialValue;
  } else {
    hook.memoizedState = value;
    return value;
  }
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs_default(value, prevValue)) {
    return value;
  } else {
    if (isCurrentTreeHidden()) {
      const resultValue = mountDeferredValueImpl(hook, value, initialValue);
      if (!objectIs_default(resultValue, prevValue)) {
        markWorkInProgressReceivedUpdate();
      }
      return resultValue;
    }
    const shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes) && !includesSomeLane(renderLanes, DeferredLane);
    if (shouldDeferValue) {
      const deferredLane = requestDeferredLane();
      currentlyRenderingFiber2.lanes = mergeLanes(
        currentlyRenderingFiber2.lanes,
        deferredLane
      );
      markSkippedUpdateLanes(deferredLane);
      return prevValue;
    } else {
      markWorkInProgressReceivedUpdate();
      hook.memoizedState = value;
      return value;
    }
  }
}
function startTransition2(fiber, queue, pendingState, finishedState, callback, options) {
  const previousPriority = (void 0)();
  (void 0)(
    higherEventPriority(previousPriority, ContinuousEventPriority)
  );
  const prevTransition = ReactSharedInternals_default.T;
  const currentTransition = {};
  if (enableViewTransition) {
    currentTransition.types = prevTransition !== null ? (
      // If we're a nested transition, we should use the same set as the parent
      // since we're conceptually always joined into the same entangled transition.
      // In practice, this only matters if we add transition types in the inner
      // without setting state. In that case, the inner transition can finish
      // without waiting for the outer.
      prevTransition.types
    ) : null;
  }
  if (enableGestureTransition) {
    currentTransition.gesture = null;
  }
  if (enableTransitionTracing) {
    currentTransition.name = options !== void 0 && options.name !== void 0 ? options.name : null;
    currentTransition.startTime = now();
  }
  if (false) {
    currentTransition._updatedFibers = /* @__PURE__ */ new Set();
  }
  ReactSharedInternals_default.T = currentTransition;
  dispatchOptimisticSetState(fiber, false, queue, pendingState);
  try {
    const returnValue = callback();
    const onStartTransitionFinish = ReactSharedInternals_default.S;
    if (onStartTransitionFinish !== null) {
      onStartTransitionFinish(currentTransition, returnValue);
    }
    if (returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function") {
      const thenable = returnValue;
      if (false) {
        ReactSharedInternals_default.asyncTransitions++;
        thenable.then(releaseAsyncTransition, releaseAsyncTransition);
      }
      const thenableForFinishedState = chainThenableValue(
        thenable,
        finishedState
      );
      dispatchSetStateInternal(
        fiber,
        queue,
        thenableForFinishedState,
        requestUpdateLane(fiber)
      );
    } else {
      dispatchSetStateInternal(
        fiber,
        queue,
        finishedState,
        requestUpdateLane(fiber)
      );
    }
  } catch (error) {
    const rejectedThenable = {
      then() {
      },
      status: "rejected",
      reason: error
    };
    dispatchSetStateInternal(
      fiber,
      queue,
      rejectedThenable,
      requestUpdateLane(fiber)
    );
  } finally {
    (void 0)(previousPriority);
    if (prevTransition !== null && currentTransition.types !== null) {
      if (false) {
        if (prevTransition.types !== null && prevTransition.types !== currentTransition.types) {
          console.error(
            "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
          );
        }
      }
      prevTransition.types = currentTransition.types;
    }
    ReactSharedInternals_default.T = prevTransition;
    if (false) {
      if (prevTransition === null && currentTransition._updatedFibers) {
        const updatedFibersCount = currentTransition._updatedFibers.size;
        currentTransition._updatedFibers.clear();
        if (updatedFibersCount > 10) {
          console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          );
        }
      }
    }
  }
}
var noop2 = () => {
};
function startHostTransition(formFiber, pendingState, action, formData) {
  if (formFiber.tag !== HostComponent) {
    throw new Error(
      "Expected the form instance to be a HostComponent. This is a bug in React."
    );
  }
  const stateHook = ensureFormComponentIsStateful(formFiber);
  const queue = stateHook.queue;
  startTransition2(
    formFiber,
    queue,
    pendingState,
    void 0,
    // TODO: `startTransition` both sets the pending state and dispatches
    // the action, if one is provided. Consider refactoring these two
    // concerns to avoid the extra lambda.
    action === null ? (
      // No action was provided, but we still call `startTransition` to
      // set the pending form status.
      noop2
    ) : () => {
      requestFormReset(formFiber);
      return action(formData);
    }
  );
}
function ensureFormComponentIsStateful(formFiber) {
  const existingStateHook = formFiber.memoizedState;
  if (existingStateHook !== null) {
    return existingStateHook;
  }
  const newQueue = {
    pending: null,
    lanes: NoLanes,
    // We're going to cheat and intentionally not create a bound dispatch
    // method, because we can call it directly in startTransition.
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: void 0
  };
  const stateHook = {
    memoizedState: void 0,
    baseState: void 0,
    baseQueue: null,
    queue: newQueue,
    next: null
  };
  const initialResetState = {};
  const newResetStateQueue = {
    pending: null,
    lanes: NoLanes,
    // We're going to cheat and intentionally not create a bound dispatch
    // method, because we can call it directly in startTransition.
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialResetState
  };
  const resetStateHook = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: newResetStateQueue,
    next: null
  };
  stateHook.next = resetStateHook;
  formFiber.memoizedState = stateHook;
  const alternate = formFiber.alternate;
  if (alternate !== null) {
    alternate.memoizedState = stateHook;
  }
  return stateHook;
}
function requestFormReset(formFiber) {
  const transition = requestCurrentTransition();
  if (transition === null) {
    if (false) {
      console.error(
        "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
      );
    }
  } else if (enableGestureTransition && transition.gesture) {
    throw new Error(
      "Cannot requestFormReset() inside a startGestureTransition. There should be no side-effects associated with starting a Gesture until its Action is invoked. Move side-effects to the Action instead."
    );
  }
  let stateHook = ensureFormComponentIsStateful(formFiber);
  const newResetState = {};
  if (stateHook.next === null) {
    stateHook = formFiber.alternate.memoizedState;
  }
  const resetStateHook = stateHook.next;
  const resetStateQueue = resetStateHook.queue;
  dispatchSetStateInternal(
    formFiber,
    resetStateQueue,
    newResetState,
    requestUpdateLane(formFiber)
  );
}
function mountTransition() {
  const stateHook = mountStateImpl(false);
  const start = startTransition2.bind(
    null,
    currentlyRenderingFiber2,
    stateHook.queue,
    true,
    false
  );
  const hook = mountWorkInProgressHook();
  hook.memoizedState = start;
  return [false, start];
}
function updateTransition() {
  const [booleanOrThenable] = updateState(false);
  const hook = updateWorkInProgressHook();
  const start = hook.memoizedState;
  const isPending = typeof booleanOrThenable === "boolean" ? booleanOrThenable : (
    // This will suspend until the async action scope has finished.
    useThenable(booleanOrThenable)
  );
  return [isPending, start];
}
function rerenderTransition() {
  const [booleanOrThenable] = rerenderState(false);
  const hook = updateWorkInProgressHook();
  const start = hook.memoizedState;
  const isPending = typeof booleanOrThenable === "boolean" ? booleanOrThenable : (
    // This will suspend until the async action scope has finished.
    useThenable(booleanOrThenable)
  );
  return [isPending, start];
}
function useHostTransitionStatus() {
  return readContext(void 0);
}
function mountId() {
  const hook = mountWorkInProgressHook();
  const root2 = getWorkInProgressRoot();
  const identifierPrefix = root2.identifierPrefix;
  let id;
  if (getIsHydrating()) {
    const treeId = getTreeId();
    id = "\xAB" + identifierPrefix + "R" + treeId;
    const localId = localIdCounter++;
    if (localId > 0) {
      id += "H" + localId.toString(32);
    }
    id += "\xBB";
  } else {
    const globalClientId = globalClientIdCounter2++;
    id = "\xAB" + identifierPrefix + "r" + globalClientId.toString(32) + "\xBB";
  }
  hook.memoizedState = id;
  return id;
}
function updateId() {
  const hook = updateWorkInProgressHook();
  const id = hook.memoizedState;
  return id;
}
function mountRefresh() {
  const hook = mountWorkInProgressHook();
  const refresh = hook.memoizedState = refreshCache.bind(
    null,
    currentlyRenderingFiber2
  );
  return refresh;
}
function updateRefresh() {
  const hook = updateWorkInProgressHook();
  return hook.memoizedState;
}
function refreshCache(fiber, seedKey, seedValue) {
  let provider = fiber.return;
  while (provider !== null) {
    switch (provider.tag) {
      case CacheComponent:
      case HostRoot: {
        const lane = requestUpdateLane(provider);
        const refreshUpdate = createUpdate(lane);
        const root2 = enqueueUpdate2(provider, refreshUpdate, lane);
        if (root2 !== null) {
          startUpdateTimerByLane(lane, "refresh()");
          scheduleUpdateOnFiber(root2, provider, lane);
          entangleTransitions(root2, provider, lane);
        }
        const seededCache = createCache();
        if (seedKey !== null && seedKey !== void 0 && root2 !== null) {
          if (enableLegacyCache) {
            seededCache.data.set(seedKey, seedValue);
          } else {
            if (false) {
              console.error(
                "The seed argument is not enabled outside experimental channels."
              );
            }
          }
        }
        const payload = {
          cache: seededCache
        };
        refreshUpdate.payload = payload;
        return;
      }
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  if (false) {
    const args = arguments;
    if (typeof args[3] === "function") {
      console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      );
    }
  }
  const lane = requestUpdateLane(fiber);
  const update = {
    lane,
    revertLane: NoLane,
    gesture: null,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    enqueueRenderPhaseUpdate(queue, update);
  } else {
    const root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (root2 !== null) {
      startUpdateTimerByLane(lane, "dispatch()");
      scheduleUpdateOnFiber(root2, fiber, lane);
      entangleTransitionUpdate(root2, queue, lane);
    }
  }
  markUpdateInDevTools(fiber, lane, action);
}
function dispatchSetState(fiber, queue, action) {
  if (false) {
    const args = arguments;
    if (typeof args[3] === "function") {
      console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      );
    }
  }
  const lane = requestUpdateLane(fiber);
  const didScheduleUpdate = dispatchSetStateInternal(
    fiber,
    queue,
    action,
    lane
  );
  if (didScheduleUpdate) {
    startUpdateTimerByLane(lane, "setState()");
  }
  markUpdateInDevTools(fiber, lane, action);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  const update = {
    lane,
    revertLane: NoLane,
    gesture: null,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    enqueueRenderPhaseUpdate(queue, update);
  } else {
    const alternate = fiber.alternate;
    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        let prevDispatcher = null;
        if (false) {
          prevDispatcher = ReactSharedInternals_default.H;
          ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }
        try {
          const currentState = queue.lastRenderedState;
          const eagerState = lastRenderedReducer(currentState, action);
          update.hasEagerState = true;
          update.eagerState = eagerState;
          if (objectIs_default(eagerState, currentState)) {
            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);
            return false;
          }
        } catch (error) {
        } finally {
          if (false) {
            ReactSharedInternals_default.H = prevDispatcher;
          }
        }
      }
    }
    const root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (root2 !== null) {
      scheduleUpdateOnFiber(root2, fiber, lane);
      entangleTransitionUpdate(root2, queue, lane);
      return true;
    }
  }
  return false;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  const transition = requestCurrentTransition();
  if (false) {
    if (transition === null) {
      if (peekEntangledActionLane() !== NoLane) {
      } else {
        console.error(
          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
        );
      }
    }
  }
  const lane = enableGestureTransition && transition !== null && transition.gesture ? GestureLane : SyncLane;
  const update = {
    lane,
    // After committing, the optimistic update is "reverted" using the same
    // lane as the transition it's associated with.
    revertLane: requestTransitionLane(transition),
    gesture: null,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender) {
      throw new Error("Cannot update optimistic state while rendering.");
    } else {
      if (false) {
        console.error("Cannot call startTransition while rendering.");
      }
    }
  } else {
    const root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (root2 !== null) {
      startUpdateTimerByLane(lane, "setOptimistic()");
      scheduleUpdateOnFiber(root2, fiber, lane);
      if (enableGestureTransition && transition !== null) {
        const provider = transition.gesture;
        if (provider !== null) {
          update.gesture = scheduleGesture(root2, provider);
        }
      }
    }
  }
  markUpdateInDevTools(fiber, lane, action);
}
function isRenderPhaseUpdate(fiber) {
  const alternate = fiber.alternate;
  return fiber === currentlyRenderingFiber2 || alternate !== null && alternate === currentlyRenderingFiber2;
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  const pending = queue.pending;
  if (pending === null) {
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }
  queue.pending = update;
}
function entangleTransitionUpdate(root2, queue, lane) {
  if (isTransitionLane(lane)) {
    let queueLanes = queue.lanes;
    queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
    const newQueueLanes = mergeLanes(queueLanes, lane);
    queue.lanes = newQueueLanes;
    markRootEntangled(root2, newQueueLanes);
  }
}
function markUpdateInDevTools(fiber, lane, action) {
  if (enableSchedulingProfiler) {
    markStateUpdateScheduled(fiber, lane);
  }
}
var ContextOnlyDispatcher = {
  readContext,
  use: use2,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useInsertionEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useSyncExternalStore: throwInvalidHookError,
  useId: throwInvalidHookError,
  useHostTransitionStatus: throwInvalidHookError,
  useFormState: throwInvalidHookError,
  useActionState: throwInvalidHookError,
  useOptimistic: throwInvalidHookError,
  useMemoCache: throwInvalidHookError,
  useCacheRefresh: throwInvalidHookError
};
if (enableUseEffectEventHook) {
  ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
}
var HooksDispatcherOnMount = {
  readContext,
  use: use2,
  useCallback: mountCallback,
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: mountImperativeHandle,
  useLayoutEffect: mountLayoutEffect,
  useInsertionEffect: mountInsertionEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState,
  useDebugValue: mountDebugValue,
  useDeferredValue: mountDeferredValue,
  useTransition: mountTransition,
  useSyncExternalStore: mountSyncExternalStore,
  useId: mountId,
  useHostTransitionStatus,
  useFormState: mountActionState,
  useActionState: mountActionState,
  useOptimistic: mountOptimistic,
  useMemoCache: useMemoCache2,
  useCacheRefresh: mountRefresh
};
if (enableUseEffectEventHook) {
  HooksDispatcherOnMount.useEffectEvent = mountEvent;
}
var HooksDispatcherOnUpdate = {
  readContext,
  use: use2,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState,
  useDebugValue: updateDebugValue,
  useDeferredValue: updateDeferredValue,
  useTransition: updateTransition,
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
  useHostTransitionStatus,
  useFormState: updateActionState,
  useActionState: updateActionState,
  useOptimistic: updateOptimistic,
  useMemoCache: useMemoCache2,
  useCacheRefresh: updateRefresh
};
if (enableUseEffectEventHook) {
  HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
}
var HooksDispatcherOnRerender = {
  readContext,
  use: use2,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: rerenderReducer,
  useRef: updateRef,
  useState: rerenderState,
  useDebugValue: updateDebugValue,
  useDeferredValue: rerenderDeferredValue,
  useTransition: rerenderTransition,
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
  useHostTransitionStatus,
  useFormState: rerenderActionState,
  useActionState: rerenderActionState,
  useOptimistic: rerenderOptimistic,
  useMemoCache: useMemoCache2,
  useCacheRefresh: updateRefresh
};
if (enableUseEffectEventHook) {
  HooksDispatcherOnRerender.useEffectEvent = updateEvent;
}
if (false) {
  const warnInvalidContextAccess = () => {
    console.error(
      "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
    );
  };
  const warnInvalidHookAccess = () => {
    console.error(
      "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
    );
  };
  HooksDispatcherOnMountInDEV = {
    readContext(context) {
      return readContext(context);
    },
    use: use2,
    useCallback(callback, deps) {
      currentHookNameInDev = "useCallback";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountCallback(callback, deps);
    },
    useContext(context) {
      currentHookNameInDev = "useContext";
      mountHookTypesDev();
      return readContext(context);
    },
    useEffect(create, deps) {
      currentHookNameInDev = "useEffect";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountEffect(create, deps);
    },
    useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountImperativeHandle(ref, create, deps);
    },
    useInsertionEffect(create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountInsertionEffect(create, deps);
    },
    useLayoutEffect(create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountLayoutEffect(create, deps);
    },
    useMemo(create, deps) {
      currentHookNameInDev = "useMemo";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountMemo(create, deps);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useReducer(reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      mountHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useRef(initialValue) {
      currentHookNameInDev = "useRef";
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState(initialState) {
      currentHookNameInDev = "useState";
      mountHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountState(initialState);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useDebugValue(value, formatterFn) {
      currentHookNameInDev = "useDebugValue";
      mountHookTypesDev();
      return mountDebugValue(value, formatterFn);
    },
    useDeferredValue(value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      mountHookTypesDev();
      return mountDeferredValue(value, initialValue);
    },
    useTransition() {
      currentHookNameInDev = "useTransition";
      mountHookTypesDev();
      return mountTransition();
    },
    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      mountHookTypesDev();
      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId() {
      currentHookNameInDev = "useId";
      mountHookTypesDev();
      return mountId();
    },
    useFormState(action, initialState, permalink) {
      currentHookNameInDev = "useFormState";
      mountHookTypesDev();
      warnOnUseFormStateInDev();
      return mountActionState(action, initialState, permalink);
    },
    useActionState(action, initialState, permalink) {
      currentHookNameInDev = "useActionState";
      mountHookTypesDev();
      return mountActionState(action, initialState, permalink);
    },
    useOptimistic(passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      mountHookTypesDev();
      return mountOptimistic(passthrough, reducer);
    },
    useHostTransitionStatus,
    useMemoCache: useMemoCache2,
    useCacheRefresh() {
      currentHookNameInDev = "useCacheRefresh";
      mountHookTypesDev();
      return mountRefresh();
    }
  };
  if (enableUseEffectEventHook) {
    HooksDispatcherOnMountInDEV.useEffectEvent = function useEffectEvent2(callback) {
      currentHookNameInDev = "useEffectEvent";
      mountHookTypesDev();
      return mountEvent(callback);
    };
  }
  HooksDispatcherOnMountWithHookTypesInDEV = {
    readContext(context) {
      return readContext(context);
    },
    use: use2,
    useCallback(callback, deps) {
      currentHookNameInDev = "useCallback";
      updateHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext(context) {
      currentHookNameInDev = "useContext";
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect(create, deps) {
      currentHookNameInDev = "useEffect";
      updateHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      updateHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useInsertionEffect(create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      updateHookTypesDev();
      return mountInsertionEffect(create, deps);
    },
    useLayoutEffect(create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      updateHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo(create, deps) {
      currentHookNameInDev = "useMemo";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountMemo(create, deps);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useReducer(reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useRef(initialValue) {
      currentHookNameInDev = "useRef";
      updateHookTypesDev();
      return mountRef(initialValue);
    },
    useState(initialState) {
      currentHookNameInDev = "useState";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountState(initialState);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useDebugValue(value, formatterFn) {
      currentHookNameInDev = "useDebugValue";
      updateHookTypesDev();
      return mountDebugValue(value, formatterFn);
    },
    useDeferredValue(value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      updateHookTypesDev();
      return mountDeferredValue(value, initialValue);
    },
    useTransition() {
      currentHookNameInDev = "useTransition";
      updateHookTypesDev();
      return mountTransition();
    },
    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      updateHookTypesDev();
      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId() {
      currentHookNameInDev = "useId";
      updateHookTypesDev();
      return mountId();
    },
    useActionState(action, initialState, permalink) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return mountActionState(action, initialState, permalink);
    },
    useFormState(action, initialState, permalink) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return mountActionState(action, initialState, permalink);
    },
    useOptimistic(passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return mountOptimistic(passthrough, reducer);
    },
    useHostTransitionStatus,
    useMemoCache: useMemoCache2,
    useCacheRefresh() {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return mountRefresh();
    }
  };
  if (enableUseEffectEventHook) {
    HooksDispatcherOnMountWithHookTypesInDEV.useEffectEvent = function useEffectEvent2(callback) {
      currentHookNameInDev = "useEffectEvent";
      updateHookTypesDev();
      return mountEvent(callback);
    };
  }
  HooksDispatcherOnUpdateInDEV = {
    readContext(context) {
      return readContext(context);
    },
    use: use2,
    useCallback(callback, deps) {
      currentHookNameInDev = "useCallback";
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext(context) {
      currentHookNameInDev = "useContext";
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect(create, deps) {
      currentHookNameInDev = "useEffect";
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useInsertionEffect(create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      updateHookTypesDev();
      return updateInsertionEffect(create, deps);
    },
    useLayoutEffect(create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo(create, deps) {
      currentHookNameInDev = "useMemo";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useReducer(reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useRef(initialValue) {
      currentHookNameInDev = "useRef";
      updateHookTypesDev();
      return updateRef(initialValue);
    },
    useState(initialState) {
      currentHookNameInDev = "useState";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateState(initialState);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useDebugValue(value, formatterFn) {
      currentHookNameInDev = "useDebugValue";
      updateHookTypesDev();
      return updateDebugValue(value, formatterFn);
    },
    useDeferredValue(value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      updateHookTypesDev();
      return updateDeferredValue(value, initialValue);
    },
    useTransition() {
      currentHookNameInDev = "useTransition";
      updateHookTypesDev();
      return updateTransition();
    },
    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      updateHookTypesDev();
      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId() {
      currentHookNameInDev = "useId";
      updateHookTypesDev();
      return updateId();
    },
    useFormState(action, initialState, permalink) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return updateActionState(action, initialState, permalink);
    },
    useActionState(action, initialState, permalink) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return updateActionState(action, initialState, permalink);
    },
    useOptimistic(passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return updateOptimistic(passthrough, reducer);
    },
    useHostTransitionStatus,
    useMemoCache: useMemoCache2,
    useCacheRefresh() {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return updateRefresh();
    }
  };
  if (enableUseEffectEventHook) {
    HooksDispatcherOnUpdateInDEV.useEffectEvent = function useEffectEvent2(callback) {
      currentHookNameInDev = "useEffectEvent";
      updateHookTypesDev();
      return updateEvent(callback);
    };
  }
  HooksDispatcherOnRerenderInDEV = {
    readContext(context) {
      return readContext(context);
    },
    use: use2,
    useCallback(callback, deps) {
      currentHookNameInDev = "useCallback";
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext(context) {
      currentHookNameInDev = "useContext";
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect(create, deps) {
      currentHookNameInDev = "useEffect";
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useInsertionEffect(create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      updateHookTypesDev();
      return updateInsertionEffect(create, deps);
    },
    useLayoutEffect(create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo(create, deps) {
      currentHookNameInDev = "useMemo";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useReducer(reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useRef(initialValue) {
      currentHookNameInDev = "useRef";
      updateHookTypesDev();
      return updateRef(initialValue);
    },
    useState(initialState) {
      currentHookNameInDev = "useState";
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
      try {
        return rerenderState(initialState);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useDebugValue(value, formatterFn) {
      currentHookNameInDev = "useDebugValue";
      updateHookTypesDev();
      return updateDebugValue(value, formatterFn);
    },
    useDeferredValue(value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      updateHookTypesDev();
      return rerenderDeferredValue(value, initialValue);
    },
    useTransition() {
      currentHookNameInDev = "useTransition";
      updateHookTypesDev();
      return rerenderTransition();
    },
    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      updateHookTypesDev();
      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId() {
      currentHookNameInDev = "useId";
      updateHookTypesDev();
      return updateId();
    },
    useFormState(action, initialState, permalink) {
      currentHookNameInDev = "useFormState";
      updateHookTypesDev();
      warnOnUseFormStateInDev();
      return rerenderActionState(action, initialState, permalink);
    },
    useActionState(action, initialState, permalink) {
      currentHookNameInDev = "useActionState";
      updateHookTypesDev();
      return rerenderActionState(action, initialState, permalink);
    },
    useOptimistic(passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      updateHookTypesDev();
      return rerenderOptimistic(passthrough, reducer);
    },
    useHostTransitionStatus,
    useMemoCache: useMemoCache2,
    useCacheRefresh() {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return updateRefresh();
    }
  };
  if (enableUseEffectEventHook) {
    HooksDispatcherOnRerenderInDEV.useEffectEvent = function useEffectEvent2(callback) {
      currentHookNameInDev = "useEffectEvent";
      updateHookTypesDev();
      return updateEvent(callback);
    };
  }
  InvalidNestedHooksDispatcherOnMountInDEV = {
    readContext(context) {
      warnInvalidContextAccess();
      return readContext(context);
    },
    use(usable) {
      warnInvalidHookAccess();
      return use2(usable);
    },
    useCallback(callback, deps) {
      currentHookNameInDev = "useCallback";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext(context) {
      currentHookNameInDev = "useContext";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return readContext(context);
    },
    useEffect(create, deps) {
      currentHookNameInDev = "useEffect";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useInsertionEffect(create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountInsertionEffect(create, deps);
    },
    useLayoutEffect(create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo(create, deps) {
      currentHookNameInDev = "useMemo";
      warnInvalidHookAccess();
      mountHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountMemo(create, deps);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useReducer(reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      warnInvalidHookAccess();
      mountHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useRef(initialValue) {
      currentHookNameInDev = "useRef";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState(initialState) {
      currentHookNameInDev = "useState";
      warnInvalidHookAccess();
      mountHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountState(initialState);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useDebugValue(value, formatterFn) {
      currentHookNameInDev = "useDebugValue";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDebugValue(value, formatterFn);
    },
    useDeferredValue(value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDeferredValue(value, initialValue);
    },
    useTransition() {
      currentHookNameInDev = "useTransition";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountTransition();
    },
    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId() {
      currentHookNameInDev = "useId";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountId();
    },
    useFormState(action, initialState, permalink) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountActionState(action, initialState, permalink);
    },
    useActionState(action, initialState, permalink) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountActionState(action, initialState, permalink);
    },
    useOptimistic(passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountOptimistic(passthrough, reducer);
    },
    useMemoCache(size) {
      warnInvalidHookAccess();
      return useMemoCache2(size);
    },
    useHostTransitionStatus,
    useCacheRefresh() {
      currentHookNameInDev = "useCacheRefresh";
      mountHookTypesDev();
      return mountRefresh();
    }
  };
  if (enableUseEffectEventHook) {
    InvalidNestedHooksDispatcherOnMountInDEV.useEffectEvent = function useEffectEvent2(callback) {
      currentHookNameInDev = "useEffectEvent";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountEvent(callback);
    };
  }
  InvalidNestedHooksDispatcherOnUpdateInDEV = {
    readContext(context) {
      warnInvalidContextAccess();
      return readContext(context);
    },
    use(usable) {
      warnInvalidHookAccess();
      return use2(usable);
    },
    useCallback(callback, deps) {
      currentHookNameInDev = "useCallback";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext(context) {
      currentHookNameInDev = "useContext";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect(create, deps) {
      currentHookNameInDev = "useEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useInsertionEffect(create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateInsertionEffect(create, deps);
    },
    useLayoutEffect(create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo(create, deps) {
      currentHookNameInDev = "useMemo";
      warnInvalidHookAccess();
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useReducer(reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      warnInvalidHookAccess();
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useRef(initialValue) {
      currentHookNameInDev = "useRef";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef(initialValue);
    },
    useState(initialState) {
      currentHookNameInDev = "useState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateState(initialState);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useDebugValue(value, formatterFn) {
      currentHookNameInDev = "useDebugValue";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue(value, formatterFn);
    },
    useDeferredValue(value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDeferredValue(value, initialValue);
    },
    useTransition() {
      currentHookNameInDev = "useTransition";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateTransition();
    },
    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId() {
      currentHookNameInDev = "useId";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateId();
    },
    useFormState(action, initialState, permalink) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateActionState(action, initialState, permalink);
    },
    useActionState(action, initialState, permalink) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateActionState(action, initialState, permalink);
    },
    useOptimistic(passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateOptimistic(passthrough, reducer);
    },
    useMemoCache(size) {
      warnInvalidHookAccess();
      return useMemoCache2(size);
    },
    useHostTransitionStatus,
    useCacheRefresh() {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return updateRefresh();
    }
  };
  if (enableUseEffectEventHook) {
    InvalidNestedHooksDispatcherOnUpdateInDEV.useEffectEvent = function useEffectEvent2(callback) {
      currentHookNameInDev = "useEffectEvent";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEvent(callback);
    };
  }
  InvalidNestedHooksDispatcherOnRerenderInDEV = {
    readContext(context) {
      warnInvalidContextAccess();
      return readContext(context);
    },
    use(usable) {
      warnInvalidHookAccess();
      return use2(usable);
    },
    useCallback(callback, deps) {
      currentHookNameInDev = "useCallback";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext(context) {
      currentHookNameInDev = "useContext";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect(create, deps) {
      currentHookNameInDev = "useEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle(ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useInsertionEffect(create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateInsertionEffect(create, deps);
    },
    useLayoutEffect(create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo(create, deps) {
      currentHookNameInDev = "useMemo";
      warnInvalidHookAccess();
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useReducer(reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      warnInvalidHookAccess();
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useRef(initialValue) {
      currentHookNameInDev = "useRef";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef(initialValue);
    },
    useState(initialState) {
      currentHookNameInDev = "useState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      const prevDispatcher = ReactSharedInternals_default.H;
      ReactSharedInternals_default.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return rerenderState(initialState);
      } finally {
        ReactSharedInternals_default.H = prevDispatcher;
      }
    },
    useDebugValue(value, formatterFn) {
      currentHookNameInDev = "useDebugValue";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue(value, formatterFn);
    },
    useDeferredValue(value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderDeferredValue(value, initialValue);
    },
    useTransition() {
      currentHookNameInDev = "useTransition";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderTransition();
    },
    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId() {
      currentHookNameInDev = "useId";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateId();
    },
    useFormState(action, initialState, permalink) {
      currentHookNameInDev = "useFormState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderActionState(action, initialState, permalink);
    },
    useActionState(action, initialState, permalink) {
      currentHookNameInDev = "useActionState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderActionState(action, initialState, permalink);
    },
    useOptimistic(passthrough, reducer) {
      currentHookNameInDev = "useOptimistic";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderOptimistic(passthrough, reducer);
    },
    useMemoCache(size) {
      warnInvalidHookAccess();
      return useMemoCache2(size);
    },
    useHostTransitionStatus,
    useCacheRefresh() {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return updateRefresh();
    }
  };
  if (enableUseEffectEventHook) {
    InvalidNestedHooksDispatcherOnRerenderInDEV.useEffectEvent = function useEffectEvent2(callback) {
      currentHookNameInDev = "useEffectEvent";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEvent(callback);
    };
  }
}

// dist/react-reconciler/src/ReactFiberClassComponent.js
if (false) {
  didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
  didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
  didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
  didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
  didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
  didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
  didWarnAboutContextTypes = /* @__PURE__ */ new Set();
  didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
  didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
  didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
  Object.freeze(fakeInternalInstance);
}
function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
  const prevState = workInProgress2.memoizedState;
  let partialState = getDerivedStateFromProps(nextProps, prevState);
  if (false) {
    if (workInProgress2.mode & StrictLegacyMode) {
      setIsStrictModeForDevtools(true);
      try {
        partialState = getDerivedStateFromProps(nextProps, prevState);
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    warnOnUndefinedDerivedState(ctor, partialState);
  }
  const memoizedState = partialState === null || partialState === void 0 ? prevState : assign_default({}, prevState, partialState);
  workInProgress2.memoizedState = memoizedState;
  if (workInProgress2.lanes === NoLanes) {
    const updateQueue = workInProgress2.updateQueue;
    updateQueue.baseState = memoizedState;
  }
}
var classComponentUpdater = {
  // $FlowFixMe[missing-local-annot]
  enqueueSetState(inst, payload, callback) {
    const fiber = get(inst);
    const lane = requestUpdateLane(fiber);
    const update = createUpdate(lane);
    update.payload = payload;
    if (callback !== void 0 && callback !== null) {
      if (false) {
        warnOnInvalidCallback(callback);
      }
      update.callback = callback;
    }
    const root2 = enqueueUpdate2(fiber, update, lane);
    if (root2 !== null) {
      startUpdateTimerByLane(lane, "this.setState()");
      scheduleUpdateOnFiber(root2, fiber, lane);
      entangleTransitions(root2, fiber, lane);
    }
    if (enableSchedulingProfiler) {
      markStateUpdateScheduled(fiber, lane);
    }
  },
  enqueueReplaceState(inst, payload, callback) {
    const fiber = get(inst);
    const lane = requestUpdateLane(fiber);
    const update = createUpdate(lane);
    update.tag = ReplaceState;
    update.payload = payload;
    if (callback !== void 0 && callback !== null) {
      if (false) {
        warnOnInvalidCallback(callback);
      }
      update.callback = callback;
    }
    const root2 = enqueueUpdate2(fiber, update, lane);
    if (root2 !== null) {
      startUpdateTimerByLane(lane, "this.replaceState()");
      scheduleUpdateOnFiber(root2, fiber, lane);
      entangleTransitions(root2, fiber, lane);
    }
    if (enableSchedulingProfiler) {
      markStateUpdateScheduled(fiber, lane);
    }
  },
  // $FlowFixMe[missing-local-annot]
  enqueueForceUpdate(inst, callback) {
    const fiber = get(inst);
    const lane = requestUpdateLane(fiber);
    const update = createUpdate(lane);
    update.tag = ForceUpdate;
    if (callback !== void 0 && callback !== null) {
      if (false) {
        warnOnInvalidCallback(callback);
      }
      update.callback = callback;
    }
    const root2 = enqueueUpdate2(fiber, update, lane);
    if (root2 !== null) {
      startUpdateTimerByLane(lane, "this.forceUpdate()");
      scheduleUpdateOnFiber(root2, fiber, lane);
      entangleTransitions(root2, fiber, lane);
    }
    if (enableSchedulingProfiler) {
      markForceUpdateScheduled(fiber, lane);
    }
  }
};
function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
  const instance = workInProgress2.stateNode;
  if (typeof instance.shouldComponentUpdate === "function") {
    let shouldUpdate = instance.shouldComponentUpdate(
      newProps,
      newState,
      nextContext
    );
    if (false) {
      if (workInProgress2.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(true);
        try {
          shouldUpdate = instance.shouldComponentUpdate(
            newProps,
            newState,
            nextContext
          );
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      if (shouldUpdate === void 0) {
        console.error(
          "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
          getComponentNameFromType(ctor) || "Component"
        );
      }
    }
    return shouldUpdate;
  }
  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return !shallowEqual_default(oldProps, newProps) || !shallowEqual_default(oldState, newState);
  }
  return true;
}
function constructClassInstance(workInProgress2, ctor, props) {
  let isLegacyContextConsumer = false;
  let unmaskedContext = emptyContextObject;
  let context = emptyContextObject;
  const contextType = ctor.contextType;
  if (false) {
    if ("contextType" in ctor) {
      const isValid = (
        // Allow null for conditional declaration
        contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE
      );
      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
        didWarnAboutInvalidateContextType.add(ctor);
        let addendum = "";
        if (contextType === void 0) {
          addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
        } else if (typeof contextType !== "object") {
          addendum = " However, it is set to a " + typeof contextType + ".";
        } else if (contextType.$$typeof === REACT_CONSUMER_TYPE) {
          addendum = " Did you accidentally pass the Context.Consumer instead?";
        } else {
          addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
        }
        console.error(
          "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
          getComponentNameFromType(ctor) || "Component",
          addendum
        );
      }
    }
  }
  if (typeof contextType === "object" && contextType !== null) {
    context = readContext(contextType);
  } else if (!disableLegacyContext) {
    unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
    const contextTypes = ctor.contextTypes;
    isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
    context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
  }
  let instance = new ctor(props, context);
  if (false) {
    if (workInProgress2.mode & StrictLegacyMode) {
      setIsStrictModeForDevtools(true);
      try {
        instance = new ctor(props, context);
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
  }
  const state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
  instance.updater = classComponentUpdater;
  workInProgress2.stateNode = instance;
  set(instance, workInProgress2);
  if (false) {
    instance._reactInternalInstance = fakeInternalInstance;
  }
  if (false) {
    if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
      const componentName = getComponentNameFromType(ctor) || "Component";
      if (!didWarnAboutUninitializedState.has(componentName)) {
        didWarnAboutUninitializedState.add(componentName);
        console.error(
          "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
          componentName,
          instance.state === null ? "null" : "undefined",
          componentName
        );
      }
    }
    if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
      let foundWillMountName = null;
      let foundWillReceivePropsName = null;
      let foundWillUpdateName = null;
      if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
        foundWillMountName = "componentWillMount";
      } else if (typeof instance.UNSAFE_componentWillMount === "function") {
        foundWillMountName = "UNSAFE_componentWillMount";
      }
      if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
        foundWillReceivePropsName = "componentWillReceiveProps";
      } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
        foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
      }
      if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
        foundWillUpdateName = "componentWillUpdate";
      } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
        foundWillUpdateName = "UNSAFE_componentWillUpdate";
      }
      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        const componentName = getComponentNameFromType(ctor) || "Component";
        const newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {
          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);
          console.error(
            "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
            componentName,
            newApiName,
            foundWillMountName !== null ? `
  ${foundWillMountName}` : "",
            foundWillReceivePropsName !== null ? `
  ${foundWillReceivePropsName}` : "",
            foundWillUpdateName !== null ? `
  ${foundWillUpdateName}` : ""
          );
        }
      }
    }
  }
  if (isLegacyContextConsumer) {
    cacheContext(workInProgress2, unmaskedContext, context);
  }
  return instance;
}
function callComponentWillMount(workInProgress2, instance) {
  const oldState = instance.state;
  if (typeof instance.componentWillMount === "function") {
    instance.componentWillMount();
  }
  if (typeof instance.UNSAFE_componentWillMount === "function") {
    instance.UNSAFE_componentWillMount();
  }
  if (oldState !== instance.state) {
    if (false) {
      console.error(
        "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
        getComponentNameFromFiber(workInProgress2) || "Component"
      );
    }
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}
function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
  const oldState = instance.state;
  if (typeof instance.componentWillReceiveProps === "function") {
    instance.componentWillReceiveProps(newProps, nextContext);
  }
  if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  }
  if (instance.state !== oldState) {
    if (false) {
      const componentName = getComponentNameFromFiber(workInProgress2) || "Component";
      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
        didWarnAboutStateAssignmentForComponent.add(componentName);
        console.error(
          "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          componentName
        );
      }
    }
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}
function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
  if (false) {
    checkClassInstance(workInProgress2, ctor, newProps);
  }
  const instance = workInProgress2.stateNode;
  instance.props = newProps;
  instance.state = workInProgress2.memoizedState;
  instance.refs = {};
  initializeUpdateQueue(workInProgress2);
  const contextType = ctor.contextType;
  if (typeof contextType === "object" && contextType !== null) {
    instance.context = readContext(contextType);
  } else if (disableLegacyContext) {
    instance.context = emptyContextObject;
  } else {
    const unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
    instance.context = getMaskedContext(workInProgress2, unmaskedContext);
  }
  if (false) {
    if (instance.state === newProps) {
      const componentName = getComponentNameFromType(ctor) || "Component";
      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
        console.error(
          "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
          componentName
        );
      }
    }
    if (workInProgress2.mode & StrictLegacyMode) {
      ReactStrictModeWarnings_default.recordLegacyContextWarning(
        workInProgress2,
        instance
      );
    }
    ReactStrictModeWarnings_default.recordUnsafeLifecycleWarnings(
      workInProgress2,
      instance
    );
  }
  instance.state = workInProgress2.memoizedState;
  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === "function") {
    applyDerivedStateFromProps(
      workInProgress2,
      ctor,
      getDerivedStateFromProps,
      newProps
    );
    instance.state = workInProgress2.memoizedState;
  }
  if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
    callComponentWillMount(workInProgress2, instance);
    processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
    suspendIfUpdateReadFromEntangledAsyncAction();
    instance.state = workInProgress2.memoizedState;
  }
  if (typeof instance.componentDidMount === "function") {
    workInProgress2.flags |= Update | LayoutStatic;
  }
  if (false) {
    workInProgress2.flags |= MountLayoutDev;
  }
}
function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
  const instance = workInProgress2.stateNode;
  const unresolvedOldProps = workInProgress2.memoizedProps;
  const oldProps = resolveClassComponentProps(
    ctor,
    unresolvedOldProps,
    workInProgress2.type === workInProgress2.elementType
  );
  instance.props = oldProps;
  const oldContext = instance.context;
  const contextType = ctor.contextType;
  let nextContext = emptyContextObject;
  if (typeof contextType === "object" && contextType !== null) {
    nextContext = readContext(contextType);
  } else if (!disableLegacyContext) {
    const nextLegacyUnmaskedContext = getUnmaskedContext(
      workInProgress2,
      ctor,
      true
    );
    nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
  }
  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  const hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
  const unresolvedNewProps = workInProgress2.pendingProps;
  const didReceiveNewProps = unresolvedNewProps !== unresolvedOldProps;
  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
    if (didReceiveNewProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(
        workInProgress2,
        instance,
        newProps,
        nextContext
      );
    }
  }
  resetHasForceUpdateBeforeProcessing();
  const oldState = workInProgress2.memoizedState;
  let newState = instance.state = oldState;
  processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
  suspendIfUpdateReadFromEntangledAsyncAction();
  newState = workInProgress2.memoizedState;
  if (!didReceiveNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    if (typeof instance.componentDidMount === "function") {
      workInProgress2.flags |= Update | LayoutStatic;
    }
    if (false) {
      workInProgress2.flags |= MountLayoutDev;
    }
    return false;
  }
  if (typeof getDerivedStateFromProps === "function") {
    applyDerivedStateFromProps(
      workInProgress2,
      ctor,
      getDerivedStateFromProps,
      newProps
    );
    newState = workInProgress2.memoizedState;
  }
  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(
    workInProgress2,
    ctor,
    oldProps,
    newProps,
    oldState,
    newState,
    nextContext
  );
  if (shouldUpdate) {
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
      if (typeof instance.componentWillMount === "function") {
        instance.componentWillMount();
      }
      if (typeof instance.UNSAFE_componentWillMount === "function") {
        instance.UNSAFE_componentWillMount();
      }
    }
    if (typeof instance.componentDidMount === "function") {
      workInProgress2.flags |= Update | LayoutStatic;
    }
    if (false) {
      workInProgress2.flags |= MountLayoutDev;
    }
  } else {
    if (typeof instance.componentDidMount === "function") {
      workInProgress2.flags |= Update | LayoutStatic;
    }
    if (false) {
      workInProgress2.flags |= MountLayoutDev;
    }
    workInProgress2.memoizedProps = newProps;
    workInProgress2.memoizedState = newState;
  }
  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
}
function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
  const instance = workInProgress2.stateNode;
  cloneUpdateQueue(current2, workInProgress2);
  const unresolvedOldProps = workInProgress2.memoizedProps;
  const oldProps = resolveClassComponentProps(
    ctor,
    unresolvedOldProps,
    workInProgress2.type === workInProgress2.elementType
  );
  instance.props = oldProps;
  const unresolvedNewProps = workInProgress2.pendingProps;
  const oldContext = instance.context;
  const contextType = ctor.contextType;
  let nextContext = emptyContextObject;
  if (typeof contextType === "object" && contextType !== null) {
    nextContext = readContext(contextType);
  } else if (!disableLegacyContext) {
    const nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
    nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
  }
  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  const hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(
        workInProgress2,
        instance,
        newProps,
        nextContext
      );
    }
  }
  resetHasForceUpdateBeforeProcessing();
  const oldState = workInProgress2.memoizedState;
  let newState = instance.state = oldState;
  processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
  suspendIfUpdateReadFromEntangledAsyncAction();
  newState = workInProgress2.memoizedState;
  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !(current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies))) {
    if (typeof instance.componentDidUpdate === "function") {
      if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
        workInProgress2.flags |= Update;
      }
    }
    if (typeof instance.getSnapshotBeforeUpdate === "function") {
      if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
        workInProgress2.flags |= Snapshot;
      }
    }
    return false;
  }
  if (typeof getDerivedStateFromProps === "function") {
    applyDerivedStateFromProps(
      workInProgress2,
      ctor,
      getDerivedStateFromProps,
      newProps
    );
    newState = workInProgress2.memoizedState;
  }
  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(
    workInProgress2,
    ctor,
    oldProps,
    newProps,
    oldState,
    newState,
    nextContext
  ) || // TODO: In some cases, we'll end up checking if context has changed twice,
  // both before and after `shouldComponentUpdate` has been called. Not ideal,
  // but I'm loath to refactor this function. This only happens for memoized
  // components so it's not that common.
  current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies);
  if (shouldUpdate) {
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
      if (typeof instance.componentWillUpdate === "function") {
        instance.componentWillUpdate(newProps, newState, nextContext);
      }
      if (typeof instance.UNSAFE_componentWillUpdate === "function") {
        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
      }
    }
    if (typeof instance.componentDidUpdate === "function") {
      workInProgress2.flags |= Update;
    }
    if (typeof instance.getSnapshotBeforeUpdate === "function") {
      workInProgress2.flags |= Snapshot;
    }
  } else {
    if (typeof instance.componentDidUpdate === "function") {
      if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
        workInProgress2.flags |= Update;
      }
    }
    if (typeof instance.getSnapshotBeforeUpdate === "function") {
      if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
        workInProgress2.flags |= Snapshot;
      }
    }
    workInProgress2.memoizedProps = newProps;
    workInProgress2.memoizedState = newState;
  }
  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
}
function resolveClassComponentProps(Component2, baseProps, alreadyResolvedDefaultProps) {
  let newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (const propName in baseProps) {
      if (propName !== "ref") {
        newProps[propName] = baseProps[propName];
      }
    }
  }
  const defaultProps = Component2.defaultProps;
  if (defaultProps && // If disableDefaultPropsExceptForClasses is true, we always resolve
  // default props here in the reconciler, rather than in the JSX runtime.
  (disableDefaultPropsExceptForClasses || !alreadyResolvedDefaultProps)) {
    if (newProps === baseProps) {
      newProps = assign_default({}, newProps);
    }
    for (const propName in defaultProps) {
      if (newProps[propName] === void 0) {
        newProps[propName] = defaultProps[propName];
      }
    }
  }
  return newProps;
}

// dist/react-reconciler/src/ReactFiberLazyComponent.js
function resolveDefaultPropsOnNonClassComponent(Component2, baseProps) {
  if (disableDefaultPropsExceptForClasses) {
    return baseProps;
  }
  if (Component2 && Component2.defaultProps) {
    const props = assign_default({}, baseProps);
    const defaultProps = Component2.defaultProps;
    for (const propName in defaultProps) {
      if (props[propName] === void 0) {
        props[propName] = defaultProps[propName];
      }
    }
    return props;
  }
  return baseProps;
}

// dist/react-reconciler/src/ReactFiberErrorLogger.js
function defaultOnUncaughtError(error, errorInfo) {
  reportGlobalError_default(error);
  if (false) {
    const componentNameMessage = componentName ? `An error occurred in the <${componentName}> component.` : "An error occurred in one of your React components.";
    const errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.";
    try {
      console.warn(
        "%s\n\n%s\n",
        componentNameMessage,
        errorBoundaryMessage
        // We let our console.error wrapper add the component stack to the end.
      );
    } finally {
    }
  }
}
function defaultOnCaughtError(error, errorInfo) {
  if (false) {
    const componentNameMessage = componentName ? `The above error occurred in the <${componentName}> component.` : "The above error occurred in one of your React components.";
    const recreateMessage = `React will try to recreate this component tree from scratch using the error boundary you provided, ${errorBoundaryName || "Anonymous"}.`;
    try {
      if (typeof error === "object" && error !== null && typeof error.environmentName === "string") {
        (void 0)(
          "error",
          [
            "%o\n\n%s\n\n%s\n",
            error,
            componentNameMessage,
            recreateMessage
            // We let DevTools or console.createTask add the component stack to the end.
          ],
          error.environmentName
        )();
      } else {
        console.error(
          "%o\n\n%s\n\n%s\n",
          error,
          componentNameMessage,
          recreateMessage
          // We let our DevTools or console.createTask add the component stack to the end.
        );
      }
    } finally {
    }
  } else {
    console["error"](error);
  }
}
function defaultOnRecoverableError(error, errorInfo) {
  reportGlobalError_default(error);
}
function logUncaughtError(root2, errorInfo) {
  try {
    if (false) {
      componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
      errorBoundaryName = null;
    }
    const error = errorInfo.value;
    if (false) {
      ReactSharedInternals_default.thrownErrors.push(error);
      return;
    }
    const onUncaughtError = root2.onUncaughtError;
    onUncaughtError(error, {
      componentStack: errorInfo.stack
    });
  } catch (e) {
    setTimeout(() => {
      throw e;
    });
  }
}
function logCaughtError(root2, boundary, errorInfo) {
  try {
    if (false) {
      componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
      errorBoundaryName = getComponentNameFromFiber(boundary);
    }
    const error = errorInfo.value;
    const onCaughtError = root2.onCaughtError;
    onCaughtError(error, {
      componentStack: errorInfo.stack,
      errorBoundary: boundary.tag === ClassComponent ? boundary.stateNode : null
    });
  } catch (e) {
    setTimeout(() => {
      throw e;
    });
  }
}

// dist/react-reconciler/src/ReactFiberThrow.js
function createRootErrorUpdate(root2, errorInfo, lane) {
  const update = createUpdate(lane);
  update.tag = CaptureUpdate;
  update.payload = { element: null };
  update.callback = () => {
    if (false) {
      runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
    } else {
      logUncaughtError(root2, errorInfo);
    }
  };
  return update;
}
function createClassErrorUpdate(lane) {
  const update = createUpdate(lane);
  update.tag = CaptureUpdate;
  return update;
}
function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if (typeof getDerivedStateFromError === "function") {
    const error = errorInfo.value;
    update.payload = () => {
      return getDerivedStateFromError(error);
    };
    update.callback = () => {
      if (false) {
        markFailedErrorBoundaryForHotReloading(fiber);
      }
      if (false) {
        runWithFiberInDEV(
          errorInfo.source,
          logCaughtError,
          root2,
          fiber,
          errorInfo
        );
      } else {
        logCaughtError(root2, fiber, errorInfo);
      }
    };
  }
  const inst = fiber.stateNode;
  if (inst !== null && typeof inst.componentDidCatch === "function") {
    update.callback = function callback() {
      if (false) {
        markFailedErrorBoundaryForHotReloading(fiber);
      }
      if (false) {
        runWithFiberInDEV(
          errorInfo.source,
          logCaughtError,
          root2,
          fiber,
          errorInfo
        );
      } else {
        logCaughtError(root2, fiber, errorInfo);
      }
      if (typeof getDerivedStateFromError !== "function") {
        markLegacyErrorBoundaryAsFailed(this);
      }
      if (false) {
        callComponentDidCatchInDEV(this, errorInfo);
      } else {
        const error = errorInfo.value;
        const stack = errorInfo.stack;
        this.componentDidCatch(error, {
          componentStack: stack !== null ? stack : ""
        });
      }
      if (false) {
        if (typeof getDerivedStateFromError !== "function") {
          if (!includesSomeLane(fiber.lanes, SyncLane)) {
            console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          }
        }
      }
    };
  }
}
function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
  const currentSourceFiber = sourceFiber.alternate;
  if (currentSourceFiber !== null) {
    propagateParentContextChangesToDeferredTree(
      currentSourceFiber,
      sourceFiber,
      rootRenderLanes
    );
  }
  const tag = sourceFiber.tag;
  if (!disableLegacyMode && (sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
    const currentSource = sourceFiber.alternate;
    if (currentSource) {
      sourceFiber.updateQueue = currentSource.updateQueue;
      sourceFiber.memoizedState = currentSource.memoizedState;
      sourceFiber.lanes = currentSource.lanes;
    } else {
      sourceFiber.updateQueue = null;
      sourceFiber.memoizedState = null;
    }
  }
}
function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
  if (!disableLegacyMode && (suspenseBoundary.mode & ConcurrentMode) === NoMode) {
    if (suspenseBoundary === returnFiber) {
      suspenseBoundary.flags |= ShouldCapture;
    } else {
      suspenseBoundary.flags |= DidCapture;
      sourceFiber.flags |= ForceUpdateForLegacySuspense;
      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
      if (sourceFiber.tag === ClassComponent) {
        const currentSourceFiber = sourceFiber.alternate;
        if (currentSourceFiber === null) {
          sourceFiber.tag = IncompleteClassComponent;
        } else {
          const update = createUpdate(SyncLane);
          update.tag = ForceUpdate;
          enqueueUpdate2(sourceFiber, update, SyncLane);
        }
      } else if (sourceFiber.tag === FunctionComponent) {
        const currentSourceFiber = sourceFiber.alternate;
        if (currentSourceFiber === null) {
          sourceFiber.tag = IncompleteFunctionComponent;
        }
      }
      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
    }
    return suspenseBoundary;
  }
  suspenseBoundary.flags |= ShouldCapture;
  suspenseBoundary.lanes = rootRenderLanes;
  return suspenseBoundary;
}
function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
  sourceFiber.flags |= Incomplete;
  if (enableUpdaterTracking) {
    if (isDevToolsPresent) {
      restorePendingUpdaters(root2, rootRenderLanes);
    }
  }
  if (value !== null && typeof value === "object") {
    if (enablePostpone && value.$$typeof === REACT_POSTPONE_TYPE) {
      value = { then: function() {
      } };
    }
    if (typeof value.then === "function") {
      const wakeable = value;
      resetSuspendedComponent(sourceFiber, rootRenderLanes);
      if (false) {
        if (getIsHydrating() && (disableLegacyMode || sourceFiber.mode & ConcurrentMode)) {
          markDidThrowWhileHydratingDEV();
        }
      }
      const suspenseBoundary = getSuspenseHandler();
      if (suspenseBoundary !== null) {
        switch (suspenseBoundary.tag) {
          case ActivityComponent:
          case SuspenseComponent: {
            if (disableLegacyMode || sourceFiber.mode & ConcurrentMode) {
              if (getShellBoundary() === null) {
                renderDidSuspendDelayIfPossible();
              } else {
                const current2 = suspenseBoundary.alternate;
                if (current2 === null) {
                  renderDidSuspend();
                }
              }
            }
            suspenseBoundary.flags &= ~ForceClientRender;
            markSuspenseBoundaryShouldCapture(
              suspenseBoundary,
              returnFiber,
              sourceFiber,
              root2,
              rootRenderLanes
            );
            const isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;
            if (isSuspenseyResource) {
              suspenseBoundary.flags |= ScheduleRetry;
            } else {
              const retryQueue = suspenseBoundary.updateQueue;
              if (retryQueue === null) {
                suspenseBoundary.updateQueue = /* @__PURE__ */ new Set([wakeable]);
              } else {
                retryQueue.add(wakeable);
              }
              if (disableLegacyMode || suspenseBoundary.mode & ConcurrentMode) {
                attachPingListener(root2, wakeable, rootRenderLanes);
              }
            }
            return false;
          }
          case OffscreenComponent: {
            if (disableLegacyMode || suspenseBoundary.mode & ConcurrentMode) {
              suspenseBoundary.flags |= ShouldCapture;
              const isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;
              if (isSuspenseyResource) {
                suspenseBoundary.flags |= ScheduleRetry;
              } else {
                const offscreenQueue = suspenseBoundary.updateQueue;
                if (offscreenQueue === null) {
                  const newOffscreenQueue = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([wakeable])
                  };
                  suspenseBoundary.updateQueue = newOffscreenQueue;
                } else {
                  const retryQueue = offscreenQueue.retryQueue;
                  if (retryQueue === null) {
                    offscreenQueue.retryQueue = /* @__PURE__ */ new Set([wakeable]);
                  } else {
                    retryQueue.add(wakeable);
                  }
                }
                attachPingListener(root2, wakeable, rootRenderLanes);
              }
              return false;
            }
          }
        }
        throw new Error(
          `Unexpected Suspense handler tag (${suspenseBoundary.tag}). This is a bug in React.`
        );
      } else {
        if (disableLegacyMode || root2.tag === ConcurrentRoot) {
          attachPingListener(root2, wakeable, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        } else {
          const uncaughtSuspenseError = new Error(
            "A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition."
          );
          value = uncaughtSuspenseError;
        }
      }
    }
  }
  if (getIsHydrating() && (disableLegacyMode || sourceFiber.mode & ConcurrentMode)) {
    markDidThrowWhileHydratingDEV();
    const hydrationBoundary = getSuspenseHandler();
    if (hydrationBoundary !== null) {
      if ((hydrationBoundary.flags & ShouldCapture) === NoFlags) {
        hydrationBoundary.flags |= ForceClientRender;
      }
      markSuspenseBoundaryShouldCapture(
        hydrationBoundary,
        returnFiber,
        sourceFiber,
        root2,
        rootRenderLanes
      );
      if (value !== HydrationMismatchException) {
        const wrapperError2 = new Error(
          "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
          { cause: value }
        );
        queueHydrationError(
          createCapturedValueAtFiber(wrapperError2, sourceFiber)
        );
      }
      return false;
    } else {
      if (value !== HydrationMismatchException) {
        const wrapperError2 = new Error(
          "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
          { cause: value }
        );
        queueHydrationError(
          createCapturedValueAtFiber(wrapperError2, sourceFiber)
        );
      }
      const workInProgress3 = root2.current.alternate;
      workInProgress3.flags |= ShouldCapture;
      const lane = pickArbitraryLane(rootRenderLanes);
      workInProgress3.lanes = mergeLanes(workInProgress3.lanes, lane);
      const rootErrorInfo = createCapturedValueAtFiber(value, sourceFiber);
      const update = createRootErrorUpdate(
        workInProgress3.stateNode,
        rootErrorInfo,
        // This should never actually get logged due to the recovery.
        lane
      );
      enqueueCapturedUpdate(workInProgress3, update);
      renderDidError();
      return false;
    }
  } else {
  }
  const wrapperError = new Error(
    "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
    { cause: value }
  );
  queueConcurrentError(createCapturedValueAtFiber(wrapperError, sourceFiber));
  renderDidError();
  if (returnFiber === null) {
    return true;
  }
  const errorInfo = createCapturedValueAtFiber(value, sourceFiber);
  let workInProgress2 = returnFiber;
  do {
    switch (workInProgress2.tag) {
      case HostRoot: {
        workInProgress2.flags |= ShouldCapture;
        const lane = pickArbitraryLane(rootRenderLanes);
        workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
        const update = createRootErrorUpdate(
          workInProgress2.stateNode,
          errorInfo,
          lane
        );
        enqueueCapturedUpdate(workInProgress2, update);
        return false;
      }
      case ClassComponent:
        const ctor = workInProgress2.type;
        const instance = workInProgress2.stateNode;
        if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
          workInProgress2.flags |= ShouldCapture;
          const lane = pickArbitraryLane(rootRenderLanes);
          workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
          const update = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(update, root2, workInProgress2, errorInfo);
          enqueueCapturedUpdate(workInProgress2, update);
          return false;
        }
        break;
      default:
        break;
    }
    workInProgress2 = workInProgress2.return;
  } while (workInProgress2 !== null);
  return false;
}

// dist/react-reconciler/src/ReactFiberTracingMarkerComponent.js
var TransitionRoot = 0;
var TransitionTracingMarker = 1;
function processTransitionCallbacks(pendingTransitions, endTime, callbacks2) {
  if (enableTransitionTracing) {
    if (pendingTransitions !== null) {
      const transitionStart = pendingTransitions.transitionStart;
      const onTransitionStart = callbacks2.onTransitionStart;
      if (transitionStart !== null && onTransitionStart != null) {
        transitionStart.forEach((transition) => {
          if (transition.name != null) {
            onTransitionStart(transition.name, transition.startTime);
          }
        });
      }
      const markerProgress = pendingTransitions.markerProgress;
      const onMarkerProgress = callbacks2.onMarkerProgress;
      if (onMarkerProgress != null && markerProgress !== null) {
        markerProgress.forEach((markerInstance, markerName) => {
          if (markerInstance.transitions !== null) {
            const pending = markerInstance.pendingBoundaries !== null ? Array.from(markerInstance.pendingBoundaries.values()) : [];
            markerInstance.transitions.forEach((transition) => {
              if (transition.name != null) {
                onMarkerProgress(
                  transition.name,
                  markerName,
                  transition.startTime,
                  endTime,
                  pending
                );
              }
            });
          }
        });
      }
      const markerComplete = pendingTransitions.markerComplete;
      const onMarkerComplete = callbacks2.onMarkerComplete;
      if (markerComplete !== null && onMarkerComplete != null) {
        markerComplete.forEach((transitions, markerName) => {
          transitions.forEach((transition) => {
            if (transition.name != null) {
              onMarkerComplete(
                transition.name,
                markerName,
                transition.startTime,
                endTime
              );
            }
          });
        });
      }
      const markerIncomplete = pendingTransitions.markerIncomplete;
      const onMarkerIncomplete = callbacks2.onMarkerIncomplete;
      if (onMarkerIncomplete != null && markerIncomplete !== null) {
        markerIncomplete.forEach(({ transitions, aborts }, markerName) => {
          transitions.forEach((transition) => {
            const filteredAborts = [];
            aborts.forEach((abort) => {
              switch (abort.reason) {
                case "marker": {
                  filteredAborts.push({
                    type: "marker",
                    name: abort.name,
                    endTime
                  });
                  break;
                }
                case "suspense": {
                  filteredAborts.push({
                    type: "suspense",
                    name: abort.name,
                    endTime
                  });
                  break;
                }
                default: {
                  break;
                }
              }
            });
            if (filteredAborts.length > 0) {
              if (transition.name != null) {
                onMarkerIncomplete(
                  transition.name,
                  markerName,
                  transition.startTime,
                  filteredAborts
                );
              }
            }
          });
        });
      }
      const transitionProgress = pendingTransitions.transitionProgress;
      const onTransitionProgress = callbacks2.onTransitionProgress;
      if (onTransitionProgress != null && transitionProgress !== null) {
        transitionProgress.forEach((pending, transition) => {
          if (transition.name != null) {
            onTransitionProgress(
              transition.name,
              transition.startTime,
              endTime,
              Array.from(pending.values())
            );
          }
        });
      }
      const transitionComplete = pendingTransitions.transitionComplete;
      const onTransitionComplete = callbacks2.onTransitionComplete;
      if (transitionComplete !== null && onTransitionComplete != null) {
        transitionComplete.forEach((transition) => {
          if (transition.name != null) {
            onTransitionComplete(
              transition.name,
              transition.startTime,
              endTime
            );
          }
        });
      }
    }
  }
}
var markerInstanceStack = createCursor(null);
function pushRootMarkerInstance(workInProgress2) {
  if (enableTransitionTracing) {
    const transitions = getWorkInProgressTransitions();
    const root2 = workInProgress2.stateNode;
    if (transitions !== null) {
      transitions.forEach((transition) => {
        if (!root2.incompleteTransitions.has(transition)) {
          const markerInstance = {
            tag: TransitionRoot,
            transitions: /* @__PURE__ */ new Set([transition]),
            pendingBoundaries: null,
            aborts: null,
            name: null
          };
          root2.incompleteTransitions.set(transition, markerInstance);
        }
      });
    }
    const markerInstances = [];
    root2.incompleteTransitions.forEach((markerInstance) => {
      markerInstances.push(markerInstance);
    });
    push2(markerInstanceStack, markerInstances, workInProgress2);
  }
}
function popRootMarkerInstance(workInProgress2) {
  if (enableTransitionTracing) {
    pop2(markerInstanceStack, workInProgress2);
  }
}
function pushMarkerInstance(workInProgress2, markerInstance) {
  if (enableTransitionTracing) {
    if (markerInstanceStack.current === null) {
      push2(markerInstanceStack, [markerInstance], workInProgress2);
    } else {
      push2(
        markerInstanceStack,
        markerInstanceStack.current.concat(markerInstance),
        workInProgress2
      );
    }
  }
}
function popMarkerInstance(workInProgress2) {
  if (enableTransitionTracing) {
    pop2(markerInstanceStack, workInProgress2);
  }
}
function getMarkerInstances() {
  if (enableTransitionTracing) {
    return markerInstanceStack.current;
  }
  return null;
}

// dist/react-reconciler/src/ReactFiberBeginWork.js
var SelectiveHydrationException = new Error(
  "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
);
var didReceiveUpdate = false;
if (false) {
  didWarnAboutBadClass = {};
  didWarnAboutContextTypeOnFunctionComponent = {};
  didWarnAboutContextTypes = {};
  didWarnAboutGetDerivedStateOnFunctionComponent = {};
  didWarnAboutReassigningProps = false;
  didWarnAboutRevealOrder = {};
  didWarnAboutTailOptions = {};
  didWarnAboutDefaultPropsOnFunctionComponent = {};
  didWarnAboutClassNameOnViewTransition = {};
}
function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
  if (current2 === null) {
    workInProgress2.child = mountChildFibers(
      workInProgress2,
      null,
      nextChildren,
      renderLanes2
    );
  } else {
    workInProgress2.child = reconcileChildFibers(
      workInProgress2,
      current2.child,
      nextChildren,
      renderLanes2
    );
  }
}
function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
  workInProgress2.child = reconcileChildFibers(
    workInProgress2,
    current2.child,
    null,
    renderLanes2
  );
  workInProgress2.child = reconcileChildFibers(
    workInProgress2,
    null,
    nextChildren,
    renderLanes2
  );
}
function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
  const render = Component2.render;
  const ref = workInProgress2.ref;
  let propsWithoutRef;
  if ("ref" in nextProps) {
    propsWithoutRef = {};
    for (const key in nextProps) {
      if (key !== "ref") {
        propsWithoutRef[key] = nextProps[key];
      }
    }
  } else {
    propsWithoutRef = nextProps;
  }
  prepareToReadContext(workInProgress2, renderLanes2);
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress2);
  }
  const nextChildren = renderWithHooks(
    current2,
    workInProgress2,
    render,
    propsWithoutRef,
    ref,
    renderLanes2
  );
  const hasId = checkDidRenderIdHook();
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }
  if (current2 !== null && !didReceiveUpdate) {
    bailoutHooks(current2, workInProgress2, renderLanes2);
    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
  }
  if (getIsHydrating() && hasId) {
    pushMaterializedTreeId(workInProgress2);
  }
  workInProgress2.flags |= PerformedWork;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updateMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
  if (current2 === null) {
    const type = Component2.type;
    if (isSimpleFunctionComponent(type) && Component2.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
    (disableDefaultPropsExceptForClasses || Component2.defaultProps === void 0)) {
      let resolvedType = type;
      if (false) {
        resolvedType = resolveFunctionForHotReloading(type);
      }
      workInProgress2.tag = SimpleMemoComponent;
      workInProgress2.type = resolvedType;
      if (false) {
        validateFunctionComponentInDev(workInProgress2, type);
      }
      return updateSimpleMemoComponent(
        current2,
        workInProgress2,
        resolvedType,
        nextProps,
        renderLanes2
      );
    }
    if (!disableDefaultPropsExceptForClasses) {
      if (false) {
        if (Component2.defaultProps !== void 0) {
          const componentName = getComponentNameFromType(type) || "Unknown";
          if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
            console.error(
              "%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.",
              componentName
            );
            didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
          }
        }
      }
    }
    const child = createFiberFromTypeAndProps(
      Component2.type,
      null,
      nextProps,
      workInProgress2,
      workInProgress2.mode,
      renderLanes2
    );
    child.ref = workInProgress2.ref;
    child.return = workInProgress2;
    workInProgress2.child = child;
    return child;
  }
  const currentChild = current2.child;
  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
    current2,
    renderLanes2
  );
  if (!hasScheduledUpdateOrContext) {
    const prevProps = currentChild.memoizedProps;
    let compare2 = Component2.compare;
    compare2 = compare2 !== null ? compare2 : shallowEqual_default;
    if (compare2(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
      return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
    }
  }
  workInProgress2.flags |= PerformedWork;
  const newChild = createWorkInProgress(currentChild, nextProps);
  newChild.ref = workInProgress2.ref;
  newChild.return = workInProgress2;
  workInProgress2.child = newChild;
  return newChild;
}
function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
  if (current2 !== null) {
    const prevProps = current2.memoizedProps;
    if (shallowEqual_default(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
    (false ? workInProgress2.type === current2.type : true)) {
      didReceiveUpdate = false;
      workInProgress2.pendingProps = nextProps = prevProps;
      if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
        workInProgress2.lanes = current2.lanes;
        return bailoutOnAlreadyFinishedWork(
          current2,
          workInProgress2,
          renderLanes2
        );
      } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        didReceiveUpdate = true;
      }
    }
  }
  return updateFunctionComponent(
    current2,
    workInProgress2,
    Component2,
    nextProps,
    renderLanes2
  );
}
function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
  const nextChildren = nextProps.children;
  const prevState = current2 !== null ? current2.memoizedState : null;
  if (nextProps.mode === "hidden" || enableLegacyHidden && nextProps.mode === "unstable-defer-without-hiding") {
    const didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
    if (didSuspend) {
      const nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes2) : renderLanes2;
      if (current2 !== null) {
        let currentChild = workInProgress2.child = current2.child;
        let currentChildLanes = NoLanes;
        while (currentChild !== null) {
          currentChildLanes = mergeLanes(
            mergeLanes(currentChildLanes, currentChild.lanes),
            currentChild.childLanes
          );
          currentChild = currentChild.sibling;
        }
        const lanesWeJustAttempted = nextBaseLanes;
        const remainingChildLanes = removeLanes(
          currentChildLanes,
          lanesWeJustAttempted
        );
        workInProgress2.childLanes = remainingChildLanes;
      } else {
        workInProgress2.childLanes = NoLanes;
        workInProgress2.child = null;
      }
      return deferHiddenOffscreenComponent(
        current2,
        workInProgress2,
        nextBaseLanes,
        renderLanes2
      );
    }
    if (!disableLegacyMode && (workInProgress2.mode & ConcurrentMode) === NoMode) {
      const nextState = {
        baseLanes: NoLanes,
        cachePool: null
      };
      workInProgress2.memoizedState = nextState;
      if (current2 !== null) {
        pushTransition(workInProgress2, null, null);
      }
      reuseHiddenContextOnStack(workInProgress2);
      pushOffscreenSuspenseHandler(workInProgress2);
    } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
      workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
      const nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes2) : renderLanes2;
      return deferHiddenOffscreenComponent(
        current2,
        workInProgress2,
        nextBaseLanes,
        renderLanes2
      );
    } else {
      const nextState = {
        baseLanes: NoLanes,
        cachePool: null
      };
      workInProgress2.memoizedState = nextState;
      if (current2 !== null) {
        const prevCachePool = prevState !== null ? prevState.cachePool : null;
        pushTransition(workInProgress2, prevCachePool, null);
      }
      if (prevState !== null) {
        pushHiddenContext(workInProgress2, prevState);
      } else {
        reuseHiddenContextOnStack(workInProgress2);
      }
      pushOffscreenSuspenseHandler(workInProgress2);
    }
  } else {
    if (prevState !== null) {
      let prevCachePool = null;
      prevCachePool = prevState.cachePool;
      let transitions = null;
      if (enableTransitionTracing) {
        const instance = workInProgress2.stateNode;
        if (instance !== null && instance._transitions != null) {
          transitions = Array.from(instance._transitions);
        }
      }
      pushTransition(workInProgress2, prevCachePool, transitions);
      pushHiddenContext(workInProgress2, prevState);
      reuseSuspenseHandlerOnStack(workInProgress2);
      workInProgress2.memoizedState = null;
    } else {
      if (current2 !== null) {
        pushTransition(workInProgress2, null, null);
      }
      reuseHiddenContextOnStack(workInProgress2);
      reuseSuspenseHandlerOnStack(workInProgress2);
    }
  }
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2) {
  const nextState = {
    baseLanes: nextBaseLanes,
    // Save the cache pool so we can resume later.
    cachePool: getOffscreenDeferredCache()
  };
  workInProgress2.memoizedState = nextState;
  if (current2 !== null) {
    pushTransition(workInProgress2, null, null);
  }
  reuseHiddenContextOnStack(workInProgress2);
  pushOffscreenSuspenseHandler(workInProgress2);
  if (current2 !== null) {
    propagateParentContextChangesToDeferredTree(
      current2,
      workInProgress2,
      renderLanes2
    );
  }
  return null;
}
function updateLegacyHiddenComponent(current2, workInProgress2, renderLanes2) {
  const nextProps = workInProgress2.pendingProps;
  return updateOffscreenComponent(
    current2,
    workInProgress2,
    renderLanes2,
    nextProps
  );
}
function mountActivityChildren(workInProgress2, nextProps, renderLanes2) {
  if (false) {
    const hiddenProp = nextProps.hidden;
    if (hiddenProp !== void 0) {
      console.error(
        `<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`,
        hiddenProp === true ? "hidden" : hiddenProp === false ? "hidden={false}" : "hidden={...}",
        hiddenProp ? 'mode="hidden"' : 'mode="visible"'
      );
    }
  }
  const nextChildren = nextProps.children;
  const nextMode = nextProps.mode;
  const mode = workInProgress2.mode;
  const offscreenChildProps = {
    mode: nextMode,
    children: nextChildren
  };
  const primaryChildFragment = mountWorkInProgressOffscreenFiber(
    offscreenChildProps,
    mode,
    renderLanes2
  );
  primaryChildFragment.ref = workInProgress2.ref;
  workInProgress2.child = primaryChildFragment;
  primaryChildFragment.return = workInProgress2;
  return primaryChildFragment;
}
function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
  reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
  const nextProps = workInProgress2.pendingProps;
  const primaryChildFragment = mountActivityChildren(
    workInProgress2,
    nextProps,
    renderLanes2
  );
  primaryChildFragment.flags |= Placement;
  popSuspenseHandler(workInProgress2);
  workInProgress2.memoizedState = null;
  return primaryChildFragment;
}
function mountDehydratedActivityComponent(workInProgress2, activityInstance, renderLanes2) {
  workInProgress2.lanes = laneToLanes(OffscreenLane);
  return null;
}
function updateDehydratedActivityComponent(current2, workInProgress2, didSuspend, nextProps, activityInstance, activityState, renderLanes2) {
  pushDehydratedActivitySuspenseHandler(workInProgress2);
  if (!didSuspend) {
    warnIfHydrating();
    if (
      // TODO: Factoring is a little weird, since we check this right below, too.
      !didReceiveUpdate
    ) {
      lazilyPropagateParentContextChanges(current2, workInProgress2, renderLanes2);
    }
    const hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
    if (didReceiveUpdate || hasContextChanged2) {
      const root2 = getWorkInProgressRoot();
      if (root2 !== null) {
        const attemptHydrationAtLane = getBumpedLaneForHydration(
          root2,
          renderLanes2
        );
        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== activityState.retryLane) {
          activityState.retryLane = attemptHydrationAtLane;
          enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
          scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane);
          throw SelectiveHydrationException;
        } else {
        }
      }
      renderDidSuspendDelayIfPossible();
      return retryActivityComponentWithoutHydrating(
        current2,
        workInProgress2,
        renderLanes2
      );
    } else {
      reenterHydrationStateFromDehydratedActivityInstance(
        workInProgress2,
        activityInstance,
        activityState.treeContext
      );
      const primaryChildFragment = mountActivityChildren(
        workInProgress2,
        nextProps,
        renderLanes2
      );
      primaryChildFragment.flags |= Hydrating;
      return primaryChildFragment;
    }
  } else {
    if (workInProgress2.flags & ForceClientRender) {
      workInProgress2.flags &= ~ForceClientRender;
      return retryActivityComponentWithoutHydrating(
        current2,
        workInProgress2,
        renderLanes2
      );
    } else if (workInProgress2.memoizedState !== null) {
      workInProgress2.child = current2.child;
      workInProgress2.flags |= DidCapture;
      return null;
    } else {
      throw new Error(
        "Client rendering an Activity suspended it again. This is a bug in React."
      );
    }
  }
}
function updateActivityComponent(current2, workInProgress2, renderLanes2) {
  const nextProps = workInProgress2.pendingProps;
  const didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
  workInProgress2.flags &= ~DidCapture;
  if (current2 === null) {
    if (getIsHydrating()) {
      if (nextProps.mode === "hidden") {
        mountActivityChildren(workInProgress2, nextProps, renderLanes2);
        workInProgress2.lanes = laneToLanes(OffscreenLane);
        return null;
      } else {
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        const dehydrated = claimNextHydratableActivityInstance(workInProgress2);
        return mountDehydratedActivityComponent(
          workInProgress2,
          dehydrated,
          renderLanes2
        );
      }
    }
    return mountActivityChildren(workInProgress2, nextProps, renderLanes2);
  } else {
    const prevState = current2.memoizedState;
    if (prevState !== null) {
      const dehydrated = prevState.dehydrated;
      return updateDehydratedActivityComponent(
        current2,
        workInProgress2,
        didSuspend,
        nextProps,
        dehydrated,
        prevState,
        renderLanes2
      );
    }
    const currentChild = current2.child;
    const nextChildren = nextProps.children;
    const nextMode = nextProps.mode;
    const offscreenChildProps = {
      mode: nextMode,
      children: nextChildren
    };
    const primaryChildFragment = updateWorkInProgressOffscreenFiber(
      currentChild,
      offscreenChildProps
    );
    primaryChildFragment.ref = workInProgress2.ref;
    workInProgress2.child = primaryChildFragment;
    primaryChildFragment.return = workInProgress2;
    return primaryChildFragment;
  }
}
function updateCacheComponent(current2, workInProgress2, renderLanes2) {
  prepareToReadContext(workInProgress2, renderLanes2);
  const parentCache = readContext(CacheContext);
  if (current2 === null) {
    const freshCache = requestCacheFromPool(renderLanes2);
    const initialState = {
      parent: parentCache,
      cache: freshCache
    };
    workInProgress2.memoizedState = initialState;
    initializeUpdateQueue(workInProgress2);
    pushCacheProvider(workInProgress2, freshCache);
  } else {
    if (includesSomeLane(current2.lanes, renderLanes2)) {
      cloneUpdateQueue(current2, workInProgress2);
      processUpdateQueue(workInProgress2, null, null, renderLanes2);
      suspendIfUpdateReadFromEntangledAsyncAction();
    }
    const prevState = current2.memoizedState;
    const nextState = workInProgress2.memoizedState;
    if (prevState.parent !== parentCache) {
      const derivedState = {
        parent: parentCache,
        cache: parentCache
      };
      workInProgress2.memoizedState = derivedState;
      if (workInProgress2.lanes === NoLanes) {
        const updateQueue = workInProgress2.updateQueue;
        workInProgress2.memoizedState = updateQueue.baseState = derivedState;
      }
      pushCacheProvider(workInProgress2, parentCache);
    } else {
      const nextCache = nextState.cache;
      pushCacheProvider(workInProgress2, nextCache);
      if (nextCache !== prevState.cache) {
        propagateContextChange(workInProgress2, CacheContext, renderLanes2);
      }
    }
  }
  const nextProps = workInProgress2.pendingProps;
  const nextChildren = nextProps.children;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updateTracingMarkerComponent(current2, workInProgress2, renderLanes2) {
  if (!enableTransitionTracing) {
    return null;
  }
  const nextProps = workInProgress2.pendingProps;
  if (current2 === null) {
    const currentTransitions = getPendingTransitions();
    if (currentTransitions !== null) {
      const markerInstance = {
        tag: TransitionTracingMarker,
        transitions: new Set(currentTransitions),
        pendingBoundaries: null,
        name: nextProps.name,
        aborts: null
      };
      workInProgress2.stateNode = markerInstance;
      workInProgress2.flags |= Passive;
    }
  } else {
    if (false) {
      if (current2.memoizedProps.name !== nextProps.name) {
        console.error(
          "Changing the name of a tracing marker after mount is not supported. To remount the tracing marker, pass it a new key."
        );
      }
    }
  }
  const instance = workInProgress2.stateNode;
  if (instance !== null) {
    pushMarkerInstance(workInProgress2, instance);
  }
  const nextChildren = nextProps.children;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updateFragment(current2, workInProgress2, renderLanes2) {
  const nextChildren = workInProgress2.pendingProps;
  if (enableFragmentRefs) {
    markRef(current2, workInProgress2);
  }
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updateMode(current2, workInProgress2, renderLanes2) {
  const nextChildren = workInProgress2.pendingProps.children;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updateProfiler(current2, workInProgress2, renderLanes2) {
  if (enableProfilerTimer) {
    workInProgress2.flags |= Update;
    if (enableProfilerCommitHooks) {
      workInProgress2.flags |= Passive;
      const stateNode = workInProgress2.stateNode;
      stateNode.effectDuration = -0;
      stateNode.passiveEffectDuration = -0;
    }
  }
  const nextProps = workInProgress2.pendingProps;
  const nextChildren = nextProps.children;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function markRef(current2, workInProgress2) {
  const ref = workInProgress2.ref;
  if (ref === null) {
    if (current2 !== null && current2.ref !== null) {
      workInProgress2.flags |= Ref | RefStatic;
    }
  } else {
    if (typeof ref !== "function" && typeof ref !== "object") {
      throw new Error(
        "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
      );
    }
    if (current2 === null || current2.ref !== ref) {
      workInProgress2.flags |= Ref | RefStatic;
    }
  }
}
function mountIncompleteFunctionComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
  workInProgress2.tag = FunctionComponent;
  return updateFunctionComponent(
    null,
    workInProgress2,
    Component2,
    nextProps,
    renderLanes2
  );
}
function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
  if (false) {
    if (Component2.prototype && typeof Component2.prototype.render === "function") {
      const componentName = getComponentNameFromType(Component2) || "Unknown";
      if (!didWarnAboutBadClass[componentName]) {
        console.error(
          "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
          componentName,
          componentName
        );
        didWarnAboutBadClass[componentName] = true;
      }
    }
    if (workInProgress2.mode & StrictLegacyMode) {
      ReactStrictModeWarnings_default.recordLegacyContextWarning(workInProgress2, null);
    }
    if (current2 === null) {
      validateFunctionComponentInDev(workInProgress2, workInProgress2.type);
      if (Component2.contextTypes) {
        const componentName = getComponentNameFromType(Component2) || "Unknown";
        if (!didWarnAboutContextTypes[componentName]) {
          didWarnAboutContextTypes[componentName] = true;
          if (disableLegacyContext) {
            console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
              componentName
            );
          } else {
            console.error(
              "%s uses the legacy contextTypes API which will be removed soon. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
              componentName
            );
          }
        }
      }
    }
  }
  let context;
  if (!disableLegacyContext && !disableLegacyContextForFunctionComponents) {
    const unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
    context = getMaskedContext(workInProgress2, unmaskedContext);
  }
  let nextChildren;
  let hasId;
  prepareToReadContext(workInProgress2, renderLanes2);
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress2);
  }
  if (false) {
    nextChildren = renderWithHooks(
      current2,
      workInProgress2,
      Component2,
      nextProps,
      context,
      renderLanes2
    );
    hasId = checkDidRenderIdHook();
  } else {
    nextChildren = renderWithHooks(
      current2,
      workInProgress2,
      Component2,
      nextProps,
      context,
      renderLanes2
    );
    hasId = checkDidRenderIdHook();
  }
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }
  if (current2 !== null && !didReceiveUpdate) {
    bailoutHooks(current2, workInProgress2, renderLanes2);
    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
  }
  if (getIsHydrating() && hasId) {
    pushMaterializedTreeId(workInProgress2);
  }
  workInProgress2.flags |= PerformedWork;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function replayFunctionComponent(current2, workInProgress2, nextProps, Component2, secondArg, renderLanes2) {
  prepareToReadContext(workInProgress2, renderLanes2);
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress2);
  }
  const nextChildren = replaySuspendedComponentWithHooks(
    current2,
    workInProgress2,
    Component2,
    nextProps,
    secondArg
  );
  const hasId = checkDidRenderIdHook();
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }
  if (current2 !== null && !didReceiveUpdate) {
    bailoutHooks(current2, workInProgress2, renderLanes2);
    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
  }
  if (getIsHydrating() && hasId) {
    pushMaterializedTreeId(workInProgress2);
  }
  workInProgress2.flags |= PerformedWork;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
  if (false) {
    switch (shouldError(workInProgress2)) {
      case false: {
        const instance2 = workInProgress2.stateNode;
        const ctor = workInProgress2.type;
        const tempInstance = new ctor(
          workInProgress2.memoizedProps,
          instance2.context
        );
        const state = tempInstance.state;
        instance2.updater.enqueueSetState(instance2, state, null);
        break;
      }
      case true: {
        workInProgress2.flags |= DidCapture;
        workInProgress2.flags |= ShouldCapture;
        const error = new Error("Simulated error coming from DevTools");
        const lane = pickArbitraryLane(renderLanes2);
        workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
        const root2 = getWorkInProgressRoot();
        if (root2 === null) {
          throw new Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        }
        const update = createClassErrorUpdate(lane);
        initializeClassErrorUpdate(
          update,
          root2,
          workInProgress2,
          createCapturedValueAtFiber(error, workInProgress2)
        );
        enqueueCapturedUpdate(workInProgress2, update);
        break;
      }
    }
  }
  let hasContext;
  if (isContextProvider(Component2)) {
    hasContext = true;
    pushContextProvider(workInProgress2);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress2, renderLanes2);
  const instance = workInProgress2.stateNode;
  let shouldUpdate;
  if (instance === null) {
    resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
    constructClassInstance(workInProgress2, Component2, nextProps);
    mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
    shouldUpdate = true;
  } else if (current2 === null) {
    shouldUpdate = resumeMountClassInstance(
      workInProgress2,
      Component2,
      nextProps,
      renderLanes2
    );
  } else {
    shouldUpdate = updateClassInstance(
      current2,
      workInProgress2,
      Component2,
      nextProps,
      renderLanes2
    );
  }
  const nextUnitOfWork = finishClassComponent(
    current2,
    workInProgress2,
    Component2,
    shouldUpdate,
    hasContext,
    renderLanes2
  );
  if (false) {
    const inst = workInProgress2.stateNode;
    if (shouldUpdate && inst.props !== nextProps) {
      if (!didWarnAboutReassigningProps) {
        console.error(
          "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
          getComponentNameFromFiber(workInProgress2) || "a component"
        );
      }
      didWarnAboutReassigningProps = true;
    }
  }
  return nextUnitOfWork;
}
function finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
  markRef(current2, workInProgress2);
  const didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
  if (!shouldUpdate && !didCaptureError) {
    if (hasContext) {
      invalidateContextProvider(workInProgress2, Component2, false);
    }
    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
  }
  const instance = workInProgress2.stateNode;
  if (false) {
    setCurrentFiber(workInProgress2);
  }
  let nextChildren;
  if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
    nextChildren = null;
    if (enableProfilerTimer) {
      stopProfilerTimerIfRunning(workInProgress2);
    }
  } else {
    if (enableSchedulingProfiler) {
      markComponentRenderStarted(workInProgress2);
    }
    if (false) {
      nextChildren = callRenderInDEV(instance);
      if (workInProgress2.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(true);
        try {
          callRenderInDEV(instance);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
    } else {
      nextChildren = instance.render();
    }
    if (enableSchedulingProfiler) {
      markComponentRenderStopped();
    }
  }
  workInProgress2.flags |= PerformedWork;
  if (current2 !== null && didCaptureError) {
    forceUnmountCurrentAndReconcile(
      current2,
      workInProgress2,
      nextChildren,
      renderLanes2
    );
  } else {
    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  }
  workInProgress2.memoizedState = instance.state;
  if (hasContext) {
    invalidateContextProvider(workInProgress2, Component2, true);
  }
  return workInProgress2.child;
}
function pushHostRootContext(workInProgress2) {
  const root2 = workInProgress2.stateNode;
  if (root2.pendingContext) {
    pushTopLevelContextObject(
      workInProgress2,
      root2.pendingContext,
      root2.pendingContext !== root2.context
    );
  } else if (root2.context) {
    pushTopLevelContextObject(workInProgress2, root2.context, false);
  }
  pushHostContainer(workInProgress2, root2.containerInfo);
}
function updateHostRoot(current2, workInProgress2, renderLanes2) {
  pushHostRootContext(workInProgress2);
  if (current2 === null) {
    throw new Error("Should have a current fiber. This is a bug in React.");
  }
  const nextProps = workInProgress2.pendingProps;
  const prevState = workInProgress2.memoizedState;
  const prevChildren = prevState.element;
  cloneUpdateQueue(current2, workInProgress2);
  processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
  const nextState = workInProgress2.memoizedState;
  const root2 = workInProgress2.stateNode;
  pushRootTransition(workInProgress2, root2, renderLanes2);
  if (enableTransitionTracing) {
    pushRootMarkerInstance(workInProgress2);
  }
  const nextCache = nextState.cache;
  pushCacheProvider(workInProgress2, nextCache);
  if (nextCache !== prevState.cache) {
    propagateContextChange(workInProgress2, CacheContext, renderLanes2);
  }
  suspendIfUpdateReadFromEntangledAsyncAction();
  const nextChildren = nextState.element;
  if (void 0 && prevState.isDehydrated) {
    const overrideState = {
      element: nextChildren,
      isDehydrated: false,
      cache: nextState.cache
    };
    const updateQueue = workInProgress2.updateQueue;
    updateQueue.baseState = overrideState;
    workInProgress2.memoizedState = overrideState;
    if (workInProgress2.flags & ForceClientRender) {
      return mountHostRootWithoutHydrating(
        current2,
        workInProgress2,
        nextChildren,
        renderLanes2
      );
    } else if (nextChildren !== prevChildren) {
      const recoverableError = createCapturedValueAtFiber(
        new Error(
          "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
        ),
        workInProgress2
      );
      queueHydrationError(recoverableError);
      return mountHostRootWithoutHydrating(
        current2,
        workInProgress2,
        nextChildren,
        renderLanes2
      );
    } else {
      enterHydrationState(workInProgress2);
      const child = mountChildFibers(
        workInProgress2,
        null,
        nextChildren,
        renderLanes2
      );
      workInProgress2.child = child;
      let node = child;
      while (node) {
        node.flags = node.flags & ~Placement | Hydrating;
        node = node.sibling;
      }
    }
  } else {
    resetHydrationState();
    if (nextChildren === prevChildren) {
      return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
    }
    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  }
  return workInProgress2.child;
}
function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
  resetHydrationState();
  workInProgress2.flags |= ForceClientRender;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updateHostComponent(current2, workInProgress2, renderLanes2) {
  if (current2 === null) {
    tryToClaimNextHydratableInstance(workInProgress2);
  }
  pushHostContext(workInProgress2);
  const type = workInProgress2.type;
  const nextProps = workInProgress2.pendingProps;
  const prevProps = current2 !== null ? current2.memoizedProps : null;
  let nextChildren = nextProps.children;
  const isDirectTextChild = (void 0)(type, nextProps);
  if (isDirectTextChild) {
    nextChildren = null;
  } else if (prevProps !== null && (void 0)(type, prevProps)) {
    workInProgress2.flags |= ContentReset;
  }
  const memoizedState = workInProgress2.memoizedState;
  if (memoizedState !== null) {
    const newState = renderTransitionAwareHostComponentWithHooks(
      current2,
      workInProgress2,
      renderLanes2
    );
    if (void 0) {
      (void 0)._currentValue = newState;
    } else {
      (void 0)._currentValue2 = newState;
    }
  }
  markRef(current2, workInProgress2);
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updateHostHoistable(current2, workInProgress2, renderLanes2) {
  markRef(current2, workInProgress2);
  if (current2 === null) {
    const resource = (void 0)(
      workInProgress2.type,
      null,
      workInProgress2.pendingProps,
      null
    );
    if (resource) {
      workInProgress2.memoizedState = resource;
    } else {
      if (!getIsHydrating()) {
        workInProgress2.stateNode = (void 0)(
          workInProgress2.type,
          workInProgress2.pendingProps,
          getRootHostContainer(),
          workInProgress2
        );
      }
    }
  } else {
    workInProgress2.memoizedState = (void 0)(
      workInProgress2.type,
      current2.memoizedProps,
      workInProgress2.pendingProps,
      current2.memoizedState
    );
  }
  return null;
}
function updateHostSingleton(current2, workInProgress2, renderLanes2) {
  pushHostContext(workInProgress2);
  if (current2 === null) {
    claimHydratableSingleton(workInProgress2);
  }
  const nextChildren = workInProgress2.pendingProps.children;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  markRef(current2, workInProgress2);
  if (current2 === null) {
    workInProgress2.flags |= LayoutStatic;
  }
  return workInProgress2.child;
}
function updateHostText(current2, workInProgress2) {
  if (current2 === null) {
    tryToClaimNextHydratableTextInstance(workInProgress2);
  }
  return null;
}
function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
  const props = workInProgress2.pendingProps;
  const lazyComponent = elementType;
  let Component2;
  if (false) {
    Component2 = callLazyInitInDEV(lazyComponent);
  } else {
    const payload = lazyComponent._payload;
    const init = lazyComponent._init;
    Component2 = init(payload);
  }
  workInProgress2.type = Component2;
  if (typeof Component2 === "function") {
    if (isFunctionClassComponent(Component2)) {
      const resolvedProps = resolveClassComponentProps(Component2, props, false);
      workInProgress2.tag = ClassComponent;
      if (false) {
        workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
      }
      return updateClassComponent(
        null,
        workInProgress2,
        Component2,
        resolvedProps,
        renderLanes2
      );
    } else {
      const resolvedProps = disableDefaultPropsExceptForClasses ? props : resolveDefaultPropsOnNonClassComponent(Component2, props);
      workInProgress2.tag = FunctionComponent;
      if (false) {
        validateFunctionComponentInDev(workInProgress2, Component2);
        workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
      }
      return updateFunctionComponent(
        null,
        workInProgress2,
        Component2,
        resolvedProps,
        renderLanes2
      );
    }
  } else if (Component2 !== void 0 && Component2 !== null) {
    const $$typeof = Component2.$$typeof;
    if ($$typeof === REACT_FORWARD_REF_TYPE) {
      const resolvedProps = disableDefaultPropsExceptForClasses ? props : resolveDefaultPropsOnNonClassComponent(Component2, props);
      workInProgress2.tag = ForwardRef;
      if (false) {
        workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
      }
      return updateForwardRef(
        null,
        workInProgress2,
        Component2,
        resolvedProps,
        renderLanes2
      );
    } else if ($$typeof === REACT_MEMO_TYPE) {
      const resolvedProps = disableDefaultPropsExceptForClasses ? props : resolveDefaultPropsOnNonClassComponent(Component2, props);
      workInProgress2.tag = MemoComponent;
      return updateMemoComponent(
        null,
        workInProgress2,
        Component2,
        disableDefaultPropsExceptForClasses ? resolvedProps : resolveDefaultPropsOnNonClassComponent(
          Component2.type,
          resolvedProps
        ),
        // The inner type can have defaults too
        renderLanes2
      );
    }
  }
  let hint = "";
  if (false) {
    if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE) {
      hint = " Did you wrap a component in React.lazy() more than once?";
    }
  }
  const loggedComponent = getComponentNameFromType(Component2) || Component2;
  throw new Error(
    `Element type is invalid. Received a promise that resolves to: ${loggedComponent}. Lazy element type must resolve to a class or function.${hint}`
  );
}
function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
  workInProgress2.tag = ClassComponent;
  let hasContext;
  if (isContextProvider(Component2)) {
    hasContext = true;
    pushContextProvider(workInProgress2);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress2, renderLanes2);
  constructClassInstance(workInProgress2, Component2, nextProps);
  mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
  return finishClassComponent(
    null,
    workInProgress2,
    Component2,
    true,
    hasContext,
    renderLanes2
  );
}
var SUSPENDED_MARKER = {
  dehydrated: null,
  treeContext: null,
  retryLane: NoLane,
  hydrationErrors: null
};
function mountSuspenseOffscreenState(renderLanes2) {
  return {
    baseLanes: renderLanes2,
    cachePool: getSuspendedCache()
  };
}
function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
  let cachePool = null;
  const prevCachePool = prevOffscreenState.cachePool;
  if (prevCachePool !== null) {
    const parentCache = void 0 ? CacheContext._currentValue : CacheContext._currentValue2;
    if (prevCachePool.parent !== parentCache) {
      cachePool = {
        parent: parentCache,
        pool: parentCache
      };
    } else {
      cachePool = prevCachePool;
    }
  } else {
    cachePool = getSuspendedCache();
  }
  return {
    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
    cachePool
  };
}
function shouldRemainOnFallback(current2, workInProgress2, renderLanes2) {
  if (current2 !== null) {
    const suspenseState = current2.memoizedState;
    if (suspenseState === null) {
      return false;
    }
  }
  const suspenseContext = suspenseStackCursor.current;
  return hasSuspenseListContext(
    suspenseContext,
    ForceSuspenseFallback
  );
}
function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
  let remainingLanes = current2 !== null ? removeLanes(current2.childLanes, renderLanes2) : NoLanes;
  if (primaryTreeDidDefer) {
    remainingLanes = mergeLanes(remainingLanes, peekDeferredLane());
  }
  return remainingLanes;
}
function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
  const nextProps = workInProgress2.pendingProps;
  if (false) {
    if (shouldSuspend(workInProgress2)) {
      workInProgress2.flags |= DidCapture;
    }
  }
  let showFallback = false;
  const didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
  if (didSuspend || shouldRemainOnFallback(current2, workInProgress2, renderLanes2)) {
    showFallback = true;
    workInProgress2.flags &= ~DidCapture;
  }
  const didPrimaryChildrenDefer = (workInProgress2.flags & DidDefer) !== NoFlags;
  workInProgress2.flags &= ~DidDefer;
  if (current2 === null) {
    if (getIsHydrating()) {
      if (showFallback) {
        pushPrimaryTreeSuspenseHandler(workInProgress2);
      } else {
        pushFallbackTreeSuspenseHandler(workInProgress2);
      }
      const dehydrated = claimNextHydratableSuspenseInstance(workInProgress2);
      return mountDehydratedSuspenseComponent(
        workInProgress2,
        dehydrated,
        renderLanes2
      );
    }
    const nextPrimaryChildren = nextProps.children;
    const nextFallbackChildren = nextProps.fallback;
    if (showFallback) {
      pushFallbackTreeSuspenseHandler(workInProgress2);
      const fallbackFragment = mountSuspenseFallbackChildren(
        workInProgress2,
        nextPrimaryChildren,
        nextFallbackChildren,
        renderLanes2
      );
      const primaryChildFragment = workInProgress2.child;
      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
      primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(
        current2,
        didPrimaryChildrenDefer,
        renderLanes2
      );
      workInProgress2.memoizedState = SUSPENDED_MARKER;
      if (enableTransitionTracing) {
        const currentTransitions = getPendingTransitions();
        if (currentTransitions !== null) {
          const parentMarkerInstances = getMarkerInstances();
          const offscreenQueue = primaryChildFragment.updateQueue;
          if (offscreenQueue === null) {
            const newOffscreenQueue = {
              transitions: currentTransitions,
              markerInstances: parentMarkerInstances,
              retryQueue: null
            };
            primaryChildFragment.updateQueue = newOffscreenQueue;
          } else {
            offscreenQueue.transitions = currentTransitions;
            offscreenQueue.markerInstances = parentMarkerInstances;
          }
        }
      }
      return fallbackFragment;
    } else if (enableCPUSuspense && typeof nextProps.unstable_expectedLoadTime === "number") {
      pushFallbackTreeSuspenseHandler(workInProgress2);
      const fallbackFragment = mountSuspenseFallbackChildren(
        workInProgress2,
        nextPrimaryChildren,
        nextFallbackChildren,
        renderLanes2
      );
      const primaryChildFragment = workInProgress2.child;
      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
      primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(
        current2,
        didPrimaryChildrenDefer,
        renderLanes2
      );
      workInProgress2.memoizedState = SUSPENDED_MARKER;
      workInProgress2.lanes = SomeRetryLane;
      return fallbackFragment;
    } else {
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      return mountSuspensePrimaryChildren(
        workInProgress2,
        nextPrimaryChildren,
        renderLanes2
      );
    }
  } else {
    const prevState = current2.memoizedState;
    if (prevState !== null) {
      const dehydrated = prevState.dehydrated;
      if (dehydrated !== null) {
        return updateDehydratedSuspenseComponent(
          current2,
          workInProgress2,
          didSuspend,
          didPrimaryChildrenDefer,
          nextProps,
          dehydrated,
          prevState,
          renderLanes2
        );
      }
    }
    if (showFallback) {
      pushFallbackTreeSuspenseHandler(workInProgress2);
      const nextFallbackChildren = nextProps.fallback;
      const nextPrimaryChildren = nextProps.children;
      const fallbackChildFragment = updateSuspenseFallbackChildren(
        current2,
        workInProgress2,
        nextPrimaryChildren,
        nextFallbackChildren,
        renderLanes2
      );
      const primaryChildFragment = workInProgress2.child;
      const prevOffscreenState = current2.child.memoizedState;
      primaryChildFragment.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
      if (enableTransitionTracing) {
        const currentTransitions = getPendingTransitions();
        if (currentTransitions !== null) {
          const parentMarkerInstances = getMarkerInstances();
          const offscreenQueue = primaryChildFragment.updateQueue;
          const currentOffscreenQueue = current2.updateQueue;
          if (offscreenQueue === null) {
            const newOffscreenQueue = {
              transitions: currentTransitions,
              markerInstances: parentMarkerInstances,
              retryQueue: null
            };
            primaryChildFragment.updateQueue = newOffscreenQueue;
          } else if (offscreenQueue === currentOffscreenQueue) {
            const newOffscreenQueue = {
              transitions: currentTransitions,
              markerInstances: parentMarkerInstances,
              retryQueue: currentOffscreenQueue !== null ? currentOffscreenQueue.retryQueue : null
            };
            primaryChildFragment.updateQueue = newOffscreenQueue;
          } else {
            offscreenQueue.transitions = currentTransitions;
            offscreenQueue.markerInstances = parentMarkerInstances;
          }
        }
      }
      primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(
        current2,
        didPrimaryChildrenDefer,
        renderLanes2
      );
      workInProgress2.memoizedState = SUSPENDED_MARKER;
      return fallbackChildFragment;
    } else {
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      const nextPrimaryChildren = nextProps.children;
      const primaryChildFragment = updateSuspensePrimaryChildren(
        current2,
        workInProgress2,
        nextPrimaryChildren,
        renderLanes2
      );
      workInProgress2.memoizedState = null;
      return primaryChildFragment;
    }
  }
}
function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
  const mode = workInProgress2.mode;
  const primaryChildProps = {
    mode: "visible",
    children: primaryChildren
  };
  const primaryChildFragment = mountWorkInProgressOffscreenFiber(
    primaryChildProps,
    mode,
    renderLanes2
  );
  primaryChildFragment.return = workInProgress2;
  workInProgress2.child = primaryChildFragment;
  return primaryChildFragment;
}
function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
  const mode = workInProgress2.mode;
  const progressedPrimaryFragment = workInProgress2.child;
  const primaryChildProps = {
    mode: "hidden",
    children: primaryChildren
  };
  let primaryChildFragment;
  let fallbackChildFragment;
  if (!disableLegacyMode && (mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;
    if (enableProfilerTimer && workInProgress2.mode & ProfileMode) {
      primaryChildFragment.actualDuration = -0;
      primaryChildFragment.actualStartTime = -1.1;
      primaryChildFragment.selfBaseDuration = -0;
      primaryChildFragment.treeBaseDuration = -0;
    }
    fallbackChildFragment = createFiberFromFragment(
      fallbackChildren,
      mode,
      renderLanes2,
      null
    );
  } else {
    primaryChildFragment = mountWorkInProgressOffscreenFiber(
      primaryChildProps,
      mode,
      NoLanes
    );
    fallbackChildFragment = createFiberFromFragment(
      fallbackChildren,
      mode,
      renderLanes2,
      null
    );
  }
  primaryChildFragment.return = workInProgress2;
  fallbackChildFragment.return = workInProgress2;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress2.child = primaryChildFragment;
  return fallbackChildFragment;
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
}
function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
  return createWorkInProgress(current2, offscreenProps);
}
function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
  const currentPrimaryChildFragment = current2.child;
  const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  const primaryChildFragment = updateWorkInProgressOffscreenFiber(
    currentPrimaryChildFragment,
    {
      mode: "visible",
      children: primaryChildren
    }
  );
  if (!disableLegacyMode && (workInProgress2.mode & ConcurrentMode) === NoMode) {
    primaryChildFragment.lanes = renderLanes2;
  }
  primaryChildFragment.return = workInProgress2;
  primaryChildFragment.sibling = null;
  if (currentFallbackChildFragment !== null) {
    const deletions = workInProgress2.deletions;
    if (deletions === null) {
      workInProgress2.deletions = [currentFallbackChildFragment];
      workInProgress2.flags |= ChildDeletion;
    } else {
      deletions.push(currentFallbackChildFragment);
    }
  }
  workInProgress2.child = primaryChildFragment;
  return primaryChildFragment;
}
function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
  const mode = workInProgress2.mode;
  const currentPrimaryChildFragment = current2.child;
  const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  const primaryChildProps = {
    mode: "hidden",
    children: primaryChildren
  };
  let primaryChildFragment;
  if (
    // In legacy mode, we commit the primary tree as if it successfully
    // completed, even though it's in an inconsistent state.
    !disableLegacyMode && (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
    // already cloned. In legacy mode, the only case where this isn't true is
    // when DevTools forces us to display a fallback; we skip the first render
    // pass entirely and go straight to rendering the fallback. (In Concurrent
    // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
    // only codepath.)
    workInProgress2.child !== currentPrimaryChildFragment
  ) {
    const progressedPrimaryFragment = workInProgress2.child;
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;
    if (enableProfilerTimer && workInProgress2.mode & ProfileMode) {
      primaryChildFragment.actualDuration = -0;
      primaryChildFragment.actualStartTime = -1.1;
      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
    }
    workInProgress2.deletions = null;
  } else {
    primaryChildFragment = updateWorkInProgressOffscreenFiber(
      currentPrimaryChildFragment,
      primaryChildProps
    );
    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
  }
  let fallbackChildFragment;
  if (currentFallbackChildFragment !== null) {
    fallbackChildFragment = createWorkInProgress(
      currentFallbackChildFragment,
      fallbackChildren
    );
  } else {
    fallbackChildFragment = createFiberFromFragment(
      fallbackChildren,
      mode,
      renderLanes2,
      null
    );
    fallbackChildFragment.flags |= Placement;
  }
  fallbackChildFragment.return = workInProgress2;
  primaryChildFragment.return = workInProgress2;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress2.child = primaryChildFragment;
  return fallbackChildFragment;
}
function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
  reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
  const nextProps = workInProgress2.pendingProps;
  const primaryChildren = nextProps.children;
  const primaryChildFragment = mountSuspensePrimaryChildren(
    workInProgress2,
    primaryChildren,
    renderLanes2
  );
  primaryChildFragment.flags |= Placement;
  workInProgress2.memoizedState = null;
  return primaryChildFragment;
}
function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
  const fiberMode = workInProgress2.mode;
  const primaryChildProps = {
    mode: "visible",
    children: primaryChildren
  };
  const primaryChildFragment = mountWorkInProgressOffscreenFiber(
    primaryChildProps,
    fiberMode,
    NoLanes
  );
  const fallbackChildFragment = createFiberFromFragment(
    fallbackChildren,
    fiberMode,
    renderLanes2,
    null
  );
  fallbackChildFragment.flags |= Placement;
  primaryChildFragment.return = workInProgress2;
  fallbackChildFragment.return = workInProgress2;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress2.child = primaryChildFragment;
  if (disableLegacyMode || (workInProgress2.mode & ConcurrentMode) !== NoMode) {
    reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
  }
  return fallbackChildFragment;
}
function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
  if ((void 0)(suspenseInstance)) {
    workInProgress2.lanes = laneToLanes(
      enableHydrationLaneScheduling ? DefaultLane : DefaultHydrationLane
    );
  } else {
    workInProgress2.lanes = laneToLanes(OffscreenLane);
  }
  return null;
}
function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, didPrimaryChildrenDefer, nextProps, suspenseInstance, suspenseState, renderLanes2) {
  if (!didSuspend) {
    pushPrimaryTreeSuspenseHandler(workInProgress2);
    warnIfHydrating();
    if ((void 0)(suspenseInstance)) {
      let digest;
      let message;
      let stack = null;
      let componentStack = null;
      if (false) {
        ({ digest, message, stack, componentStack } = (void 0)(suspenseInstance));
      } else {
        ({ digest } = (void 0)(suspenseInstance));
      }
      if (!enablePostpone || digest !== "POSTPONE") {
        let error;
        if (false) {
          error = new Error(message);
        } else {
          error = new Error(
            "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
          );
        }
        error.stack = "";
        error.digest = digest;
        const capturedValue = createCapturedValueFromError(
          error,
          componentStack === void 0 ? null : componentStack
        );
        queueHydrationError(capturedValue);
      }
      return retrySuspenseComponentWithoutHydrating(
        current2,
        workInProgress2,
        renderLanes2
      );
    }
    if (
      // TODO: Factoring is a little weird, since we check this right below, too.
      !didReceiveUpdate
    ) {
      lazilyPropagateParentContextChanges(current2, workInProgress2, renderLanes2);
    }
    const hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
    if (didReceiveUpdate || hasContextChanged2) {
      const root2 = getWorkInProgressRoot();
      if (root2 !== null) {
        const attemptHydrationAtLane = getBumpedLaneForHydration(
          root2,
          renderLanes2
        );
        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
          suspenseState.retryLane = attemptHydrationAtLane;
          enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
          scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane);
          throw SelectiveHydrationException;
        } else {
        }
      }
      if ((void 0)(suspenseInstance)) {
      } else {
        renderDidSuspendDelayIfPossible();
      }
      return retrySuspenseComponentWithoutHydrating(
        current2,
        workInProgress2,
        renderLanes2
      );
    } else if ((void 0)(suspenseInstance)) {
      workInProgress2.flags |= DidCapture | Callback;
      workInProgress2.child = current2.child;
      return null;
    } else {
      reenterHydrationStateFromDehydratedSuspenseInstance(
        workInProgress2,
        suspenseInstance,
        suspenseState.treeContext
      );
      const primaryChildren = nextProps.children;
      const primaryChildFragment = mountSuspensePrimaryChildren(
        workInProgress2,
        primaryChildren,
        renderLanes2
      );
      primaryChildFragment.flags |= Hydrating;
      return primaryChildFragment;
    }
  } else {
    if (workInProgress2.flags & ForceClientRender) {
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      workInProgress2.flags &= ~ForceClientRender;
      return retrySuspenseComponentWithoutHydrating(
        current2,
        workInProgress2,
        renderLanes2
      );
    } else if (workInProgress2.memoizedState !== null) {
      pushFallbackTreeSuspenseHandler(workInProgress2);
      workInProgress2.child = current2.child;
      workInProgress2.flags |= DidCapture;
      return null;
    } else {
      pushFallbackTreeSuspenseHandler(workInProgress2);
      const nextPrimaryChildren = nextProps.children;
      const nextFallbackChildren = nextProps.fallback;
      const fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(
        current2,
        workInProgress2,
        nextPrimaryChildren,
        nextFallbackChildren,
        renderLanes2
      );
      const primaryChildFragment = workInProgress2.child;
      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
      primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(
        current2,
        didPrimaryChildrenDefer,
        renderLanes2
      );
      workInProgress2.memoizedState = SUSPENDED_MARKER;
      return fallbackChildFragment;
    }
  }
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
  const alternate = fiber.alternate;
  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
  }
  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
}
function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
  let node = firstChild;
  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      const state = node.memoizedState;
      if (state !== null) {
        scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
      }
    } else if (node.tag === SuspenseListComponent) {
      scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === workInProgress2) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress2) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}
function findLastContentRow(firstChild) {
  let row = firstChild;
  let lastContentRow = null;
  while (row !== null) {
    const currentRow = row.alternate;
    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
      lastContentRow = row;
    }
    row = row.sibling;
  }
  return lastContentRow;
}
function validateRevealOrder(revealOrder) {
  if (false) {
    if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
      didWarnAboutRevealOrder[revealOrder] = true;
      if (typeof revealOrder === "string") {
        switch (revealOrder.toLowerCase()) {
          case "together":
          case "forwards":
          case "backwards": {
            console.error(
              '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
              revealOrder,
              revealOrder.toLowerCase()
            );
            break;
          }
          case "forward":
          case "backward": {
            console.error(
              '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
              revealOrder,
              revealOrder.toLowerCase()
            );
            break;
          }
          default:
            console.error(
              '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
              revealOrder
            );
            break;
        }
      } else {
        console.error(
          '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
          revealOrder
        );
      }
    }
  }
}
function validateTailOptions(tailMode, revealOrder) {
  if (false) {
    if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
      if (tailMode !== "collapsed" && tailMode !== "hidden") {
        didWarnAboutTailOptions[tailMode] = true;
        console.error(
          '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
          tailMode
        );
      } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
        didWarnAboutTailOptions[tailMode] = true;
        console.error(
          '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
          tailMode
        );
      }
    }
  }
}
function validateSuspenseListChildren(children, revealOrder) {
  if (false) {
    if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
      if (isArray_default(children)) {
        for (let i = 0; i < children.length; i++) {
          if (!validateSuspenseListNestedChild(children[i], i)) {
            return;
          }
        }
      } else {
        const iteratorFn = getIteratorFn(children);
        if (typeof iteratorFn === "function") {
          const childrenIterator = iteratorFn.call(children);
          if (childrenIterator) {
            let step = childrenIterator.next();
            let i = 0;
            for (; !step.done; step = childrenIterator.next()) {
              if (!validateSuspenseListNestedChild(step.value, i)) {
                return;
              }
              i++;
            }
          }
        } else {
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            revealOrder
          );
        }
      }
    }
  }
}
function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
  const renderState = workInProgress2.memoizedState;
  if (renderState === null) {
    workInProgress2.memoizedState = {
      isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail,
      tailMode
    };
  } else {
    renderState.isBackwards = isBackwards;
    renderState.rendering = null;
    renderState.renderingStartTime = 0;
    renderState.last = lastContentRow;
    renderState.tail = tail;
    renderState.tailMode = tailMode;
  }
}
function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
  const nextProps = workInProgress2.pendingProps;
  const revealOrder = nextProps.revealOrder;
  const tailMode = nextProps.tail;
  const newChildren = nextProps.children;
  validateRevealOrder(revealOrder);
  validateTailOptions(tailMode, revealOrder);
  validateSuspenseListChildren(newChildren, revealOrder);
  reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
  let suspenseContext = suspenseStackCursor.current;
  const shouldForceFallback = hasSuspenseListContext(
    suspenseContext,
    ForceSuspenseFallback
  );
  if (shouldForceFallback) {
    suspenseContext = setShallowSuspenseListContext(
      suspenseContext,
      ForceSuspenseFallback
    );
    workInProgress2.flags |= DidCapture;
  } else {
    const didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
    if (didSuspendBefore) {
      propagateSuspenseContextChange(
        workInProgress2,
        workInProgress2.child,
        renderLanes2
      );
    }
    suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);
  }
  pushSuspenseListContext(workInProgress2, suspenseContext);
  if (!disableLegacyMode && (workInProgress2.mode & ConcurrentMode) === NoMode) {
    workInProgress2.memoizedState = null;
  } else {
    switch (revealOrder) {
      case "forwards": {
        const lastContentRow = findLastContentRow(workInProgress2.child);
        let tail;
        if (lastContentRow === null) {
          tail = workInProgress2.child;
          workInProgress2.child = null;
        } else {
          tail = lastContentRow.sibling;
          lastContentRow.sibling = null;
        }
        initSuspenseListRenderState(
          workInProgress2,
          false,
          // isBackwards
          tail,
          lastContentRow,
          tailMode
        );
        break;
      }
      case "backwards": {
        let tail = null;
        let row = workInProgress2.child;
        workInProgress2.child = null;
        while (row !== null) {
          const currentRow = row.alternate;
          if (currentRow !== null && findFirstSuspended(currentRow) === null) {
            workInProgress2.child = row;
            break;
          }
          const nextRow = row.sibling;
          row.sibling = tail;
          tail = row;
          row = nextRow;
        }
        initSuspenseListRenderState(
          workInProgress2,
          true,
          // isBackwards
          tail,
          null,
          // last
          tailMode
        );
        break;
      }
      case "together": {
        initSuspenseListRenderState(
          workInProgress2,
          false,
          // isBackwards
          null,
          // tail
          null,
          // last
          void 0
        );
        break;
      }
      default: {
        workInProgress2.memoizedState = null;
      }
    }
  }
  return workInProgress2.child;
}
function updateViewTransition(current2, workInProgress2, renderLanes2) {
  const pendingProps = workInProgress2.pendingProps;
  if (pendingProps.name != null && pendingProps.name !== "auto") {
    workInProgress2.flags |= current2 === null ? ViewTransitionNamedMount | ViewTransitionNamedStatic : ViewTransitionNamedStatic;
  } else {
    if (getIsHydrating()) {
      pushMaterializedTreeId(workInProgress2);
    }
  }
  if (false) {
    if (pendingProps.className !== void 0) {
      const example = typeof pendingProps.className === "string" ? JSON.stringify(pendingProps.className) : "{...}";
      if (!didWarnAboutClassNameOnViewTransition[example]) {
        didWarnAboutClassNameOnViewTransition[example] = true;
        console.error(
          `<ViewTransition> doesn't accept a "className" prop. It has been renamed to "default".
-   <ViewTransition className=%s>
+   <ViewTransition default=%s>`,
          example,
          example
        );
      }
    }
  }
  if (current2 !== null && current2.memoizedProps.name !== pendingProps.name) {
    workInProgress2.flags |= Ref | RefStatic;
  } else {
    markRef(current2, workInProgress2);
  }
  const nextChildren = pendingProps.children;
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function updatePortalComponent(current2, workInProgress2, renderLanes2) {
  pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
  const nextChildren = workInProgress2.pendingProps;
  if (current2 === null) {
    workInProgress2.child = reconcileChildFibers(
      workInProgress2,
      null,
      nextChildren,
      renderLanes2
    );
  } else {
    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  }
  return workInProgress2.child;
}
function updateContextProvider(current2, workInProgress2, renderLanes2) {
  let context;
  if (enableRenderableContext) {
    context = workInProgress2.type;
  } else {
    context = workInProgress2.type._context;
  }
  const newProps = workInProgress2.pendingProps;
  const newValue = newProps.value;
  if (false) {
    if (!("value" in newProps)) {
      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
        hasWarnedAboutUsingNoValuePropOnContextProvider = true;
        console.error(
          "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
        );
      }
    }
  }
  pushProvider(workInProgress2, context, newValue);
  const newChildren = newProps.children;
  reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
  return workInProgress2.child;
}
function updateContextConsumer(current2, workInProgress2, renderLanes2) {
  let context;
  if (enableRenderableContext) {
    const consumerType = workInProgress2.type;
    context = consumerType._context;
  } else {
    context = workInProgress2.type;
    if (false) {
      if (context._context !== void 0) {
        context = context._context;
      }
    }
  }
  const newProps = workInProgress2.pendingProps;
  const render = newProps.children;
  if (false) {
    if (typeof render !== "function") {
      console.error(
        "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
      );
    }
  }
  prepareToReadContext(workInProgress2, renderLanes2);
  const newValue = readContext(context);
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress2);
  }
  let newChildren;
  if (false) {
    newChildren = callComponentInDEV(render, newValue, void 0);
  } else {
    newChildren = render(newValue);
  }
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }
  workInProgress2.flags |= PerformedWork;
  reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
  return workInProgress2.child;
}
function updateScopeComponent(current2, workInProgress2, renderLanes2) {
  const nextProps = workInProgress2.pendingProps;
  const nextChildren = nextProps.children;
  markRef(current2, workInProgress2);
  reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function markWorkInProgressReceivedUpdate() {
  didReceiveUpdate = true;
}
function checkIfWorkInProgressReceivedUpdate() {
  return didReceiveUpdate;
}
function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
  if (!disableLegacyMode && (workInProgress2.mode & ConcurrentMode) === NoMode) {
    if (current2 !== null) {
      current2.alternate = null;
      workInProgress2.alternate = null;
      workInProgress2.flags |= Placement;
    }
  }
}
function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
  if (current2 !== null) {
    workInProgress2.dependencies = current2.dependencies;
  }
  if (enableProfilerTimer) {
    stopProfilerTimerIfRunning(workInProgress2);
  }
  markSkippedUpdateLanes(workInProgress2.lanes);
  if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
    if (current2 !== null) {
      lazilyPropagateParentContextChanges(current2, workInProgress2, renderLanes2);
      if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
        return null;
      }
    } else {
      return null;
    }
  }
  cloneChildFibers(current2, workInProgress2);
  return workInProgress2.child;
}
function checkScheduledUpdateOrContext(current2, renderLanes2) {
  const updateLanes = current2.lanes;
  if (includesSomeLane(updateLanes, renderLanes2)) {
    return true;
  }
  const dependencies = current2.dependencies;
  if (dependencies !== null && checkIfContextChanged(dependencies)) {
    return true;
  }
  return false;
}
function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
  switch (workInProgress2.tag) {
    case HostRoot: {
      pushHostRootContext(workInProgress2);
      const root2 = workInProgress2.stateNode;
      pushRootTransition(workInProgress2, root2, renderLanes2);
      if (enableTransitionTracing) {
        pushRootMarkerInstance(workInProgress2);
      }
      const cache3 = current2.memoizedState.cache;
      pushCacheProvider(workInProgress2, cache3);
      resetHydrationState();
      break;
    }
    case HostSingleton:
    case HostComponent:
      pushHostContext(workInProgress2);
      break;
    case ClassComponent: {
      const Component2 = workInProgress2.type;
      if (isContextProvider(Component2)) {
        pushContextProvider(workInProgress2);
      }
      break;
    }
    case HostPortal:
      pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
      break;
    case ContextProvider: {
      const newValue = workInProgress2.memoizedProps.value;
      let context;
      if (enableRenderableContext) {
        context = workInProgress2.type;
      } else {
        context = workInProgress2.type._context;
      }
      pushProvider(workInProgress2, context, newValue);
      break;
    }
    case Profiler:
      if (enableProfilerTimer) {
        const hasChildWork = includesSomeLane(
          renderLanes2,
          workInProgress2.childLanes
        );
        if (hasChildWork) {
          workInProgress2.flags |= Update;
        }
        if (enableProfilerCommitHooks) {
          workInProgress2.flags |= Passive;
          const stateNode = workInProgress2.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
        }
      }
      break;
    case ActivityComponent: {
      const state = workInProgress2.memoizedState;
      if (state !== null) {
        workInProgress2.flags |= DidCapture;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        return null;
      }
      break;
    }
    case SuspenseComponent: {
      const state = workInProgress2.memoizedState;
      if (state !== null) {
        if (state.dehydrated !== null) {
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          workInProgress2.flags |= DidCapture;
          return null;
        }
        const primaryChildFragment = workInProgress2.child;
        const primaryChildLanes = primaryChildFragment.childLanes;
        if (includesSomeLane(renderLanes2, primaryChildLanes)) {
          return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
        } else {
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          const child = bailoutOnAlreadyFinishedWork(
            current2,
            workInProgress2,
            renderLanes2
          );
          if (child !== null) {
            return child.sibling;
          } else {
            return null;
          }
        }
      } else {
        pushPrimaryTreeSuspenseHandler(workInProgress2);
      }
      break;
    }
    case SuspenseListComponent: {
      const didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
      let hasChildWork = includesSomeLane(
        renderLanes2,
        workInProgress2.childLanes
      );
      if (!hasChildWork) {
        lazilyPropagateParentContextChanges(
          current2,
          workInProgress2,
          renderLanes2
        );
        hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
      }
      if (didSuspendBefore) {
        if (hasChildWork) {
          return updateSuspenseListComponent(
            current2,
            workInProgress2,
            renderLanes2
          );
        }
        workInProgress2.flags |= DidCapture;
      }
      const renderState = workInProgress2.memoizedState;
      if (renderState !== null) {
        renderState.rendering = null;
        renderState.tail = null;
        renderState.lastEffect = null;
      }
      pushSuspenseListContext(workInProgress2, suspenseStackCursor.current);
      if (hasChildWork) {
        break;
      } else {
        return null;
      }
    }
    case OffscreenComponent: {
      workInProgress2.lanes = NoLanes;
      return updateOffscreenComponent(
        current2,
        workInProgress2,
        renderLanes2,
        workInProgress2.pendingProps
      );
    }
    case CacheComponent: {
      const cache3 = current2.memoizedState.cache;
      pushCacheProvider(workInProgress2, cache3);
      break;
    }
    case TracingMarkerComponent: {
      if (enableTransitionTracing) {
        const instance = workInProgress2.stateNode;
        if (instance !== null) {
          pushMarkerInstance(workInProgress2, instance);
        }
        break;
      }
    }
    case LegacyHiddenComponent: {
      if (enableLegacyHidden) {
        workInProgress2.lanes = NoLanes;
        return updateLegacyHiddenComponent(
          current2,
          workInProgress2,
          renderLanes2
        );
      }
    }
  }
  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
}
function beginWork(current2, workInProgress2, renderLanes2) {
  if (false) {
    if (workInProgress2._debugNeedsRemount && current2 !== null) {
      const copiedFiber = createFiberFromTypeAndProps(
        workInProgress2.type,
        workInProgress2.key,
        workInProgress2.pendingProps,
        workInProgress2._debugOwner || null,
        workInProgress2.mode,
        workInProgress2.lanes
      );
      copiedFiber._debugStack = workInProgress2._debugStack;
      copiedFiber._debugTask = workInProgress2._debugTask;
      return remountFiber(current2, workInProgress2, copiedFiber);
    }
  }
  if (current2 !== null) {
    const oldProps = current2.memoizedProps;
    const newProps = workInProgress2.pendingProps;
    if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
    (false ? workInProgress2.type !== current2.type : false)) {
      didReceiveUpdate = true;
    } else {
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current2,
        renderLanes2
      );
      if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
      // may not be work scheduled on `current`, so we check for this flag.
      (workInProgress2.flags & DidCapture) === NoFlags) {
        didReceiveUpdate = false;
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current2,
          workInProgress2,
          renderLanes2
        );
      }
      if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        didReceiveUpdate = true;
      } else {
        didReceiveUpdate = false;
      }
    }
  } else {
    didReceiveUpdate = false;
    if (getIsHydrating() && isForkedChild(workInProgress2)) {
      const slotIndex = workInProgress2.index;
      const numberOfForks = getForksAtLevel(workInProgress2);
      pushTreeId(workInProgress2, numberOfForks, slotIndex);
    }
  }
  workInProgress2.lanes = NoLanes;
  switch (workInProgress2.tag) {
    case LazyComponent: {
      const elementType = workInProgress2.elementType;
      return mountLazyComponent(
        current2,
        workInProgress2,
        elementType,
        renderLanes2
      );
    }
    case FunctionComponent: {
      const Component2 = workInProgress2.type;
      const unresolvedProps = workInProgress2.pendingProps;
      const resolvedProps = disableDefaultPropsExceptForClasses || workInProgress2.elementType === Component2 ? unresolvedProps : resolveDefaultPropsOnNonClassComponent(Component2, unresolvedProps);
      return updateFunctionComponent(
        current2,
        workInProgress2,
        Component2,
        resolvedProps,
        renderLanes2
      );
    }
    case ClassComponent: {
      const Component2 = workInProgress2.type;
      const unresolvedProps = workInProgress2.pendingProps;
      const resolvedProps = resolveClassComponentProps(
        Component2,
        unresolvedProps,
        workInProgress2.elementType === Component2
      );
      return updateClassComponent(
        current2,
        workInProgress2,
        Component2,
        resolvedProps,
        renderLanes2
      );
    }
    case HostRoot:
      return updateHostRoot(current2, workInProgress2, renderLanes2);
    case HostHoistable:
      if (void 0) {
        return updateHostHoistable(current2, workInProgress2, renderLanes2);
      }
    // Fall through
    case HostSingleton:
      if (void 0) {
        return updateHostSingleton(current2, workInProgress2, renderLanes2);
      }
    // Fall through
    case HostComponent:
      return updateHostComponent(current2, workInProgress2, renderLanes2);
    case HostText:
      return updateHostText(current2, workInProgress2);
    case SuspenseComponent:
      return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
    case HostPortal:
      return updatePortalComponent(current2, workInProgress2, renderLanes2);
    case ForwardRef: {
      const type = workInProgress2.type;
      const unresolvedProps = workInProgress2.pendingProps;
      const resolvedProps = disableDefaultPropsExceptForClasses || workInProgress2.elementType === type ? unresolvedProps : resolveDefaultPropsOnNonClassComponent(type, unresolvedProps);
      return updateForwardRef(
        current2,
        workInProgress2,
        type,
        resolvedProps,
        renderLanes2
      );
    }
    case Fragment:
      return updateFragment(current2, workInProgress2, renderLanes2);
    case Mode:
      return updateMode(current2, workInProgress2, renderLanes2);
    case Profiler:
      return updateProfiler(current2, workInProgress2, renderLanes2);
    case ContextProvider:
      return updateContextProvider(current2, workInProgress2, renderLanes2);
    case ContextConsumer:
      return updateContextConsumer(current2, workInProgress2, renderLanes2);
    case MemoComponent: {
      const type = workInProgress2.type;
      const unresolvedProps = workInProgress2.pendingProps;
      let resolvedProps = disableDefaultPropsExceptForClasses ? unresolvedProps : resolveDefaultPropsOnNonClassComponent(type, unresolvedProps);
      resolvedProps = disableDefaultPropsExceptForClasses ? resolvedProps : resolveDefaultPropsOnNonClassComponent(type.type, resolvedProps);
      return updateMemoComponent(
        current2,
        workInProgress2,
        type,
        resolvedProps,
        renderLanes2
      );
    }
    case SimpleMemoComponent: {
      return updateSimpleMemoComponent(
        current2,
        workInProgress2,
        workInProgress2.type,
        workInProgress2.pendingProps,
        renderLanes2
      );
    }
    case IncompleteClassComponent: {
      if (disableLegacyMode) {
        break;
      }
      const Component2 = workInProgress2.type;
      const unresolvedProps = workInProgress2.pendingProps;
      const resolvedProps = resolveClassComponentProps(
        Component2,
        unresolvedProps,
        workInProgress2.elementType === Component2
      );
      return mountIncompleteClassComponent(
        current2,
        workInProgress2,
        Component2,
        resolvedProps,
        renderLanes2
      );
    }
    case IncompleteFunctionComponent: {
      if (disableLegacyMode) {
        break;
      }
      const Component2 = workInProgress2.type;
      const unresolvedProps = workInProgress2.pendingProps;
      const resolvedProps = resolveClassComponentProps(
        Component2,
        unresolvedProps,
        workInProgress2.elementType === Component2
      );
      return mountIncompleteFunctionComponent(
        current2,
        workInProgress2,
        Component2,
        resolvedProps,
        renderLanes2
      );
    }
    case SuspenseListComponent: {
      return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
    }
    case ScopeComponent: {
      if (enableScopeAPI) {
        return updateScopeComponent(current2, workInProgress2, renderLanes2);
      }
      break;
    }
    case ActivityComponent: {
      return updateActivityComponent(current2, workInProgress2, renderLanes2);
    }
    case OffscreenComponent: {
      return updateOffscreenComponent(
        current2,
        workInProgress2,
        renderLanes2,
        workInProgress2.pendingProps
      );
    }
    case LegacyHiddenComponent: {
      if (enableLegacyHidden) {
        return updateLegacyHiddenComponent(
          current2,
          workInProgress2,
          renderLanes2
        );
      }
      break;
    }
    case CacheComponent: {
      return updateCacheComponent(current2, workInProgress2, renderLanes2);
    }
    case TracingMarkerComponent: {
      if (enableTransitionTracing) {
        return updateTracingMarkerComponent(
          current2,
          workInProgress2,
          renderLanes2
        );
      }
      break;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        return updateViewTransition(current2, workInProgress2, renderLanes2);
      }
      break;
    }
    case Throw: {
      throw workInProgress2.pendingProps;
    }
  }
  throw new Error(
    `Unknown unit of work tag (${workInProgress2.tag}). This error is likely caused by a bug in React. Please file an issue.`
  );
}

// dist/react-reconciler/src/ReactFiberScope.js
function getSuspenseFallbackChild(fiber) {
  return fiber.child.sibling.child;
}
var emptyObject2 = {};
function collectScopedNodes(node, fn, scopedNodes) {
  if (enableScopeAPI) {
    if (node.tag === HostComponent) {
      const { type, memoizedProps, stateNode } = node;
      const instance = (void 0)(stateNode);
      if (instance !== null && fn(type, memoizedProps || emptyObject2, instance) === true) {
        scopedNodes.push(instance);
      }
    }
    let child = node.child;
    if (isFiberSuspenseAndTimedOut(node)) {
      child = getSuspenseFallbackChild(node);
    }
    if (child !== null) {
      collectScopedNodesFromChildren(child, fn, scopedNodes);
    }
  }
}
function collectFirstScopedNode(node, fn) {
  if (enableScopeAPI) {
    if (node.tag === HostComponent) {
      const { type, memoizedProps, stateNode } = node;
      const instance = (void 0)(stateNode);
      if (instance !== null && fn(type, memoizedProps, instance) === true) {
        return instance;
      }
    }
    let child = node.child;
    if (isFiberSuspenseAndTimedOut(node)) {
      child = getSuspenseFallbackChild(node);
    }
    if (child !== null) {
      return collectFirstScopedNodeFromChildren(child, fn);
    }
  }
  return null;
}
function collectScopedNodesFromChildren(startingChild, fn, scopedNodes) {
  let child = startingChild;
  while (child !== null) {
    collectScopedNodes(child, fn, scopedNodes);
    child = child.sibling;
  }
}
function collectFirstScopedNodeFromChildren(startingChild, fn) {
  let child = startingChild;
  while (child !== null) {
    const scopedNode = collectFirstScopedNode(child, fn);
    if (scopedNode !== null) {
      return scopedNode;
    }
    child = child.sibling;
  }
  return null;
}
function collectNearestContextValues(node, context, childContextValues) {
  if (node.tag === ContextProvider && (enableRenderableContext ? node.type : node.type._context) === context) {
    const contextValue = node.memoizedProps.value;
    childContextValues.push(contextValue);
  } else {
    let child = node.child;
    if (isFiberSuspenseAndTimedOut(node)) {
      child = getSuspenseFallbackChild(node);
    }
    if (child !== null) {
      collectNearestChildContextValues(child, context, childContextValues);
    }
  }
}
function collectNearestChildContextValues(startingChild, context, childContextValues) {
  let child = startingChild;
  while (child !== null) {
    collectNearestContextValues(child, context, childContextValues);
    child = child.sibling;
  }
}
function DO_NOT_USE_queryAllNodes(fn) {
  const currentFiber = (void 0)(this);
  if (currentFiber === null) {
    return null;
  }
  const child = currentFiber.child;
  const scopedNodes = [];
  if (child !== null) {
    collectScopedNodesFromChildren(child, fn, scopedNodes);
  }
  return scopedNodes.length === 0 ? null : scopedNodes;
}
function DO_NOT_USE_queryFirstNode(fn) {
  const currentFiber = (void 0)(this);
  if (currentFiber === null) {
    return null;
  }
  const child = currentFiber.child;
  if (child !== null) {
    return collectFirstScopedNodeFromChildren(child, fn);
  }
  return null;
}
function containsNode(node) {
  let fiber = (void 0)(node);
  while (fiber !== null) {
    if (fiber.tag === ScopeComponent && fiber.stateNode === this) {
      return true;
    }
    fiber = fiber.return;
  }
  return false;
}
function getChildContextValues(context) {
  const currentFiber = (void 0)(this);
  if (currentFiber === null) {
    return [];
  }
  const child = currentFiber.child;
  const childContextValues = [];
  if (child !== null) {
    collectNearestChildContextValues(child, context, childContextValues);
  }
  return childContextValues;
}
function createScopeInstance() {
  return {
    DO_NOT_USE_queryAllNodes,
    DO_NOT_USE_queryFirstNode,
    containsNode,
    getChildContextValues
  };
}

// dist/react-reconciler/src/ReactFiberCompleteWork.js
function markUpdate(workInProgress2) {
  workInProgress2.flags |= Update;
}
function markCloned(workInProgress2) {
  if (void 0 && enablePersistedModeClonedFlag) {
    workInProgress2.flags |= Cloned;
  }
}
function doesRequireClone(current2, completedWork) {
  const didBailout = current2 !== null && current2.child === completedWork.child;
  if (didBailout) {
    return false;
  }
  if ((completedWork.flags & ChildDeletion) !== NoFlags) {
    return true;
  }
  let child = completedWork.child;
  while (child !== null) {
    const checkedFlags = enablePersistedModeClonedFlag ? Cloned | Visibility | Placement | ChildDeletion : MutationMask;
    if ((child.flags & checkedFlags) !== NoFlags || (child.subtreeFlags & checkedFlags) !== NoFlags) {
      return true;
    }
    child = child.sibling;
  }
  return false;
}
function appendAllChildren(parent, workInProgress2, needsVisibilityToggle, isHidden) {
  if (void 0) {
    let node = workInProgress2.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        (void 0)(parent, node.stateNode);
      } else if (node.tag === HostPortal || (void 0 ? node.tag === HostSingleton : false)) {
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress2) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress2) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  } else if (void 0) {
    let node = workInProgress2.child;
    while (node !== null) {
      if (node.tag === HostComponent) {
        let instance = node.stateNode;
        if (needsVisibilityToggle && isHidden) {
          const props = node.memoizedProps;
          const type = node.type;
          instance = (void 0)(instance, type, props);
        }
        (void 0)(parent, instance);
      } else if (node.tag === HostText) {
        let instance = node.stateNode;
        if (needsVisibilityToggle && isHidden) {
          const text = node.memoizedProps;
          instance = (void 0)(instance, text);
        }
        (void 0)(parent, instance);
      } else if (node.tag === HostPortal) {
      } else if (node.tag === OffscreenComponent && node.memoizedState !== null) {
        const child = node.child;
        if (child !== null) {
          child.return = node;
        }
        appendAllChildren(
          parent,
          node,
          /* needsVisibilityToggle */
          true,
          /* isHidden */
          true
        );
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress2) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress2) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
}
function appendAllChildrenToContainer(containerChildSet, workInProgress2, needsVisibilityToggle, isHidden) {
  let hasOffscreenComponentChild = false;
  if (void 0) {
    let node = workInProgress2.child;
    while (node !== null) {
      if (node.tag === HostComponent) {
        let instance = node.stateNode;
        if (needsVisibilityToggle && isHidden) {
          const props = node.memoizedProps;
          const type = node.type;
          instance = (void 0)(instance, type, props);
        }
        (void 0)(containerChildSet, instance);
      } else if (node.tag === HostText) {
        let instance = node.stateNode;
        if (needsVisibilityToggle && isHidden) {
          const text = node.memoizedProps;
          instance = (void 0)(instance, text);
        }
        (void 0)(containerChildSet, instance);
      } else if (node.tag === HostPortal) {
      } else if (node.tag === OffscreenComponent && node.memoizedState !== null) {
        const child = node.child;
        if (child !== null) {
          child.return = node;
        }
        appendAllChildrenToContainer(
          containerChildSet,
          node,
          /* needsVisibilityToggle */
          true,
          /* isHidden */
          true
        );
        hasOffscreenComponentChild = true;
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      node = node;
      if (node === workInProgress2) {
        return hasOffscreenComponentChild;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress2) {
          return hasOffscreenComponentChild;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return hasOffscreenComponentChild;
}
function updateHostContainer(current2, workInProgress2) {
  if (void 0) {
    if (doesRequireClone(current2, workInProgress2)) {
      const portalOrRoot = workInProgress2.stateNode;
      const container = portalOrRoot.containerInfo;
      const newChildSet = (void 0)();
      appendAllChildrenToContainer(
        newChildSet,
        workInProgress2,
        /* needsVisibilityToggle */
        false,
        /* isHidden */
        false
      );
      portalOrRoot.pendingChildren = newChildSet;
      markUpdate(workInProgress2);
      (void 0)(container, newChildSet);
    }
  }
}
function updateHostComponent2(current2, workInProgress2, type, newProps, renderLanes2) {
  if (void 0) {
    const oldProps = current2.memoizedProps;
    if (oldProps === newProps) {
      return;
    }
    markUpdate(workInProgress2);
  } else if (void 0) {
    const currentInstance = current2.stateNode;
    const oldProps = current2.memoizedProps;
    const requiresClone = doesRequireClone(current2, workInProgress2);
    if (!requiresClone && oldProps === newProps) {
      workInProgress2.stateNode = currentInstance;
      return;
    }
    const currentHostContext = getHostContext();
    let newChildSet = null;
    let hasOffscreenComponentChild = false;
    if (requiresClone && passChildrenWhenCloningPersistedNodes) {
      markCloned(workInProgress2);
      newChildSet = (void 0)();
      hasOffscreenComponentChild = appendAllChildrenToContainer(
        newChildSet,
        workInProgress2,
        /* needsVisibilityToggle */
        false,
        /* isHidden */
        false
      );
    }
    const newInstance = (void 0)(
      currentInstance,
      type,
      oldProps,
      newProps,
      !requiresClone,
      !hasOffscreenComponentChild ? newChildSet : void 0
    );
    if (newInstance === currentInstance) {
      workInProgress2.stateNode = currentInstance;
      return;
    } else {
      markCloned(workInProgress2);
    }
    if ((void 0)(newInstance, type, newProps, currentHostContext)) {
      markUpdate(workInProgress2);
    }
    workInProgress2.stateNode = newInstance;
    if (!requiresClone) {
      if (!enablePersistedModeClonedFlag) {
        markUpdate(workInProgress2);
      }
    } else if (!passChildrenWhenCloningPersistedNodes || hasOffscreenComponentChild) {
      appendAllChildren(
        newInstance,
        workInProgress2,
        /* needsVisibilityToggle */
        false,
        /* isHidden */
        false
      );
    }
  }
}
function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
  const maySuspend = (enableSuspenseyImages || (workInProgress2.mode & SuspenseyImagesMode) !== NoMode) && (oldProps === null ? (void 0)(type, newProps) : (void 0)(type, oldProps, newProps));
  if (!maySuspend) {
    workInProgress2.flags &= ~MaySuspendCommit;
    return;
  }
  workInProgress2.flags |= MaySuspendCommit;
  if (includesOnlySuspenseyCommitEligibleLanes(renderLanes2) || (void 0)(type, newProps)) {
    const isReady = (void 0)(workInProgress2.stateNode, type, newProps);
    if (!isReady) {
      if (shouldRemainOnPreviousScreen()) {
        workInProgress2.flags |= ShouldSuspendCommit;
      } else {
        suspendCommit();
      }
    } else {
      workInProgress2.flags |= ShouldSuspendCommit;
    }
  }
}
function preloadResourceAndSuspendIfNeeded(workInProgress2, resource, type, props, renderLanes2) {
  if (!(void 0)(resource)) {
    workInProgress2.flags &= ~MaySuspendCommit;
    return;
  }
  workInProgress2.flags |= MaySuspendCommit;
  const isReady = (void 0)(resource);
  if (!isReady) {
    if (shouldRemainOnPreviousScreen()) {
      workInProgress2.flags |= ShouldSuspendCommit;
    } else {
      suspendCommit();
    }
  }
}
function scheduleRetryEffect(workInProgress2, retryQueue) {
  const wakeables = retryQueue;
  if (wakeables !== null) {
    workInProgress2.flags |= Update;
  }
  if (workInProgress2.flags & ScheduleRetry) {
    const retryLane = (
      // TODO: This check should probably be moved into claimNextRetryLane
      // I also suspect that we need some further consolidation of offscreen
      // and retry lanes.
      workInProgress2.tag !== OffscreenComponent ? claimNextRetryLane() : OffscreenLane
    );
    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, retryLane);
    markSpawnedRetryLane(retryLane);
  }
}
function updateHostText2(current2, workInProgress2, oldText, newText) {
  if (void 0) {
    if (oldText !== newText) {
      markUpdate(workInProgress2);
    }
  } else if (void 0) {
    if (oldText !== newText) {
      const rootContainerInstance = getRootHostContainer();
      const currentHostContext = getHostContext();
      markCloned(workInProgress2);
      workInProgress2.stateNode = (void 0)(
        newText,
        rootContainerInstance,
        currentHostContext,
        workInProgress2
      );
      if (!enablePersistedModeClonedFlag) {
        markUpdate(workInProgress2);
      }
    } else {
      workInProgress2.stateNode = current2.stateNode;
    }
  }
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (getIsHydrating()) {
    return;
  }
  switch (renderState.tailMode) {
    case "hidden": {
      let tailNode = renderState.tail;
      let lastTailNode = null;
      while (tailNode !== null) {
        if (tailNode.alternate !== null) {
          lastTailNode = tailNode;
        }
        tailNode = tailNode.sibling;
      }
      if (lastTailNode === null) {
        renderState.tail = null;
      } else {
        lastTailNode.sibling = null;
      }
      break;
    }
    case "collapsed": {
      let tailNode = renderState.tail;
      let lastTailNode = null;
      while (tailNode !== null) {
        if (tailNode.alternate !== null) {
          lastTailNode = tailNode;
        }
        tailNode = tailNode.sibling;
      }
      if (lastTailNode === null) {
        if (!hasRenderedATailFallback && renderState.tail !== null) {
          renderState.tail.sibling = null;
        } else {
          renderState.tail = null;
        }
      } else {
        lastTailNode.sibling = null;
      }
      break;
    }
  }
}
function bubbleProperties(completedWork) {
  const didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
  let newChildLanes = NoLanes;
  let subtreeFlags = NoFlags;
  if (!didBailout) {
    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {
      let actualDuration = completedWork.actualDuration;
      let treeBaseDuration = completedWork.selfBaseDuration;
      let child = completedWork.child;
      while (child !== null) {
        newChildLanes = mergeLanes(
          newChildLanes,
          mergeLanes(child.lanes, child.childLanes)
        );
        subtreeFlags |= child.subtreeFlags;
        subtreeFlags |= child.flags;
        actualDuration += child.actualDuration;
        treeBaseDuration += child.treeBaseDuration;
        child = child.sibling;
      }
      completedWork.actualDuration = actualDuration;
      completedWork.treeBaseDuration = treeBaseDuration;
    } else {
      let child = completedWork.child;
      while (child !== null) {
        newChildLanes = mergeLanes(
          newChildLanes,
          mergeLanes(child.lanes, child.childLanes)
        );
        subtreeFlags |= child.subtreeFlags;
        subtreeFlags |= child.flags;
        child.return = completedWork;
        child = child.sibling;
      }
    }
    completedWork.subtreeFlags |= subtreeFlags;
  } else {
    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {
      let treeBaseDuration = completedWork.selfBaseDuration;
      let child = completedWork.child;
      while (child !== null) {
        newChildLanes = mergeLanes(
          newChildLanes,
          mergeLanes(child.lanes, child.childLanes)
        );
        subtreeFlags |= child.subtreeFlags & StaticMask;
        subtreeFlags |= child.flags & StaticMask;
        treeBaseDuration += child.treeBaseDuration;
        child = child.sibling;
      }
      completedWork.treeBaseDuration = treeBaseDuration;
    } else {
      let child = completedWork.child;
      while (child !== null) {
        newChildLanes = mergeLanes(
          newChildLanes,
          mergeLanes(child.lanes, child.childLanes)
        );
        subtreeFlags |= child.subtreeFlags & StaticMask;
        subtreeFlags |= child.flags & StaticMask;
        child.return = completedWork;
        child = child.sibling;
      }
    }
    completedWork.subtreeFlags |= subtreeFlags;
  }
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeDehydratedActivityBoundary(current2, workInProgress2, nextState) {
  const wasHydrated = popHydrationState(workInProgress2);
  if (nextState !== null) {
    if (current2 === null) {
      if (!wasHydrated) {
        throw new Error(
          "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
        );
      }
      prepareToHydrateHostActivityInstance(workInProgress2);
      bubbleProperties(workInProgress2);
      if (enableProfilerTimer) {
        if ((workInProgress2.mode & ProfileMode) !== NoMode) {
          const isTimedOutSuspense = nextState !== null;
          if (isTimedOutSuspense) {
            const primaryChildFragment = workInProgress2.child;
            if (primaryChildFragment !== null) {
              workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
            }
          }
        }
      }
      return false;
    } else {
      emitPendingHydrationWarnings();
      resetHydrationState();
      if ((workInProgress2.flags & DidCapture) === NoFlags) {
        nextState = workInProgress2.memoizedState = null;
      }
      workInProgress2.flags |= Update;
      bubbleProperties(workInProgress2);
      if (enableProfilerTimer) {
        if ((workInProgress2.mode & ProfileMode) !== NoMode) {
          const isTimedOutSuspense = nextState !== null;
          if (isTimedOutSuspense) {
            const primaryChildFragment = workInProgress2.child;
            if (primaryChildFragment !== null) {
              workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
            }
          }
        }
      }
      return false;
    }
  } else {
    const hydrationErrors2 = upgradeHydrationErrorsToRecoverable();
    if (current2 !== null && current2.memoizedState !== null) {
      const prevState = current2.memoizedState;
      prevState.hydrationErrors = hydrationErrors2;
    }
    return true;
  }
}
function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
  const wasHydrated = popHydrationState(workInProgress2);
  if (nextState !== null && nextState.dehydrated !== null) {
    if (current2 === null) {
      if (!wasHydrated) {
        throw new Error(
          "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
        );
      }
      prepareToHydrateHostSuspenseInstance(workInProgress2);
      bubbleProperties(workInProgress2);
      if (enableProfilerTimer) {
        if ((workInProgress2.mode & ProfileMode) !== NoMode) {
          const isTimedOutSuspense = nextState !== null;
          if (isTimedOutSuspense) {
            const primaryChildFragment = workInProgress2.child;
            if (primaryChildFragment !== null) {
              workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
            }
          }
        }
      }
      return false;
    } else {
      emitPendingHydrationWarnings();
      resetHydrationState();
      if ((workInProgress2.flags & DidCapture) === NoFlags) {
        nextState = workInProgress2.memoizedState = null;
      }
      workInProgress2.flags |= Update;
      bubbleProperties(workInProgress2);
      if (enableProfilerTimer) {
        if ((workInProgress2.mode & ProfileMode) !== NoMode) {
          const isTimedOutSuspense = nextState !== null;
          if (isTimedOutSuspense) {
            const primaryChildFragment = workInProgress2.child;
            if (primaryChildFragment !== null) {
              workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
            }
          }
        }
      }
      return false;
    }
  } else {
    const hydrationErrors2 = upgradeHydrationErrorsToRecoverable();
    if (current2 !== null && current2.memoizedState !== null) {
      const prevState = current2.memoizedState;
      prevState.hydrationErrors = hydrationErrors2;
    }
    return true;
  }
}
function completeWork(current2, workInProgress2, renderLanes2) {
  const newProps = workInProgress2.pendingProps;
  popTreeContext(workInProgress2);
  switch (workInProgress2.tag) {
    case IncompleteFunctionComponent: {
      if (disableLegacyMode) {
        break;
      }
    }
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      bubbleProperties(workInProgress2);
      return null;
    case ClassComponent: {
      const Component2 = workInProgress2.type;
      if (isContextProvider(Component2)) {
        popContext(workInProgress2);
      }
      bubbleProperties(workInProgress2);
      return null;
    }
    case HostRoot: {
      const fiberRoot = workInProgress2.stateNode;
      if (enableTransitionTracing) {
        const transitions = getWorkInProgressTransitions();
        if (transitions !== null) {
          workInProgress2.flags |= Passive;
        }
      }
      let previousCache = null;
      if (current2 !== null) {
        previousCache = current2.memoizedState.cache;
      }
      const cache3 = workInProgress2.memoizedState.cache;
      if (cache3 !== previousCache) {
        workInProgress2.flags |= Passive;
      }
      popCacheProvider(workInProgress2, cache3);
      if (enableTransitionTracing) {
        popRootMarkerInstance(workInProgress2);
      }
      popRootTransition(workInProgress2, fiberRoot, renderLanes2);
      popHostContainer(workInProgress2);
      popTopLevelContextObject(workInProgress2);
      if (fiberRoot.pendingContext) {
        fiberRoot.context = fiberRoot.pendingContext;
        fiberRoot.pendingContext = null;
      }
      if (current2 === null || current2.child === null) {
        const wasHydrated = popHydrationState(workInProgress2);
        if (wasHydrated) {
          emitPendingHydrationWarnings();
          markUpdate(workInProgress2);
        } else {
          if (current2 !== null) {
            const prevState = current2.memoizedState;
            if (
              // Check if this is a client root
              !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (workInProgress2.flags & ForceClientRender) !== NoFlags
            ) {
              workInProgress2.flags |= Snapshot;
              upgradeHydrationErrorsToRecoverable();
            }
          }
        }
      }
      updateHostContainer(current2, workInProgress2);
      bubbleProperties(workInProgress2);
      if (enableTransitionTracing) {
        if ((workInProgress2.subtreeFlags & Visibility) !== NoFlags) {
          workInProgress2.flags |= Passive;
        }
      }
      return null;
    }
    case HostHoistable: {
      if (void 0) {
        const type = workInProgress2.type;
        const nextResource = workInProgress2.memoizedState;
        if (current2 === null) {
          markUpdate(workInProgress2);
          if (nextResource !== null) {
            bubbleProperties(workInProgress2);
            preloadResourceAndSuspendIfNeeded(
              workInProgress2,
              nextResource,
              type,
              newProps,
              renderLanes2
            );
            return null;
          } else {
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              null,
              newProps,
              renderLanes2
            );
            return null;
          }
        } else {
          if (nextResource) {
            if (nextResource !== current2.memoizedState) {
              markUpdate(workInProgress2);
              bubbleProperties(workInProgress2);
              preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                nextResource,
                type,
                newProps,
                renderLanes2
              );
              return null;
            } else {
              bubbleProperties(workInProgress2);
              workInProgress2.flags &= ~MaySuspendCommit;
              return null;
            }
          } else {
            const oldProps = current2.memoizedProps;
            if (void 0) {
              if (oldProps !== newProps) {
                markUpdate(workInProgress2);
              }
            } else {
              updateHostComponent2(
                current2,
                workInProgress2,
                type,
                newProps,
                renderLanes2
              );
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              oldProps,
              newProps,
              renderLanes2
            );
            return null;
          }
        }
      }
    }
    case HostSingleton: {
      if (void 0) {
        popHostContext(workInProgress2);
        const rootContainerInstance = getRootHostContainer();
        const type = workInProgress2.type;
        if (current2 !== null && workInProgress2.stateNode != null) {
          if (void 0) {
            const oldProps = current2.memoizedProps;
            if (oldProps !== newProps) {
              markUpdate(workInProgress2);
            }
          } else {
            updateHostComponent2(
              current2,
              workInProgress2,
              type,
              newProps,
              renderLanes2
            );
          }
        } else {
          if (!newProps) {
            if (workInProgress2.stateNode === null) {
              throw new Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            }
            bubbleProperties(workInProgress2);
            if (enableViewTransition) {
              workInProgress2.subtreeFlags &= ~ViewTransitionStatic;
            }
            return null;
          }
          const currentHostContext = getHostContext();
          const wasHydrated = popHydrationState(workInProgress2);
          let instance;
          if (wasHydrated) {
            prepareToHydrateHostInstance(workInProgress2, currentHostContext);
            instance = workInProgress2.stateNode;
          } else {
            instance = (void 0)(
              type,
              newProps,
              rootContainerInstance,
              currentHostContext,
              true
            );
            workInProgress2.stateNode = instance;
            markUpdate(workInProgress2);
          }
        }
        bubbleProperties(workInProgress2);
        if (enableViewTransition) {
          workInProgress2.subtreeFlags &= ~ViewTransitionStatic;
        }
        return null;
      }
    }
    case HostComponent: {
      popHostContext(workInProgress2);
      const type = workInProgress2.type;
      if (current2 !== null && workInProgress2.stateNode != null) {
        updateHostComponent2(
          current2,
          workInProgress2,
          type,
          newProps,
          renderLanes2
        );
      } else {
        if (!newProps) {
          if (workInProgress2.stateNode === null) {
            throw new Error(
              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
            );
          }
          bubbleProperties(workInProgress2);
          if (enableViewTransition) {
            workInProgress2.subtreeFlags &= ~ViewTransitionStatic;
          }
          return null;
        }
        const currentHostContext = getHostContext();
        const wasHydrated = popHydrationState(workInProgress2);
        if (wasHydrated) {
          prepareToHydrateHostInstance(workInProgress2, currentHostContext);
          if ((void 0)(
            workInProgress2.stateNode,
            type,
            newProps,
            currentHostContext
          )) {
            workInProgress2.flags |= Hydrate;
          }
        } else {
          const rootContainerInstance = getRootHostContainer();
          const instance = (void 0)(
            type,
            newProps,
            rootContainerInstance,
            currentHostContext,
            workInProgress2
          );
          markCloned(workInProgress2);
          appendAllChildren(instance, workInProgress2, false, false);
          workInProgress2.stateNode = instance;
          if ((void 0)(
            instance,
            type,
            newProps,
            currentHostContext
          )) {
            markUpdate(workInProgress2);
          }
        }
      }
      bubbleProperties(workInProgress2);
      if (enableViewTransition) {
        workInProgress2.subtreeFlags &= ~ViewTransitionStatic;
      }
      preloadInstanceAndSuspendIfNeeded(
        workInProgress2,
        workInProgress2.type,
        current2 === null ? null : current2.memoizedProps,
        workInProgress2.pendingProps,
        renderLanes2
      );
      return null;
    }
    case HostText: {
      const newText = newProps;
      if (current2 && workInProgress2.stateNode != null) {
        const oldText = current2.memoizedProps;
        updateHostText2(current2, workInProgress2, oldText, newText);
      } else {
        if (typeof newText !== "string") {
          if (workInProgress2.stateNode === null) {
            throw new Error(
              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
            );
          }
        }
        const rootContainerInstance = getRootHostContainer();
        const currentHostContext = getHostContext();
        const wasHydrated = popHydrationState(workInProgress2);
        if (wasHydrated) {
          prepareToHydrateHostTextInstance(workInProgress2);
        } else {
          markCloned(workInProgress2);
          workInProgress2.stateNode = (void 0)(
            newText,
            rootContainerInstance,
            currentHostContext,
            workInProgress2
          );
        }
      }
      bubbleProperties(workInProgress2);
      return null;
    }
    case ActivityComponent: {
      const nextState = workInProgress2.memoizedState;
      if (current2 === null || current2.memoizedState !== null) {
        const fallthroughToNormalOffscreenPath = completeDehydratedActivityBoundary(
          current2,
          workInProgress2,
          nextState
        );
        if (!fallthroughToNormalOffscreenPath) {
          if (workInProgress2.flags & ForceClientRender) {
            popSuspenseHandler(workInProgress2);
            return workInProgress2;
          } else {
            popSuspenseHandler(workInProgress2);
            return null;
          }
        }
        if ((workInProgress2.flags & DidCapture) !== NoFlags) {
          throw new Error(
            "Client rendering an Activity suspended it again. This is a bug in React."
          );
        }
      }
      bubbleProperties(workInProgress2);
      return null;
    }
    case SuspenseComponent: {
      const nextState = workInProgress2.memoizedState;
      if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
        const fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(
          current2,
          workInProgress2,
          nextState
        );
        if (!fallthroughToNormalSuspensePath) {
          if (workInProgress2.flags & ForceClientRender) {
            popSuspenseHandler(workInProgress2);
            return workInProgress2;
          } else {
            popSuspenseHandler(workInProgress2);
            return null;
          }
        }
      }
      popSuspenseHandler(workInProgress2);
      if ((workInProgress2.flags & DidCapture) !== NoFlags) {
        workInProgress2.lanes = renderLanes2;
        if (enableProfilerTimer && (workInProgress2.mode & ProfileMode) !== NoMode) {
          transferActualDuration(workInProgress2);
        }
        return workInProgress2;
      }
      const nextDidTimeout = nextState !== null;
      const prevDidTimeout = current2 !== null && current2.memoizedState !== null;
      if (nextDidTimeout) {
        const offscreenFiber = workInProgress2.child;
        let previousCache = null;
        if (offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null && offscreenFiber.alternate.memoizedState.cachePool !== null) {
          previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;
        }
        let cache3 = null;
        if (offscreenFiber.memoizedState !== null && offscreenFiber.memoizedState.cachePool !== null) {
          cache3 = offscreenFiber.memoizedState.cachePool.pool;
        }
        if (cache3 !== previousCache) {
          offscreenFiber.flags |= Passive;
        }
      }
      if (nextDidTimeout !== prevDidTimeout) {
        if (enableTransitionTracing) {
          const offscreenFiber = workInProgress2.child;
          offscreenFiber.flags |= Passive;
        }
        if (nextDidTimeout) {
          const offscreenFiber = workInProgress2.child;
          offscreenFiber.flags |= Visibility;
        }
      }
      const retryQueue = workInProgress2.updateQueue;
      scheduleRetryEffect(workInProgress2, retryQueue);
      if (enableSuspenseCallback && workInProgress2.updateQueue !== null && workInProgress2.memoizedProps.suspenseCallback != null) {
        workInProgress2.flags |= Update;
      }
      bubbleProperties(workInProgress2);
      if (enableProfilerTimer) {
        if ((workInProgress2.mode & ProfileMode) !== NoMode) {
          if (nextDidTimeout) {
            const primaryChildFragment = workInProgress2.child;
            if (primaryChildFragment !== null) {
              workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
            }
          }
        }
      }
      return null;
    }
    case HostPortal:
      popHostContainer(workInProgress2);
      updateHostContainer(current2, workInProgress2);
      if (current2 === null) {
        (void 0)(workInProgress2.stateNode.containerInfo);
      }
      bubbleProperties(workInProgress2);
      return null;
    case ContextProvider:
      let context;
      if (enableRenderableContext) {
        context = workInProgress2.type;
      } else {
        context = workInProgress2.type._context;
      }
      popProvider(context, workInProgress2);
      bubbleProperties(workInProgress2);
      return null;
    case IncompleteClassComponent: {
      if (disableLegacyMode) {
        break;
      }
      const Component2 = workInProgress2.type;
      if (isContextProvider(Component2)) {
        popContext(workInProgress2);
      }
      bubbleProperties(workInProgress2);
      return null;
    }
    case SuspenseListComponent: {
      popSuspenseListContext(workInProgress2);
      const renderState = workInProgress2.memoizedState;
      if (renderState === null) {
        bubbleProperties(workInProgress2);
        return null;
      }
      let didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
      const renderedTail = renderState.rendering;
      if (renderedTail === null) {
        if (!didSuspendAlready) {
          const cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
          if (!cannotBeSuspended) {
            let row = workInProgress2.child;
            while (row !== null) {
              const suspended = findFirstSuspended(row);
              if (suspended !== null) {
                didSuspendAlready = true;
                workInProgress2.flags |= DidCapture;
                cutOffTailIfNeeded(renderState, false);
                const retryQueue = suspended.updateQueue;
                workInProgress2.updateQueue = retryQueue;
                scheduleRetryEffect(workInProgress2, retryQueue);
                workInProgress2.subtreeFlags = NoFlags;
                resetChildFibers(workInProgress2, renderLanes2);
                pushSuspenseListContext(
                  workInProgress2,
                  setShallowSuspenseListContext(
                    suspenseStackCursor.current,
                    ForceSuspenseFallback
                  )
                );
                return workInProgress2.child;
              }
              row = row.sibling;
            }
          }
          if (renderState.tail !== null && now() > getRenderTargetTime()) {
            workInProgress2.flags |= DidCapture;
            didSuspendAlready = true;
            cutOffTailIfNeeded(renderState, false);
            workInProgress2.lanes = SomeRetryLane;
          }
        } else {
          cutOffTailIfNeeded(renderState, false);
        }
      } else {
        if (!didSuspendAlready) {
          const suspended = findFirstSuspended(renderedTail);
          if (suspended !== null) {
            workInProgress2.flags |= DidCapture;
            didSuspendAlready = true;
            const retryQueue = suspended.updateQueue;
            workInProgress2.updateQueue = retryQueue;
            scheduleRetryEffect(workInProgress2, retryQueue);
            cutOffTailIfNeeded(renderState, true);
            if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
              bubbleProperties(workInProgress2);
              return null;
            }
          } else if (
            // The time it took to render last row is greater than the remaining
            // time we have to render. So rendering one more row would likely
            // exceed it.
            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
          ) {
            workInProgress2.flags |= DidCapture;
            didSuspendAlready = true;
            cutOffTailIfNeeded(renderState, false);
            workInProgress2.lanes = SomeRetryLane;
          }
        }
        if (renderState.isBackwards) {
          renderedTail.sibling = workInProgress2.child;
          workInProgress2.child = renderedTail;
        } else {
          const previousSibling = renderState.last;
          if (previousSibling !== null) {
            previousSibling.sibling = renderedTail;
          } else {
            workInProgress2.child = renderedTail;
          }
          renderState.last = renderedTail;
        }
      }
      if (renderState.tail !== null) {
        const next = renderState.tail;
        renderState.rendering = next;
        renderState.tail = next.sibling;
        renderState.renderingStartTime = now();
        next.sibling = null;
        let suspenseContext = suspenseStackCursor.current;
        if (didSuspendAlready) {
          suspenseContext = setShallowSuspenseListContext(
            suspenseContext,
            ForceSuspenseFallback
          );
        } else {
          suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);
        }
        pushSuspenseListContext(workInProgress2, suspenseContext);
        return next;
      }
      bubbleProperties(workInProgress2);
      return null;
    }
    case ScopeComponent: {
      if (enableScopeAPI) {
        if (current2 === null) {
          const scopeInstance = createScopeInstance();
          workInProgress2.stateNode = scopeInstance;
          (void 0)(scopeInstance, workInProgress2);
          if (workInProgress2.ref !== null) {
            markUpdate(workInProgress2);
          }
        } else {
          if (workInProgress2.ref !== null) {
            markUpdate(workInProgress2);
          }
        }
        bubbleProperties(workInProgress2);
        return null;
      }
      break;
    }
    case OffscreenComponent:
    case LegacyHiddenComponent: {
      popSuspenseHandler(workInProgress2);
      popHiddenContext(workInProgress2);
      const nextState = workInProgress2.memoizedState;
      const nextIsHidden = nextState !== null;
      if (enableLegacyHidden && workInProgress2.tag === LegacyHiddenComponent) {
      } else {
        if (current2 !== null) {
          const prevState = current2.memoizedState;
          const prevIsHidden = prevState !== null;
          if (prevIsHidden !== nextIsHidden) {
            workInProgress2.flags |= Visibility;
          }
        } else {
          if (nextIsHidden) {
            workInProgress2.flags |= Visibility;
          }
        }
      }
      if (!nextIsHidden || !disableLegacyMode && (workInProgress2.mode & ConcurrentMode) === NoMode) {
        bubbleProperties(workInProgress2);
      } else {
        if (includesSomeLane(renderLanes2, OffscreenLane) && // Also don't bubble if the tree suspended
        (workInProgress2.flags & DidCapture) === NoLanes) {
          bubbleProperties(workInProgress2);
          if ((!enableLegacyHidden || workInProgress2.tag !== LegacyHiddenComponent) && workInProgress2.subtreeFlags & (Placement | Update)) {
            workInProgress2.flags |= Visibility;
          }
        }
      }
      const offscreenQueue = workInProgress2.updateQueue;
      if (offscreenQueue !== null) {
        const retryQueue = offscreenQueue.retryQueue;
        scheduleRetryEffect(workInProgress2, retryQueue);
      }
      let previousCache = null;
      if (current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null) {
        previousCache = current2.memoizedState.cachePool.pool;
      }
      let cache3 = null;
      if (workInProgress2.memoizedState !== null && workInProgress2.memoizedState.cachePool !== null) {
        cache3 = workInProgress2.memoizedState.cachePool.pool;
      }
      if (cache3 !== previousCache) {
        workInProgress2.flags |= Passive;
      }
      popTransition(workInProgress2, current2);
      return null;
    }
    case CacheComponent: {
      let previousCache = null;
      if (current2 !== null) {
        previousCache = current2.memoizedState.cache;
      }
      const cache3 = workInProgress2.memoizedState.cache;
      if (cache3 !== previousCache) {
        workInProgress2.flags |= Passive;
      }
      popCacheProvider(workInProgress2, cache3);
      bubbleProperties(workInProgress2);
      return null;
    }
    case TracingMarkerComponent: {
      if (enableTransitionTracing) {
        const instance = workInProgress2.stateNode;
        if (instance !== null) {
          popMarkerInstance(workInProgress2);
        }
        bubbleProperties(workInProgress2);
      }
      return null;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        workInProgress2.flags |= ViewTransitionStatic;
        bubbleProperties(workInProgress2);
      }
      return null;
    }
    case Throw: {
      if (!disableLegacyMode) {
        return null;
      }
    }
  }
  throw new Error(
    `Unknown unit of work tag (${workInProgress2.tag}). This error is likely caused by a bug in React. Please file an issue.`
  );
}

// dist/react-reconciler/src/ReactFiberUnwindWork.js
function unwindWork(current2, workInProgress2, renderLanes2) {
  popTreeContext(workInProgress2);
  switch (workInProgress2.tag) {
    case ClassComponent: {
      const Component2 = workInProgress2.type;
      if (isContextProvider(Component2)) {
        popContext(workInProgress2);
      }
      const flags = workInProgress2.flags;
      if (flags & ShouldCapture) {
        workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
        if (enableProfilerTimer && (workInProgress2.mode & ProfileMode) !== NoMode) {
          transferActualDuration(workInProgress2);
        }
        return workInProgress2;
      }
      return null;
    }
    case HostRoot: {
      const root2 = workInProgress2.stateNode;
      const cache4 = workInProgress2.memoizedState.cache;
      popCacheProvider(workInProgress2, cache4);
      if (enableTransitionTracing) {
        popRootMarkerInstance(workInProgress2);
      }
      popRootTransition(workInProgress2, root2, renderLanes2);
      popHostContainer(workInProgress2);
      popTopLevelContextObject(workInProgress2);
      const flags = workInProgress2.flags;
      if ((flags & ShouldCapture) !== NoFlags && (flags & DidCapture) === NoFlags) {
        workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
        return workInProgress2;
      }
      return null;
    }
    case HostHoistable:
    case HostSingleton:
    case HostComponent: {
      popHostContext(workInProgress2);
      return null;
    }
    case ActivityComponent: {
      const activityState = workInProgress2.memoizedState;
      if (activityState !== null) {
        popSuspenseHandler(workInProgress2);
        if (workInProgress2.alternate === null) {
          throw new Error(
            "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
          );
        }
        resetHydrationState();
      }
      const flags = workInProgress2.flags;
      if (flags & ShouldCapture) {
        workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
        if (enableProfilerTimer && (workInProgress2.mode & ProfileMode) !== NoMode) {
          transferActualDuration(workInProgress2);
        }
        return workInProgress2;
      }
      return null;
    }
    case SuspenseComponent: {
      popSuspenseHandler(workInProgress2);
      const suspenseState = workInProgress2.memoizedState;
      if (suspenseState !== null && suspenseState.dehydrated !== null) {
        if (workInProgress2.alternate === null) {
          throw new Error(
            "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
          );
        }
        resetHydrationState();
      }
      const flags = workInProgress2.flags;
      if (flags & ShouldCapture) {
        workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
        if (enableProfilerTimer && (workInProgress2.mode & ProfileMode) !== NoMode) {
          transferActualDuration(workInProgress2);
        }
        return workInProgress2;
      }
      return null;
    }
    case SuspenseListComponent: {
      popSuspenseListContext(workInProgress2);
      return null;
    }
    case HostPortal:
      popHostContainer(workInProgress2);
      return null;
    case ContextProvider:
      let context;
      if (enableRenderableContext) {
        context = workInProgress2.type;
      } else {
        context = workInProgress2.type._context;
      }
      popProvider(context, workInProgress2);
      return null;
    case OffscreenComponent:
    case LegacyHiddenComponent: {
      popSuspenseHandler(workInProgress2);
      popHiddenContext(workInProgress2);
      popTransition(workInProgress2, current2);
      const flags = workInProgress2.flags;
      if (flags & ShouldCapture) {
        workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
        if (enableProfilerTimer && (workInProgress2.mode & ProfileMode) !== NoMode) {
          transferActualDuration(workInProgress2);
        }
        return workInProgress2;
      }
      return null;
    }
    case CacheComponent:
      const cache3 = workInProgress2.memoizedState.cache;
      popCacheProvider(workInProgress2, cache3);
      return null;
    case TracingMarkerComponent:
      if (enableTransitionTracing) {
        if (workInProgress2.stateNode !== null) {
          popMarkerInstance(workInProgress2);
        }
      }
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case ClassComponent: {
      const childContextTypes = interruptedWork.type.childContextTypes;
      if (childContextTypes !== null && childContextTypes !== void 0) {
        popContext(interruptedWork);
      }
      break;
    }
    case HostRoot: {
      const root2 = interruptedWork.stateNode;
      const cache4 = interruptedWork.memoizedState.cache;
      popCacheProvider(interruptedWork, cache4);
      if (enableTransitionTracing) {
        popRootMarkerInstance(interruptedWork);
      }
      popRootTransition(interruptedWork, root2, renderLanes2);
      popHostContainer(interruptedWork);
      popTopLevelContextObject(interruptedWork);
      break;
    }
    case HostHoistable:
    case HostSingleton:
    case HostComponent: {
      popHostContext(interruptedWork);
      break;
    }
    case HostPortal:
      popHostContainer(interruptedWork);
      break;
    case ActivityComponent: {
      if (interruptedWork.memoizedState !== null) {
        popSuspenseHandler(interruptedWork);
      }
      break;
    }
    case SuspenseComponent:
      popSuspenseHandler(interruptedWork);
      break;
    case SuspenseListComponent:
      popSuspenseListContext(interruptedWork);
      break;
    case ContextProvider:
      let context;
      if (enableRenderableContext) {
        context = interruptedWork.type;
      } else {
        context = interruptedWork.type._context;
      }
      popProvider(context, interruptedWork);
      break;
    case OffscreenComponent:
    case LegacyHiddenComponent:
      popSuspenseHandler(interruptedWork);
      popHiddenContext(interruptedWork);
      popTransition(interruptedWork, current2);
      break;
    case CacheComponent:
      const cache3 = interruptedWork.memoizedState.cache;
      popCacheProvider(interruptedWork, cache3);
      break;
    case TracingMarkerComponent:
      if (enableTransitionTracing) {
        const instance = interruptedWork.stateNode;
        if (instance !== null) {
          popMarkerInstance(interruptedWork);
        }
      }
      break;
    default:
      break;
  }
}

// dist/react-reconciler/src/ReactFiberCommitEffects.js
function shouldProfile(current2) {
  return enableProfilerTimer && enableProfilerCommitHooks && (current2.mode & ProfileMode) !== NoMode;
}
function commitHookLayoutEffects(finishedWork, hookFlags) {
  if (shouldProfile(finishedWork)) {
    startEffectTimer();
    commitHookEffectListMount(hookFlags, finishedWork);
    recordEffectDuration(finishedWork);
  } else {
    commitHookEffectListMount(hookFlags, finishedWork);
  }
}
function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
  if (shouldProfile(finishedWork)) {
    startEffectTimer();
    commitHookEffectListUnmount(
      hookFlags,
      finishedWork,
      nearestMountedAncestor
    );
    recordEffectDuration(finishedWork);
  } else {
    commitHookEffectListUnmount(
      hookFlags,
      finishedWork,
      nearestMountedAncestor
    );
  }
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    const updateQueue = finishedWork.updateQueue;
    const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
    if (lastEffect !== null) {
      const firstEffect = lastEffect.next;
      let effect = firstEffect;
      do {
        if ((effect.tag & flags) === flags) {
          if (enableSchedulingProfiler) {
            if ((flags & Passive2) !== NoFlags2) {
              markComponentPassiveEffectMountStarted(finishedWork);
            } else if ((flags & Layout) !== NoFlags2) {
              markComponentLayoutEffectMountStarted(finishedWork);
            }
          }
          let destroy;
          if (false) {
            if ((flags & Insertion) !== NoFlags2) {
              setIsRunningInsertionEffect(true);
            }
            destroy = runWithFiberInDEV(finishedWork, callCreateInDEV, effect);
            if ((flags & Insertion) !== NoFlags2) {
              setIsRunningInsertionEffect(false);
            }
          } else {
            const create = effect.create;
            const inst = effect.inst;
            destroy = create();
            inst.destroy = destroy;
          }
          if (enableSchedulingProfiler) {
            if ((flags & Passive2) !== NoFlags2) {
              markComponentPassiveEffectMountStopped();
            } else if ((flags & Layout) !== NoFlags2) {
              markComponentLayoutEffectMountStopped();
            }
          }
          if (false) {
            if (destroy !== void 0 && typeof destroy !== "function") {
              let hookName;
              if ((effect.tag & Layout) !== NoFlags) {
                hookName = "useLayoutEffect";
              } else if ((effect.tag & Insertion) !== NoFlags) {
                hookName = "useInsertionEffect";
              } else {
                hookName = "useEffect";
              }
              let addendum;
              if (destroy === null) {
                addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
              } else if (typeof destroy.then === "function") {
                addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching`;
              } else {
                addendum = " You returned: " + destroy;
              }
              runWithFiberInDEV(
                finishedWork,
                (n, a) => {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    n,
                    a
                  );
                },
                hookName,
                addendum
              );
            }
          }
        }
        effect = effect.next;
      } while (effect !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
  try {
    const updateQueue = finishedWork.updateQueue;
    const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
    if (lastEffect !== null) {
      const firstEffect = lastEffect.next;
      let effect = firstEffect;
      do {
        if ((effect.tag & flags) === flags) {
          const inst = effect.inst;
          const destroy = inst.destroy;
          if (destroy !== void 0) {
            inst.destroy = void 0;
            if (enableSchedulingProfiler) {
              if ((flags & Passive2) !== NoFlags2) {
                markComponentPassiveEffectUnmountStarted(finishedWork);
              } else if ((flags & Layout) !== NoFlags2) {
                markComponentLayoutEffectUnmountStarted(finishedWork);
              }
            }
            if (false) {
              if ((flags & Insertion) !== NoFlags2) {
                setIsRunningInsertionEffect(true);
              }
            }
            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
            if (false) {
              if ((flags & Insertion) !== NoFlags2) {
                setIsRunningInsertionEffect(false);
              }
            }
            if (enableSchedulingProfiler) {
              if ((flags & Passive2) !== NoFlags2) {
                markComponentPassiveEffectUnmountStopped();
              } else if ((flags & Layout) !== NoFlags2) {
                markComponentLayoutEffectUnmountStopped();
              }
            }
          }
        }
        effect = effect.next;
      } while (effect !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookPassiveMountEffects(finishedWork, hookFlags) {
  if (shouldProfile(finishedWork)) {
    startEffectTimer();
    commitHookEffectListMount(hookFlags, finishedWork);
    recordEffectDuration(finishedWork);
  } else {
    commitHookEffectListMount(hookFlags, finishedWork);
  }
}
function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
  if (shouldProfile(finishedWork)) {
    startEffectTimer();
    commitHookEffectListUnmount(
      hookFlags,
      finishedWork,
      nearestMountedAncestor
    );
    recordEffectDuration(finishedWork);
  } else {
    commitHookEffectListUnmount(
      hookFlags,
      finishedWork,
      nearestMountedAncestor
    );
  }
}
function commitClassLayoutLifecycles(finishedWork, current2) {
  const instance = finishedWork.stateNode;
  if (current2 === null) {
    if (false) {
      if (!finishedWork.type.defaultProps && !("ref" in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {
        if (instance.props !== finishedWork.memoizedProps) {
          console.error(
            "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          );
        }
        if (instance.state !== finishedWork.memoizedState) {
          console.error(
            "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          );
        }
      }
    }
    if (shouldProfile(finishedWork)) {
      startEffectTimer();
      if (false) {
        runWithFiberInDEV(
          finishedWork,
          callComponentDidMountInDEV,
          finishedWork,
          instance
        );
      } else {
        try {
          instance.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      recordEffectDuration(finishedWork);
    } else {
      if (false) {
        runWithFiberInDEV(
          finishedWork,
          callComponentDidMountInDEV,
          finishedWork,
          instance
        );
      } else {
        try {
          instance.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
  } else {
    const prevProps = resolveClassComponentProps(
      finishedWork.type,
      current2.memoizedProps,
      finishedWork.elementType === finishedWork.type
    );
    const prevState = current2.memoizedState;
    if (false) {
      if (!finishedWork.type.defaultProps && !("ref" in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {
        if (instance.props !== finishedWork.memoizedProps) {
          console.error(
            "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          );
        }
        if (instance.state !== finishedWork.memoizedState) {
          console.error(
            "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          );
        }
      }
    }
    if (shouldProfile(finishedWork)) {
      startEffectTimer();
      if (false) {
        runWithFiberInDEV(
          finishedWork,
          callComponentDidUpdateInDEV,
          finishedWork,
          instance,
          prevProps,
          prevState,
          instance.__reactInternalSnapshotBeforeUpdate
        );
      } else {
        try {
          instance.componentDidUpdate(
            prevProps,
            prevState,
            instance.__reactInternalSnapshotBeforeUpdate
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      recordEffectDuration(finishedWork);
    } else {
      if (false) {
        runWithFiberInDEV(
          finishedWork,
          callComponentDidUpdateInDEV,
          finishedWork,
          instance,
          prevProps,
          prevState,
          instance.__reactInternalSnapshotBeforeUpdate
        );
      } else {
        try {
          instance.componentDidUpdate(
            prevProps,
            prevState,
            instance.__reactInternalSnapshotBeforeUpdate
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
  }
}
function commitClassDidMount(finishedWork) {
  const instance = finishedWork.stateNode;
  if (typeof instance.componentDidMount === "function") {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        callComponentDidMountInDEV,
        finishedWork,
        instance
      );
    } else {
      try {
        instance.componentDidMount();
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
  }
}
function commitClassCallbacks(finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  if (updateQueue !== null) {
    const instance = finishedWork.stateNode;
    if (false) {
      if (!finishedWork.type.defaultProps && !("ref" in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {
        if (instance.props !== finishedWork.memoizedProps) {
          console.error(
            "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          );
        }
        if (instance.state !== finishedWork.memoizedState) {
          console.error(
            "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          );
        }
      }
    }
    try {
      if (false) {
        runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
      } else {
        commitCallbacks(updateQueue, instance);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function commitClassHiddenCallbacks(finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  if (updateQueue !== null) {
    const instance = finishedWork.stateNode;
    try {
      if (false) {
        runWithFiberInDEV(
          finishedWork,
          commitHiddenCallbacks,
          updateQueue,
          instance
        );
      } else {
        commitHiddenCallbacks(updateQueue, instance);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function commitRootCallbacks(finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  if (updateQueue !== null) {
    let instance = null;
    if (finishedWork.child !== null) {
      switch (finishedWork.child.tag) {
        case HostSingleton:
        case HostComponent:
          instance = (void 0)(finishedWork.child.stateNode);
          break;
        case ClassComponent:
          instance = finishedWork.child.stateNode;
          break;
      }
    }
    try {
      if (false) {
        runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
      } else {
        commitCallbacks(updateQueue, instance);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
if (false) {
  didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
}
function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
  return instance.getSnapshotBeforeUpdate(prevProps, prevState);
}
function commitClassSnapshot(finishedWork, current2) {
  const prevProps = current2.memoizedProps;
  const prevState = current2.memoizedState;
  const instance = finishedWork.stateNode;
  if (false) {
    if (!finishedWork.type.defaultProps && !("ref" in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {
      if (instance.props !== finishedWork.memoizedProps) {
        console.error(
          "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          getComponentNameFromFiber(finishedWork) || "instance"
        );
      }
      if (instance.state !== finishedWork.memoizedState) {
        console.error(
          "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          getComponentNameFromFiber(finishedWork) || "instance"
        );
      }
    }
  }
  try {
    const resolvedPrevProps = resolveClassComponentProps(
      finishedWork.type,
      prevProps,
      finishedWork.elementType === finishedWork.type
    );
    let snapshot;
    if (false) {
      snapshot = runWithFiberInDEV(
        finishedWork,
        callGetSnapshotBeforeUpdates,
        instance,
        resolvedPrevProps,
        prevState
      );
      const didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
        didWarnSet.add(finishedWork.type);
        runWithFiberInDEV(finishedWork, () => {
          console.error(
            "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
            getComponentNameFromFiber(finishedWork)
          );
        });
      }
    } else {
      snapshot = callGetSnapshotBeforeUpdates(
        instance,
        resolvedPrevProps,
        prevState
      );
    }
    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
  instance.props = resolveClassComponentProps(
    current2.type,
    current2.memoizedProps,
    current2.elementType === current2.type
  );
  instance.state = current2.memoizedState;
  if (shouldProfile(current2)) {
    startEffectTimer();
    if (false) {
      runWithFiberInDEV(
        current2,
        callComponentWillUnmountInDEV,
        current2,
        nearestMountedAncestor,
        instance
      );
    } else {
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error);
      }
    }
    recordEffectDuration(current2);
  } else {
    if (false) {
      runWithFiberInDEV(
        current2,
        callComponentWillUnmountInDEV,
        current2,
        nearestMountedAncestor,
        instance
      );
    } else {
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error);
      }
    }
  }
}
function commitAttachRef(finishedWork) {
  const ref = finishedWork.ref;
  if (ref !== null) {
    let instanceToUse;
    switch (finishedWork.tag) {
      case HostHoistable:
      case HostSingleton:
      case HostComponent:
        instanceToUse = (void 0)(finishedWork.stateNode);
        break;
      case ViewTransitionComponent: {
        if (enableViewTransition) {
          const instance = finishedWork.stateNode;
          const props = finishedWork.memoizedProps;
          const name = getViewTransitionName(props, instance);
          if (instance.ref === null || instance.ref.name !== name) {
            instance.ref = (void 0)(name);
          }
          instanceToUse = instance.ref;
          break;
        }
        instanceToUse = finishedWork.stateNode;
        break;
      }
      case Fragment:
        if (enableFragmentRefs) {
          const instance = finishedWork.stateNode;
          if (instance === null) {
            finishedWork.stateNode = (void 0)(finishedWork);
          }
          instanceToUse = finishedWork.stateNode;
          break;
        }
      // Fallthrough
      default:
        instanceToUse = finishedWork.stateNode;
    }
    if (typeof ref === "function") {
      if (shouldProfile(finishedWork)) {
        try {
          startEffectTimer();
          finishedWork.refCleanup = ref(instanceToUse);
        } finally {
          recordEffectDuration(finishedWork);
        }
      } else {
        finishedWork.refCleanup = ref(instanceToUse);
      }
    } else {
      if (false) {
        if (typeof ref === "string") {
          console.error("String refs are no longer supported.");
        } else if (!ref.hasOwnProperty("current")) {
          console.error(
            "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
            getComponentNameFromFiber(finishedWork)
          );
        }
      }
      ref.current = instanceToUse;
    }
  }
}
function safelyAttachRef(current2, nearestMountedAncestor) {
  try {
    if (false) {
      runWithFiberInDEV(current2, commitAttachRef, current2);
    } else {
      commitAttachRef(current2);
    }
  } catch (error) {
    captureCommitPhaseError(current2, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current2, nearestMountedAncestor) {
  const ref = current2.ref;
  const refCleanup = current2.refCleanup;
  if (ref !== null) {
    if (typeof refCleanup === "function") {
      try {
        if (shouldProfile(current2)) {
          try {
            startEffectTimer();
            if (false) {
              runWithFiberInDEV(current2, refCleanup);
            } else {
              refCleanup();
            }
          } finally {
            recordEffectDuration(current2);
          }
        } else {
          if (false) {
            runWithFiberInDEV(current2, refCleanup);
          } else {
            refCleanup();
          }
        }
      } catch (error) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error);
      } finally {
        current2.refCleanup = null;
        const finishedWork = current2.alternate;
        if (finishedWork != null) {
          finishedWork.refCleanup = null;
        }
      }
    } else if (typeof ref === "function") {
      try {
        if (shouldProfile(current2)) {
          try {
            startEffectTimer();
            if (false) {
              runWithFiberInDEV(current2, ref, null);
            } else {
              ref(null);
            }
          } finally {
            recordEffectDuration(current2);
          }
        } else {
          if (false) {
            runWithFiberInDEV(current2, ref, null);
          } else {
            ref(null);
          }
        }
      } catch (error) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error);
      }
    } else {
      ref.current = null;
    }
  }
}
function safelyCallDestroy(current2, nearestMountedAncestor, destroy, resource) {
  const destroy_ = resource == null ? destroy : destroy.bind(null, resource);
  if (false) {
    runWithFiberInDEV(
      current2,
      callDestroyInDEV,
      current2,
      nearestMountedAncestor,
      destroy_
    );
  } else {
    try {
      destroy_();
    } catch (error) {
      captureCommitPhaseError(current2, nearestMountedAncestor, error);
    }
  }
}
function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
  const { id, onCommit, onRender } = finishedWork.memoizedProps;
  let phase = current2 === null ? "mount" : "update";
  if (enableProfilerNestedUpdatePhase) {
    if (isCurrentUpdateNested()) {
      phase = "nested-update";
    }
  }
  if (typeof onRender === "function") {
    onRender(
      id,
      phase,
      // $FlowFixMe: This should be always a number in profiling mode
      finishedWork.actualDuration,
      // $FlowFixMe: This should be always a number in profiling mode
      finishedWork.treeBaseDuration,
      // $FlowFixMe: This should be always a number in profiling mode
      finishedWork.actualStartTime,
      commitStartTime2
    );
  }
  if (enableProfilerCommitHooks) {
    if (typeof onCommit === "function") {
      onCommit(id, phase, effectDuration, commitStartTime2);
    }
  }
}
function commitProfilerUpdate(finishedWork, current2, commitStartTime2, effectDuration) {
  if (enableProfilerTimer) {
    try {
      if (false) {
        runWithFiberInDEV(
          finishedWork,
          commitProfiler,
          finishedWork,
          current2,
          commitStartTime2,
          effectDuration
        );
      } else {
        commitProfiler(finishedWork, current2, commitStartTime2, effectDuration);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
  const { id, onPostCommit } = finishedWork.memoizedProps;
  let phase = current2 === null ? "mount" : "update";
  if (enableProfilerNestedUpdatePhase) {
    if (isCurrentUpdateNested()) {
      phase = "nested-update";
    }
  }
  if (typeof onPostCommit === "function") {
    onPostCommit(id, phase, passiveEffectDuration, commitStartTime2);
  }
}
function commitProfilerPostCommit(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        commitProfilerPostCommitImpl,
        finishedWork,
        current2,
        commitStartTime2,
        passiveEffectDuration
      );
    } else {
      commitProfilerPostCommitImpl(
        finishedWork,
        current2,
        commitStartTime2,
        passiveEffectDuration
      );
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}

// dist/react-reconciler/src/ReactFiberMutationTracking.js
var rootMutationContext = false;
var viewTransitionMutationContext = false;
function pushRootMutationContext() {
  if (enableDefaultTransitionIndicator) {
    rootMutationContext = false;
  }
  if (enableViewTransition) {
    viewTransitionMutationContext = false;
  }
}
function pushMutationContext() {
  if (!enableViewTransition) {
    return false;
  }
  const prev = viewTransitionMutationContext;
  viewTransitionMutationContext = false;
  return prev;
}
function popMutationContext(prev) {
  if (enableViewTransition) {
    if (viewTransitionMutationContext) {
      rootMutationContext = true;
    }
    viewTransitionMutationContext = prev;
  }
}
function trackHostMutation() {
  if (enableViewTransition) {
    viewTransitionMutationContext = true;
  } else if (enableDefaultTransitionIndicator) {
    rootMutationContext = true;
  }
}

// dist/react-reconciler/src/ReactFiberCommitHostEffects.js
function commitHostMount(finishedWork) {
  const type = finishedWork.type;
  const props = finishedWork.memoizedProps;
  const instance = finishedWork.stateNode;
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        instance,
        type,
        props,
        finishedWork
      );
    } else {
      (void 0)(instance, type, props, finishedWork);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostHydratedInstance(finishedWork) {
  const type = finishedWork.type;
  const props = finishedWork.memoizedProps;
  const instance = finishedWork.stateNode;
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        instance,
        type,
        props,
        finishedWork
      );
    } else {
      (void 0)(instance, type, props, finishedWork);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        finishedWork.stateNode,
        finishedWork.type,
        oldProps,
        newProps,
        finishedWork
      );
    } else {
      (void 0)(
        finishedWork.stateNode,
        finishedWork.type,
        oldProps,
        newProps,
        finishedWork
      );
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostTextUpdate(finishedWork, newText, oldText) {
  const textInstance = finishedWork.stateNode;
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        textInstance,
        oldText,
        newText
      );
    } else {
      (void 0)(textInstance, oldText, newText);
    }
    trackHostMutation();
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostResetTextContent(finishedWork) {
  const instance = finishedWork.stateNode;
  try {
    if (false) {
      runWithFiberInDEV(finishedWork, void 0, instance);
    } else {
      (void 0)(instance);
    }
    trackHostMutation();
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitShowHideSuspenseBoundary(node, isHidden) {
  try {
    const instance = node.stateNode;
    if (isHidden) {
      if (false) {
        runWithFiberInDEV(node, void 0, instance);
      } else {
        (void 0)(instance);
      }
    } else {
      if (false) {
        runWithFiberInDEV(node, void 0, node.stateNode);
      } else {
        (void 0)(node.stateNode);
      }
    }
  } catch (error) {
    captureCommitPhaseError(node, node.return, error);
  }
}
function commitShowHideHostInstance(node, isHidden) {
  try {
    const instance = node.stateNode;
    if (isHidden) {
      if (false) {
        runWithFiberInDEV(node, void 0, instance);
      } else {
        (void 0)(instance);
      }
    } else {
      if (false) {
        runWithFiberInDEV(
          node,
          void 0,
          node.stateNode,
          node.memoizedProps
        );
      } else {
        (void 0)(node.stateNode, node.memoizedProps);
      }
    }
  } catch (error) {
    captureCommitPhaseError(node, node.return, error);
  }
}
function commitShowHideHostTextInstance(node, isHidden) {
  try {
    const instance = node.stateNode;
    if (isHidden) {
      if (false) {
        runWithFiberInDEV(node, void 0, instance);
      } else {
        (void 0)(instance);
      }
    } else {
      if (false) {
        runWithFiberInDEV(
          node,
          void 0,
          instance,
          node.memoizedProps
        );
      } else {
        (void 0)(instance, node.memoizedProps);
      }
    }
    trackHostMutation();
  } catch (error) {
    captureCommitPhaseError(node, node.return, error);
  }
}
function commitNewChildToFragmentInstances(fiber, parentFragmentInstances) {
  for (let i = 0; i < parentFragmentInstances.length; i++) {
    const fragmentInstance = parentFragmentInstances[i];
    (void 0)(fiber.stateNode, fragmentInstance);
  }
}
function commitFragmentInstanceInsertionEffects(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isFragmentInstanceParent(parent)) {
      const fragmentInstance = parent.stateNode;
      (void 0)(fiber.stateNode, fragmentInstance);
    }
    if (isHostParent(parent)) {
      return;
    }
    parent = parent.return;
  }
}
function commitFragmentInstanceDeletionEffects(fiber) {
  let parent = fiber.return;
  while (parent !== null) {
    if (isFragmentInstanceParent(parent)) {
      const fragmentInstance = parent.stateNode;
      (void 0)(fiber.stateNode, fragmentInstance);
    }
    if (isHostParent(parent)) {
      return;
    }
    parent = parent.return;
  }
}
function isHostParent(fiber) {
  return fiber.tag === HostComponent || fiber.tag === HostRoot || (void 0 ? fiber.tag === HostHoistable : false) || (void 0 ? fiber.tag === HostSingleton && (void 0)(fiber.type) : false) || fiber.tag === HostPortal;
}
function isFragmentInstanceParent(fiber) {
  return fiber && fiber.tag === Fragment && fiber.stateNode !== null;
}
function getHostSibling(fiber) {
  let node = fiber;
  siblings: while (true) {
    while (node.sibling === null) {
      if (node.return === null || isHostParent(node.return)) {
        return null;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
      if (void 0 && node.tag === HostSingleton && (void 0)(node.type)) {
        continue siblings;
      }
      if (node.flags & Placement) {
        continue siblings;
      }
      if (node.child === null || node.tag === HostPortal) {
        continue siblings;
      } else {
        node.child.return = node;
        node = node.child;
      }
    }
    if (!(node.flags & Placement)) {
      return node.stateNode;
    }
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent, parentFragmentInstances) {
  const { tag } = node;
  const isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    const stateNode = node.stateNode;
    if (before) {
      (void 0)(parent, stateNode, before);
    } else {
      (void 0)(parent, stateNode);
    }
    if (enableFragmentRefs && tag === HostComponent && // Only run fragment insertion effects for initial insertions
    node.alternate === null && parentFragmentInstances !== null) {
      commitNewChildToFragmentInstances(node, parentFragmentInstances);
    }
    trackHostMutation();
    return;
  } else if (tag === HostPortal) {
    return;
  }
  if ((void 0 ? tag === HostSingleton : false) && (void 0)(node.type)) {
    parent = node.stateNode;
    before = null;
  }
  const child = node.child;
  if (child !== null) {
    insertOrAppendPlacementNodeIntoContainer(
      child,
      before,
      parent,
      parentFragmentInstances
    );
    let sibling = child.sibling;
    while (sibling !== null) {
      insertOrAppendPlacementNodeIntoContainer(
        sibling,
        before,
        parent,
        parentFragmentInstances
      );
      sibling = sibling.sibling;
    }
  }
}
function insertOrAppendPlacementNode(node, before, parent, parentFragmentInstances) {
  const { tag } = node;
  const isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    const stateNode = node.stateNode;
    if (before) {
      (void 0)(parent, stateNode, before);
    } else {
      (void 0)(parent, stateNode);
    }
    if (enableFragmentRefs && tag === HostComponent && // Only run fragment insertion effects for initial insertions
    node.alternate === null && parentFragmentInstances !== null) {
      commitNewChildToFragmentInstances(node, parentFragmentInstances);
    }
    trackHostMutation();
    return;
  } else if (tag === HostPortal) {
    return;
  }
  if ((void 0 ? tag === HostSingleton : false) && (void 0)(node.type)) {
    parent = node.stateNode;
  }
  const child = node.child;
  if (child !== null) {
    insertOrAppendPlacementNode(child, before, parent, parentFragmentInstances);
    let sibling = child.sibling;
    while (sibling !== null) {
      insertOrAppendPlacementNode(
        sibling,
        before,
        parent,
        parentFragmentInstances
      );
      sibling = sibling.sibling;
    }
  }
}
function commitPlacement(finishedWork) {
  if (!void 0) {
    return;
  }
  let hostParentFiber;
  let parentFragmentInstances = null;
  let parentFiber = finishedWork.return;
  while (parentFiber !== null) {
    if (enableFragmentRefs && isFragmentInstanceParent(parentFiber)) {
      const fragmentInstance = parentFiber.stateNode;
      if (parentFragmentInstances === null) {
        parentFragmentInstances = [fragmentInstance];
      } else {
        parentFragmentInstances.push(fragmentInstance);
      }
    }
    if (isHostParent(parentFiber)) {
      hostParentFiber = parentFiber;
      break;
    }
    parentFiber = parentFiber.return;
  }
  if (hostParentFiber == null) {
    throw new Error(
      "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  switch (hostParentFiber.tag) {
    case HostSingleton: {
      if (void 0) {
        const parent = hostParentFiber.stateNode;
        const before = getHostSibling(finishedWork);
        insertOrAppendPlacementNode(
          finishedWork,
          before,
          parent,
          parentFragmentInstances
        );
        break;
      }
    }
    case HostComponent: {
      const parent = hostParentFiber.stateNode;
      if (hostParentFiber.flags & ContentReset) {
        (void 0)(parent);
        hostParentFiber.flags &= ~ContentReset;
      }
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(
        finishedWork,
        before,
        parent,
        parentFragmentInstances
      );
      break;
    }
    case HostRoot:
    case HostPortal: {
      const parent = hostParentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);
      insertOrAppendPlacementNodeIntoContainer(
        finishedWork,
        before,
        parent,
        parentFragmentInstances
      );
      break;
    }
    default:
      throw new Error(
        "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
      );
  }
}
function commitHostPlacement(finishedWork) {
  try {
    if (false) {
      runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
    } else {
      commitPlacement(finishedWork);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostRemoveChildFromContainer(deletedFiber, nearestMountedAncestor, parentContainer, hostInstance) {
  try {
    if (false) {
      runWithFiberInDEV(
        deletedFiber,
        void 0,
        parentContainer,
        hostInstance
      );
    } else {
      (void 0)(parentContainer, hostInstance);
    }
    trackHostMutation();
  } catch (error) {
    captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
  }
}
function commitHostRemoveChild(deletedFiber, nearestMountedAncestor, parentInstance, hostInstance) {
  try {
    if (false) {
      runWithFiberInDEV(
        deletedFiber,
        void 0,
        parentInstance,
        hostInstance
      );
    } else {
      (void 0)(parentInstance, hostInstance);
    }
    trackHostMutation();
  } catch (error) {
    captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
  }
}
function commitHostRootContainerChildren(root2, finishedWork) {
  const containerInfo = root2.containerInfo;
  const pendingChildren = root2.pendingChildren;
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        containerInfo,
        pendingChildren
      );
    } else {
      (void 0)(containerInfo, pendingChildren);
    }
    trackHostMutation();
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {
  const containerInfo = portal.containerInfo;
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        containerInfo,
        pendingChildren
      );
    } else {
      (void 0)(containerInfo, pendingChildren);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostHydratedContainer(root2, finishedWork) {
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        root2.containerInfo
      );
    } else {
      (void 0)(root2.containerInfo);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostHydratedActivity(activityInstance, finishedWork) {
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        activityInstance
      );
    } else {
      (void 0)(activityInstance);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostHydratedSuspense(suspenseInstance, finishedWork) {
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        suspenseInstance
      );
    } else {
      (void 0)(suspenseInstance);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostSingletonAcquisition(finishedWork) {
  const singleton = finishedWork.stateNode;
  const props = finishedWork.memoizedProps;
  try {
    if (false) {
      runWithFiberInDEV(
        finishedWork,
        void 0,
        finishedWork.type,
        props,
        singleton,
        finishedWork
      );
    } else {
      (void 0)(
        finishedWork.type,
        props,
        singleton,
        finishedWork
      );
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostSingletonRelease(releasingWork) {
  if (false) {
    runWithFiberInDEV(
      releasingWork,
      void 0,
      releasingWork.stateNode
    );
  } else {
    (void 0)(releasingWork.stateNode);
  }
}

// dist/react-reconciler/src/ReactFiberCommitViewTransitions.js
var shouldStartViewTransition = false;
function resetShouldStartViewTransition() {
  shouldStartViewTransition = false;
}
var appearingViewTransitions = null;
function resetAppearingViewTransitions() {
  appearingViewTransitions = null;
}
function trackAppearingViewTransition(name, state) {
  if (appearingViewTransitions === null) {
    appearingViewTransitions = /* @__PURE__ */ new Map();
  }
  appearingViewTransitions.set(name, state);
}
function trackEnterViewTransitions(placement) {
  if (placement.tag === ViewTransitionComponent || (placement.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
    shouldStartViewTransition = true;
  }
}
var viewTransitionCancelableChildren = null;
function pushViewTransitionCancelableScope() {
  const prevChildren = viewTransitionCancelableChildren;
  viewTransitionCancelableChildren = null;
  return prevChildren;
}
function popViewTransitionCancelableScope(prevChildren) {
  viewTransitionCancelableChildren = prevChildren;
}
var viewTransitionHostInstanceIdx = 0;
function applyViewTransitionToHostInstances(child, name, className, collectMeasurements, stopAtNestedViewTransitions) {
  viewTransitionHostInstanceIdx = 0;
  return applyViewTransitionToHostInstancesRecursive(
    child,
    name,
    className,
    collectMeasurements,
    stopAtNestedViewTransitions
  );
}
function applyViewTransitionToHostInstancesRecursive(child, name, className, collectMeasurements, stopAtNestedViewTransitions) {
  if (!void 0) {
    return false;
  }
  let inViewport = false;
  while (child !== null) {
    if (child.tag === HostComponent) {
      const instance = child.stateNode;
      if (collectMeasurements !== null) {
        const measurement = (void 0)(instance);
        collectMeasurements.push(measurement);
        if ((void 0)(measurement)) {
          inViewport = true;
        }
      } else if (!inViewport) {
        if ((void 0)((void 0)(instance))) {
          inViewport = true;
        }
      }
      shouldStartViewTransition = true;
      (void 0)(
        instance,
        viewTransitionHostInstanceIdx === 0 ? name : (
          // If we have multiple Host Instances below, we add a suffix to the name to give
          // each one a unique name.
          name + "_" + viewTransitionHostInstanceIdx
        ),
        className
      );
      viewTransitionHostInstanceIdx++;
    } else if (child.tag === OffscreenComponent && child.memoizedState !== null) {
    } else if (child.tag === ViewTransitionComponent && stopAtNestedViewTransitions) {
    } else {
      if (applyViewTransitionToHostInstancesRecursive(
        child.child,
        name,
        className,
        collectMeasurements,
        stopAtNestedViewTransitions
      )) {
        inViewport = true;
      }
    }
    child = child.sibling;
  }
  return inViewport;
}
function restoreViewTransitionOnHostInstances(child, stopAtNestedViewTransitions) {
  if (!void 0) {
    return;
  }
  while (child !== null) {
    if (child.tag === HostComponent) {
      const instance = child.stateNode;
      (void 0)(instance, child.memoizedProps);
    } else if (child.tag === OffscreenComponent && child.memoizedState !== null) {
    } else if (child.tag === ViewTransitionComponent && stopAtNestedViewTransitions) {
    } else {
      restoreViewTransitionOnHostInstances(
        child.child,
        stopAtNestedViewTransitions
      );
    }
    child = child.sibling;
  }
}
function commitAppearingPairViewTransitions(placement) {
  if ((placement.subtreeFlags & ViewTransitionNamedStatic) === NoFlags) {
    return;
  }
  let child = placement.child;
  while (child !== null) {
    if (child.tag === OffscreenComponent && child.memoizedState === null) {
    } else {
      commitAppearingPairViewTransitions(child);
      if (child.tag === ViewTransitionComponent && (child.flags & ViewTransitionNamedStatic) !== NoFlags) {
        const instance = child.stateNode;
        if (instance.paired) {
          const props = child.memoizedProps;
          if (props.name == null || props.name === "auto") {
            throw new Error(
              "Found a pair with an auto name. This is a bug in React."
            );
          }
          const name = props.name;
          const className = getViewTransitionClassName(
            props.default,
            props.share
          );
          if (className !== "none") {
            const inViewport = applyViewTransitionToHostInstances(
              child.child,
              name,
              className,
              null,
              false
            );
            if (!inViewport) {
              restoreViewTransitionOnHostInstances(child.child, false);
            }
          }
        }
      }
    }
    child = child.sibling;
  }
}
function commitEnterViewTransitions(placement, gesture) {
  if (placement.tag === ViewTransitionComponent) {
    const state = placement.stateNode;
    const props = placement.memoizedProps;
    const name = getViewTransitionName(props, state);
    const className = getViewTransitionClassName(
      props.default,
      state.paired ? props.share : props.enter
    );
    if (className !== "none") {
      const inViewport = applyViewTransitionToHostInstances(
        placement.child,
        name,
        className,
        null,
        false
      );
      if (!inViewport) {
        restoreViewTransitionOnHostInstances(placement.child, false);
      } else {
        commitAppearingPairViewTransitions(placement);
        if (!state.paired) {
          if (gesture) {
          } else {
            scheduleViewTransitionEvent(placement, props.onEnter);
          }
        }
      }
    } else {
      commitAppearingPairViewTransitions(placement);
    }
  } else if ((placement.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
    let child = placement.child;
    while (child !== null) {
      commitEnterViewTransitions(child, gesture);
      child = child.sibling;
    }
  } else {
    commitAppearingPairViewTransitions(placement);
  }
}
function commitDeletedPairViewTransitions(deletion) {
  if (appearingViewTransitions === null || appearingViewTransitions.size === 0) {
    return;
  }
  const pairs = appearingViewTransitions;
  if ((deletion.subtreeFlags & ViewTransitionNamedStatic) === NoFlags) {
    return;
  }
  let child = deletion.child;
  while (child !== null) {
    if (child.tag === OffscreenComponent && child.memoizedState === null) {
    } else {
      if (child.tag === ViewTransitionComponent && (child.flags & ViewTransitionNamedStatic) !== NoFlags) {
        const props = child.memoizedProps;
        const name = props.name;
        if (name != null && name !== "auto") {
          const pair = pairs.get(name);
          if (pair !== void 0) {
            const className = getViewTransitionClassName(
              props.default,
              props.share
            );
            if (className !== "none") {
              const inViewport = applyViewTransitionToHostInstances(
                child.child,
                name,
                className,
                null,
                false
              );
              if (!inViewport) {
                restoreViewTransitionOnHostInstances(child.child, false);
              } else {
                const oldInstance = child.stateNode;
                const newInstance = pair;
                newInstance.paired = oldInstance;
                oldInstance.paired = newInstance;
                scheduleViewTransitionEvent(child, props.onShare);
              }
            }
            pairs.delete(name);
            if (pairs.size === 0) {
              break;
            }
          }
        }
      }
      commitDeletedPairViewTransitions(child);
    }
    child = child.sibling;
  }
}
function commitExitViewTransitions(deletion) {
  if (deletion.tag === ViewTransitionComponent) {
    const props = deletion.memoizedProps;
    const name = getViewTransitionName(props, deletion.stateNode);
    const pair = appearingViewTransitions !== null ? appearingViewTransitions.get(name) : void 0;
    const className = getViewTransitionClassName(
      props.default,
      pair !== void 0 ? props.share : props.exit
    );
    if (className !== "none") {
      const inViewport = applyViewTransitionToHostInstances(
        deletion.child,
        name,
        className,
        null,
        false
      );
      if (!inViewport) {
        restoreViewTransitionOnHostInstances(deletion.child, false);
      } else if (pair !== void 0) {
        const oldInstance = deletion.stateNode;
        const newInstance = pair;
        newInstance.paired = oldInstance;
        oldInstance.paired = newInstance;
        appearingViewTransitions.delete(name);
        scheduleViewTransitionEvent(deletion, props.onShare);
      } else {
        scheduleViewTransitionEvent(deletion, props.onExit);
      }
    }
    if (appearingViewTransitions !== null) {
      commitDeletedPairViewTransitions(deletion);
    }
  } else if ((deletion.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
    let child = deletion.child;
    while (child !== null) {
      commitExitViewTransitions(child);
      child = child.sibling;
    }
  } else {
    if (appearingViewTransitions !== null) {
      commitDeletedPairViewTransitions(deletion);
    }
  }
}
function commitBeforeUpdateViewTransition(current2, finishedWork) {
  const oldProps = current2.memoizedProps;
  const oldName = getViewTransitionName(oldProps, current2.stateNode);
  const newProps = finishedWork.memoizedProps;
  const className = getViewTransitionClassName(
    newProps.default,
    newProps.update
  );
  if (className === "none") {
    return;
  }
  applyViewTransitionToHostInstances(
    current2.child,
    oldName,
    className,
    current2.memoizedState = [],
    true
  );
}
function commitNestedViewTransitions(changedParent) {
  let child = changedParent.child;
  while (child !== null) {
    if (child.tag === ViewTransitionComponent) {
      const props = child.memoizedProps;
      const name = getViewTransitionName(props, child.stateNode);
      const className = getViewTransitionClassName(
        props.default,
        props.update
      );
      child.flags &= ~Update;
      if (className !== "none") {
        applyViewTransitionToHostInstances(
          child.child,
          name,
          className,
          child.memoizedState = [],
          false
        );
      }
    } else if ((child.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
      commitNestedViewTransitions(child);
    }
    child = child.sibling;
  }
}
function restorePairedViewTransitions(parent) {
  if ((parent.subtreeFlags & ViewTransitionNamedStatic) === NoFlags) {
    return;
  }
  let child = parent.child;
  while (child !== null) {
    if (child.tag === OffscreenComponent && child.memoizedState === null) {
    } else {
      if (child.tag === ViewTransitionComponent && (child.flags & ViewTransitionNamedStatic) !== NoFlags) {
        const instance = child.stateNode;
        if (instance.paired !== null) {
          instance.paired = null;
          restoreViewTransitionOnHostInstances(child.child, false);
        }
      }
      restorePairedViewTransitions(child);
    }
    child = child.sibling;
  }
}
function restoreEnterOrExitViewTransitions(fiber) {
  if (fiber.tag === ViewTransitionComponent) {
    const instance = fiber.stateNode;
    instance.paired = null;
    restoreViewTransitionOnHostInstances(fiber.child, false);
    restorePairedViewTransitions(fiber);
  } else if ((fiber.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
    let child = fiber.child;
    while (child !== null) {
      restoreEnterOrExitViewTransitions(child);
      child = child.sibling;
    }
  } else {
    restorePairedViewTransitions(fiber);
  }
}
function restoreUpdateViewTransition(current2, finishedWork) {
  restoreViewTransitionOnHostInstances(current2.child, true);
  restoreViewTransitionOnHostInstances(finishedWork.child, true);
}
function restoreUpdateViewTransitionForGesture(current2, finishedWork) {
  restoreViewTransitionOnHostInstances(current2.child, true);
}
function restoreNestedViewTransitions(changedParent) {
  let child = changedParent.child;
  while (child !== null) {
    if (child.tag === ViewTransitionComponent) {
      restoreViewTransitionOnHostInstances(child.child, false);
    } else if ((child.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
      restoreNestedViewTransitions(child);
    }
    child = child.sibling;
  }
}
function measureViewTransitionHostInstances(parentViewTransition, child, newName, oldName, className, previousMeasurements, stopAtNestedViewTransitions) {
  viewTransitionHostInstanceIdx = 0;
  return measureViewTransitionHostInstancesRecursive(
    parentViewTransition,
    child,
    newName,
    oldName,
    className,
    previousMeasurements,
    stopAtNestedViewTransitions
  );
}
function measureViewTransitionHostInstancesRecursive(parentViewTransition, child, newName, oldName, className, previousMeasurements, stopAtNestedViewTransitions) {
  if (!void 0) {
    return true;
  }
  let inViewport = false;
  while (child !== null) {
    if (child.tag === HostComponent) {
      const instance = child.stateNode;
      if (previousMeasurements !== null && viewTransitionHostInstanceIdx < previousMeasurements.length) {
        const previousMeasurement = previousMeasurements[viewTransitionHostInstanceIdx];
        const nextMeasurement = (void 0)(instance);
        if ((void 0)(previousMeasurement) || (void 0)(nextMeasurement)) {
          inViewport = true;
        }
        if ((parentViewTransition.flags & Update) === NoFlags && (void 0)(previousMeasurement, nextMeasurement)) {
          parentViewTransition.flags |= Update;
        }
        if ((void 0)(previousMeasurement, nextMeasurement)) {
          parentViewTransition.flags |= AffectedParentLayout;
        }
      } else {
        parentViewTransition.flags |= AffectedParentLayout;
      }
      if ((parentViewTransition.flags & Update) !== NoFlags) {
        (void 0)(
          instance,
          viewTransitionHostInstanceIdx === 0 ? newName : (
            // If we have multiple Host Instances below, we add a suffix to the name to give
            // each one a unique name.
            newName + "_" + viewTransitionHostInstanceIdx
          ),
          className
        );
      }
      if (!inViewport || (parentViewTransition.flags & Update) === NoFlags) {
        if (viewTransitionCancelableChildren === null) {
          viewTransitionCancelableChildren = [];
        }
        viewTransitionCancelableChildren.push(
          instance,
          oldName,
          child.memoizedProps
        );
      }
      viewTransitionHostInstanceIdx++;
    } else if (child.tag === OffscreenComponent && child.memoizedState !== null) {
    } else if (child.tag === ViewTransitionComponent && stopAtNestedViewTransitions) {
      parentViewTransition.flags |= child.flags & AffectedParentLayout;
    } else {
      if (measureViewTransitionHostInstancesRecursive(
        parentViewTransition,
        child.child,
        newName,
        oldName,
        className,
        previousMeasurements,
        stopAtNestedViewTransitions
      )) {
        inViewport = true;
      }
    }
    child = child.sibling;
  }
  return inViewport;
}
function measureUpdateViewTransition(current2, finishedWork, gesture) {
  const oldFiber = gesture ? finishedWork : current2;
  const newFiber = gesture ? current2 : finishedWork;
  const props = newFiber.memoizedProps;
  const state = newFiber.stateNode;
  const newName = getViewTransitionName(props, state);
  const oldName = getViewTransitionName(oldFiber.memoizedProps, state);
  const className = getViewTransitionClassName(
    props.default,
    props.update
  );
  if (className === "none") {
    return false;
  }
  let previousMeasurements;
  if (gesture) {
    const clones = state.clones;
    if (clones === null) {
      previousMeasurements = null;
    } else {
      previousMeasurements = clones.map(void 0);
    }
  } else {
    previousMeasurements = oldFiber.memoizedState;
    oldFiber.memoizedState = null;
  }
  const inViewport = measureViewTransitionHostInstances(
    finishedWork,
    // This is always finishedWork since it's used to assign flags.
    newFiber.child,
    // This either current or finishedWork depending on if was a gesture.
    newName,
    oldName,
    className,
    previousMeasurements,
    true
  );
  const previousCount = previousMeasurements === null ? 0 : previousMeasurements.length;
  if (viewTransitionHostInstanceIdx !== previousCount) {
    finishedWork.flags |= AffectedParentLayout;
  }
  return inViewport;
}
function measureNestedViewTransitions(changedParent, gesture) {
  let child = changedParent.child;
  while (child !== null) {
    if (child.tag === ViewTransitionComponent) {
      const props = child.memoizedProps;
      const state = child.stateNode;
      const name = getViewTransitionName(props, state);
      const className = getViewTransitionClassName(
        props.default,
        props.update
      );
      let previousMeasurements;
      if (gesture) {
        const clones = state.clones;
        if (clones === null) {
          previousMeasurements = null;
        } else {
          previousMeasurements = clones.map(void 0);
        }
      } else {
        previousMeasurements = child.memoizedState;
        child.memoizedState = null;
      }
      const inViewport = measureViewTransitionHostInstances(
        child,
        child.child,
        name,
        name,
        // Since this is unchanged, new and old name is the same.
        className,
        previousMeasurements,
        false
      );
      if ((child.flags & Update) === NoFlags || !inViewport) {
      } else {
        if (gesture) {
        } else {
          scheduleViewTransitionEvent(child, props.onUpdate);
        }
      }
    } else if ((child.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
      measureNestedViewTransitions(child, gesture);
    }
    child = child.sibling;
  }
}

// dist/react-reconciler/src/ReactFiberCommitWork.js
var offscreenSubtreeIsHidden = false;
var offscreenSubtreeWasHidden = false;
var needsFormReset = false;
var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
var nextEffect = null;
var inProgressLanes = null;
var inProgressRoot = null;
var focusedInstanceHandle = null;
var shouldFireAfterActiveInstanceBlur = false;
var viewTransitionContextChanged = false;
var inUpdateViewTransition = false;
var rootViewTransitionAffected = false;
function isHydratingParent(current2, finishedWork) {
  if (finishedWork.tag === ActivityComponent) {
    const prevState = current2.memoizedState;
    const nextState = finishedWork.memoizedState;
    return prevState !== null && nextState === null;
  } else if (finishedWork.tag === SuspenseComponent) {
    const prevState = current2.memoizedState;
    const nextState = finishedWork.memoizedState;
    return prevState !== null && prevState.dehydrated !== null && (nextState === null || nextState.dehydrated === null);
  } else if (finishedWork.tag === HostRoot) {
    return current2.memoizedState.isDehydrated && (finishedWork.flags & ForceClientRender) === NoFlags;
  } else {
    return false;
  }
}
function commitBeforeMutationEffects(root2, firstChild, committedLanes) {
  focusedInstanceHandle = (void 0)(root2.containerInfo);
  shouldFireAfterActiveInstanceBlur = false;
  const isViewTransitionEligible = enableViewTransition && includesOnlyViewTransitionEligibleLanes(committedLanes);
  nextEffect = firstChild;
  commitBeforeMutationEffects_begin(isViewTransitionEligible);
  focusedInstanceHandle = null;
  resetAppearingViewTransitions();
}
function commitBeforeMutationEffects_begin(isViewTransitionEligible) {
  const subtreeMask = isViewTransitionEligible ? BeforeAndAfterMutationTransitionMask : BeforeMutationMask;
  while (nextEffect !== null) {
    const fiber = nextEffect;
    if (enableCreateEventHandleAPI || isViewTransitionEligible) {
      const deletions = fiber.deletions;
      if (deletions !== null) {
        for (let i = 0; i < deletions.length; i++) {
          const deletion = deletions[i];
          commitBeforeMutationEffectsDeletion(
            deletion,
            isViewTransitionEligible
          );
        }
      }
    }
    if (enableViewTransition && fiber.alternate === null && (fiber.flags & Placement) !== NoFlags) {
      if (isViewTransitionEligible) {
        trackEnterViewTransitions(fiber);
      }
      commitBeforeMutationEffects_complete(isViewTransitionEligible);
      continue;
    }
    if (enableViewTransition && fiber.tag === OffscreenComponent) {
      const isModernRoot = disableLegacyMode || (fiber.mode & ConcurrentMode) !== NoMode;
      if (isModernRoot) {
        const current2 = fiber.alternate;
        const isHidden = fiber.memoizedState !== null;
        if (isHidden) {
          if (current2 !== null && current2.memoizedState === null && isViewTransitionEligible) {
            commitExitViewTransitions(current2);
          }
          commitBeforeMutationEffects_complete(isViewTransitionEligible);
          continue;
        } else if (current2 !== null && current2.memoizedState !== null) {
          if (isViewTransitionEligible) {
            trackEnterViewTransitions(fiber);
          }
          commitBeforeMutationEffects_complete(isViewTransitionEligible);
          continue;
        }
      }
    }
    const child = fiber.child;
    if ((fiber.subtreeFlags & subtreeMask) !== NoFlags && child !== null) {
      child.return = fiber;
      nextEffect = child;
    } else {
      if (isViewTransitionEligible) {
        commitNestedViewTransitions(fiber);
      }
      commitBeforeMutationEffects_complete(isViewTransitionEligible);
    }
  }
}
function commitBeforeMutationEffects_complete(isViewTransitionEligible) {
  while (nextEffect !== null) {
    const fiber = nextEffect;
    commitBeforeMutationEffectsOnFiber(fiber, isViewTransitionEligible);
    const sibling = fiber.sibling;
    if (sibling !== null) {
      sibling.return = fiber.return;
      nextEffect = sibling;
      return;
    }
    nextEffect = fiber.return;
  }
}
function commitBeforeMutationEffectsOnFiber(finishedWork, isViewTransitionEligible) {
  const current2 = finishedWork.alternate;
  const flags = finishedWork.flags;
  if (enableCreateEventHandleAPI) {
    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      if (finishedWork.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current2, finishedWork) && // $FlowFixMe[incompatible-call] found when upgrading Flow
      doesFiberContain(finishedWork, focusedInstanceHandle)) {
        shouldFireAfterActiveInstanceBlur = true;
        (void 0)(finishedWork);
      }
    }
  }
  switch (finishedWork.tag) {
    case FunctionComponent: {
      if (enableUseEffectEventHook) {
        if ((flags & Update) !== NoFlags) {
          const updateQueue = finishedWork.updateQueue;
          const eventPayloads = updateQueue !== null ? updateQueue.events : null;
          if (eventPayloads !== null) {
            for (let ii = 0; ii < eventPayloads.length; ii++) {
              const { ref, nextImpl } = eventPayloads[ii];
              ref.impl = nextImpl;
            }
          }
        }
      }
      break;
    }
    case ForwardRef:
    case SimpleMemoComponent: {
      break;
    }
    case ClassComponent: {
      if ((flags & Snapshot) !== NoFlags) {
        if (current2 !== null) {
          commitClassSnapshot(finishedWork, current2);
        }
      }
      break;
    }
    case HostRoot: {
      if ((flags & Snapshot) !== NoFlags) {
        if (void 0) {
          const root2 = finishedWork.stateNode;
          (void 0)(root2.containerInfo);
        }
      }
      break;
    }
    case HostComponent:
    case HostHoistable:
    case HostSingleton:
    case HostText:
    case HostPortal:
    case IncompleteClassComponent:
      break;
    case ViewTransitionComponent:
      if (enableViewTransition) {
        if (isViewTransitionEligible) {
          if (current2 === null) {
          } else {
            commitBeforeUpdateViewTransition(current2, finishedWork);
          }
        }
        break;
      }
    // Fallthrough
    default: {
      if ((flags & Snapshot) !== NoFlags) {
        throw new Error(
          "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
        );
      }
    }
  }
}
function commitBeforeMutationEffectsDeletion(deletion, isViewTransitionEligible) {
  if (enableCreateEventHandleAPI) {
    if (doesFiberContain(deletion, focusedInstanceHandle)) {
      shouldFireAfterActiveInstanceBlur = true;
      (void 0)(deletion);
    }
  }
  if (isViewTransitionEligible) {
    commitExitViewTransitions(deletion);
  }
}
function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      recursivelyTraverseLayoutEffects(
        finishedRoot,
        finishedWork,
        committedLanes
      );
      if (flags & Update) {
        commitHookLayoutEffects(finishedWork, Layout | HasEffect);
      }
      break;
    }
    case ClassComponent: {
      recursivelyTraverseLayoutEffects(
        finishedRoot,
        finishedWork,
        committedLanes
      );
      if (flags & Update) {
        commitClassLayoutLifecycles(finishedWork, current2);
      }
      if (flags & Callback) {
        commitClassCallbacks(finishedWork);
      }
      if (flags & Ref) {
        safelyAttachRef(finishedWork, finishedWork.return);
      }
      break;
    }
    case HostRoot: {
      const prevProfilerEffectDuration = pushNestedEffectDurations();
      recursivelyTraverseLayoutEffects(
        finishedRoot,
        finishedWork,
        committedLanes
      );
      if (flags & Callback) {
        commitRootCallbacks(finishedWork);
      }
      if (enableProfilerTimer && enableProfilerCommitHooks) {
        finishedRoot.effectDuration += popNestedEffectDurations(
          prevProfilerEffectDuration
        );
      }
      break;
    }
    case HostSingleton: {
      if (void 0) {
        if (current2 === null && flags & Update) {
          commitHostSingletonAcquisition(finishedWork);
        }
      }
    }
    case HostHoistable:
    case HostComponent: {
      recursivelyTraverseLayoutEffects(
        finishedRoot,
        finishedWork,
        committedLanes
      );
      if (current2 === null) {
        if (flags & Update) {
          commitHostMount(finishedWork);
        } else if (flags & Hydrate) {
          commitHostHydratedInstance(finishedWork);
        }
      }
      if (flags & Ref) {
        safelyAttachRef(finishedWork, finishedWork.return);
      }
      break;
    }
    case Profiler: {
      if (flags & Update) {
        const prevProfilerEffectDuration = pushNestedEffectDurations();
        recursivelyTraverseLayoutEffects(
          finishedRoot,
          finishedWork,
          committedLanes
        );
        const profilerInstance = finishedWork.stateNode;
        if (enableProfilerTimer && enableProfilerCommitHooks) {
          profilerInstance.effectDuration += bubbleNestedEffectDurations(
            prevProfilerEffectDuration
          );
        }
        commitProfilerUpdate(
          finishedWork,
          current2,
          commitStartTime,
          profilerInstance.effectDuration
        );
      } else {
        recursivelyTraverseLayoutEffects(
          finishedRoot,
          finishedWork,
          committedLanes
        );
      }
      break;
    }
    case ActivityComponent: {
      recursivelyTraverseLayoutEffects(
        finishedRoot,
        finishedWork,
        committedLanes
      );
      if (flags & Update) {
        commitActivityHydrationCallbacks(finishedRoot, finishedWork);
      }
      break;
    }
    case SuspenseComponent: {
      recursivelyTraverseLayoutEffects(
        finishedRoot,
        finishedWork,
        committedLanes
      );
      if (flags & Update) {
        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      }
      if (flags & Callback) {
        const finishedState = finishedWork.memoizedState;
        if (finishedState !== null) {
          const dehydrated = finishedState.dehydrated;
          if (dehydrated !== null) {
            const retry = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            );
            (void 0)(dehydrated, retry);
          }
        }
      }
      break;
    }
    case OffscreenComponent: {
      const isModernRoot = disableLegacyMode || (finishedWork.mode & ConcurrentMode) !== NoMode;
      if (isModernRoot) {
        const isHidden = finishedWork.memoizedState !== null;
        const newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
        if (newOffscreenSubtreeIsHidden) {
        } else {
          const wasHidden = current2 !== null && current2.memoizedState !== null;
          const newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
          const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
          const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
          offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
          if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
            const includeWorkInProgressEffects = (finishedWork.subtreeFlags & LayoutMask) !== NoFlags;
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectEndTime - componentEffectStartTime > 0.05) {
              logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              );
            }
          } else {
            recursivelyTraverseLayoutEffects(
              finishedRoot,
              finishedWork,
              committedLanes
            );
          }
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        }
      } else {
        recursivelyTraverseLayoutEffects(
          finishedRoot,
          finishedWork,
          committedLanes
        );
      }
      break;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        if (false) {
          if (flags & ViewTransitionNamedStatic) {
            trackNamedViewTransition(finishedWork);
          }
        }
        recursivelyTraverseLayoutEffects(
          finishedRoot,
          finishedWork,
          committedLanes
        );
        if (flags & Ref) {
          safelyAttachRef(finishedWork, finishedWork.return);
        }
        break;
      }
      break;
    }
    case Fragment:
      if (enableFragmentRefs) {
        if (flags & Ref) {
          safelyAttachRef(finishedWork, finishedWork.return);
        }
      }
    // Fallthrough
    default: {
      recursivelyTraverseLayoutEffects(
        finishedRoot,
        finishedWork,
        committedLanes
      );
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0) {
    if (componentEffectDuration > 0.05) {
      logComponentEffect(
        finishedWork,
        componentEffectStartTime,
        componentEffectEndTime,
        componentEffectDuration,
        componentEffectErrors
      );
    }
    if (
      // Insertion
      finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null && componentEffectEndTime - componentEffectStartTime > 0.05
    ) {
      const isHydration = isHydratingParent(
        finishedWork.return.alternate,
        finishedWork.return
      );
      if (!isHydration) {
        logComponentMount(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime
        );
      }
    }
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function abortRootTransitions(root2, abort, deletedTransitions, deletedOffscreenInstance, isInDeletedTree) {
  if (enableTransitionTracing) {
    const rootTransitions = root2.incompleteTransitions;
    deletedTransitions.forEach((transition) => {
      if (rootTransitions.has(transition)) {
        const transitionInstance = rootTransitions.get(
          transition
        );
        if (transitionInstance.aborts === null) {
          transitionInstance.aborts = [];
        }
        transitionInstance.aborts.push(abort);
        if (deletedOffscreenInstance !== null) {
          if (transitionInstance.pendingBoundaries !== null && transitionInstance.pendingBoundaries.has(deletedOffscreenInstance)) {
            transitionInstance.pendingBoundaries.delete(
              deletedOffscreenInstance
            );
          }
        }
      }
    });
  }
}
function abortTracingMarkerTransitions(abortedFiber, abort, deletedTransitions, deletedOffscreenInstance, isInDeletedTree) {
  if (enableTransitionTracing) {
    const markerInstance = abortedFiber.stateNode;
    const markerTransitions = markerInstance.transitions;
    const pendingBoundaries = markerInstance.pendingBoundaries;
    if (markerTransitions !== null) {
      deletedTransitions.forEach((transition) => {
        if (abortedFiber !== null && markerTransitions.has(transition) && (markerInstance.aborts === null || !markerInstance.aborts.includes(abort))) {
          if (markerInstance.transitions !== null) {
            if (markerInstance.aborts === null) {
              markerInstance.aborts = [abort];
              addMarkerIncompleteCallbackToPendingTransition(
                abortedFiber.memoizedProps.name,
                markerInstance.transitions,
                markerInstance.aborts
              );
            } else {
              markerInstance.aborts.push(abort);
            }
            if (deletedOffscreenInstance !== null && !isInDeletedTree && pendingBoundaries !== null && pendingBoundaries.has(deletedOffscreenInstance)) {
              pendingBoundaries.delete(deletedOffscreenInstance);
              addMarkerProgressCallbackToPendingTransition(
                abortedFiber.memoizedProps.name,
                deletedTransitions,
                pendingBoundaries
              );
            }
          }
        }
      });
    }
  }
}
function abortParentMarkerTransitionsForDeletedFiber(abortedFiber, abort, deletedTransitions, deletedOffscreenInstance, isInDeletedTree) {
  if (enableTransitionTracing) {
    let fiber = abortedFiber;
    while (fiber !== null) {
      switch (fiber.tag) {
        case TracingMarkerComponent:
          abortTracingMarkerTransitions(
            fiber,
            abort,
            deletedTransitions,
            deletedOffscreenInstance,
            isInDeletedTree
          );
          break;
        case HostRoot:
          const root2 = fiber.stateNode;
          abortRootTransitions(
            root2,
            abort,
            deletedTransitions,
            deletedOffscreenInstance,
            isInDeletedTree
          );
          break;
        default:
          break;
      }
      fiber = fiber.return;
    }
  }
}
function commitTransitionProgress(offscreenFiber) {
  if (enableTransitionTracing) {
    const offscreenInstance = offscreenFiber.stateNode;
    let prevState = null;
    const previousFiber = offscreenFiber.alternate;
    if (previousFiber !== null && previousFiber.memoizedState !== null) {
      prevState = previousFiber.memoizedState;
    }
    const nextState = offscreenFiber.memoizedState;
    const wasHidden = prevState !== null;
    const isHidden = nextState !== null;
    const pendingMarkers = offscreenInstance._pendingMarkers;
    let name = null;
    const parent = offscreenFiber.return;
    if (parent !== null && parent.tag === SuspenseComponent && parent.memoizedProps.name) {
      name = parent.memoizedProps.name;
    }
    if (!wasHidden && isHidden) {
      if (pendingMarkers !== null) {
        pendingMarkers.forEach((markerInstance) => {
          const pendingBoundaries = markerInstance.pendingBoundaries;
          const transitions = markerInstance.transitions;
          const markerName = markerInstance.name;
          if (pendingBoundaries !== null && !pendingBoundaries.has(offscreenInstance)) {
            pendingBoundaries.set(offscreenInstance, {
              name
            });
            if (transitions !== null) {
              if (markerInstance.tag === TransitionTracingMarker && markerName !== null) {
                addMarkerProgressCallbackToPendingTransition(
                  markerName,
                  transitions,
                  pendingBoundaries
                );
              } else if (markerInstance.tag === TransitionRoot) {
                transitions.forEach((transition) => {
                  addTransitionProgressCallbackToPendingTransition(
                    transition,
                    pendingBoundaries
                  );
                });
              }
            }
          }
        });
      }
    } else if (wasHidden && !isHidden) {
      if (pendingMarkers !== null) {
        pendingMarkers.forEach((markerInstance) => {
          const pendingBoundaries = markerInstance.pendingBoundaries;
          const transitions = markerInstance.transitions;
          const markerName = markerInstance.name;
          if (pendingBoundaries !== null && pendingBoundaries.has(offscreenInstance)) {
            pendingBoundaries.delete(offscreenInstance);
            if (transitions !== null) {
              if (markerInstance.tag === TransitionTracingMarker && markerName !== null) {
                addMarkerProgressCallbackToPendingTransition(
                  markerName,
                  transitions,
                  pendingBoundaries
                );
                if (pendingBoundaries.size === 0) {
                  if (markerInstance.aborts === null) {
                    addMarkerCompleteCallbackToPendingTransition(
                      markerName,
                      transitions
                    );
                  }
                  markerInstance.transitions = null;
                  markerInstance.pendingBoundaries = null;
                  markerInstance.aborts = null;
                }
              } else if (markerInstance.tag === TransitionRoot) {
                transitions.forEach((transition) => {
                  addTransitionProgressCallbackToPendingTransition(
                    transition,
                    pendingBoundaries
                  );
                });
              }
            }
          }
        });
      }
    }
  }
}
function hideOrUnhideAllChildren(finishedWork, isHidden) {
  let hostSubtreeRoot = null;
  if (void 0) {
    let node = finishedWork;
    while (true) {
      if (node.tag === HostComponent || (void 0 ? node.tag === HostHoistable : false)) {
        if (hostSubtreeRoot === null) {
          hostSubtreeRoot = node;
          commitShowHideHostInstance(node, isHidden);
        }
      } else if (node.tag === HostText) {
        if (hostSubtreeRoot === null) {
          commitShowHideHostTextInstance(node, isHidden);
        }
      } else if (node.tag === DehydratedFragment) {
        if (hostSubtreeRoot === null) {
          commitShowHideSuspenseBoundary(node, isHidden);
        }
      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) {
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === finishedWork) {
          return;
        }
        if (hostSubtreeRoot === node) {
          hostSubtreeRoot = null;
        }
        node = node.return;
      }
      if (hostSubtreeRoot === node) {
        hostSubtreeRoot = null;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
}
function detachFiberMutation(fiber) {
  const alternate = fiber.alternate;
  if (alternate !== null) {
    alternate.return = null;
  }
  fiber.return = null;
}
function detachFiberAfterEffects(fiber) {
  const alternate = fiber.alternate;
  if (alternate !== null) {
    fiber.alternate = null;
    detachFiberAfterEffects(alternate);
  }
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  if (fiber.tag === HostComponent) {
    const hostInstance = fiber.stateNode;
    if (hostInstance !== null) {
      (void 0)(hostInstance);
    }
  }
  fiber.stateNode = null;
  if (false) {
    fiber._debugOwner = null;
  }
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
var hostParent = null;
var hostParentIsContainer = false;
function commitDeletionEffects(root2, returnFiber, deletedFiber) {
  const prevEffectStart = pushComponentEffectStart();
  if (void 0) {
    let parent = returnFiber;
    findParent: while (parent !== null) {
      switch (parent.tag) {
        case HostSingleton: {
          if (void 0) {
            if ((void 0)(parent.type)) {
              hostParent = parent.stateNode;
              hostParentIsContainer = false;
              break findParent;
            }
            break;
          }
        }
        case HostComponent: {
          hostParent = parent.stateNode;
          hostParentIsContainer = false;
          break findParent;
        }
        case HostRoot:
        case HostPortal: {
          hostParent = parent.stateNode.containerInfo;
          hostParentIsContainer = true;
          break findParent;
        }
      }
      parent = parent.return;
    }
    if (hostParent === null) {
      throw new Error(
        "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
    hostParent = null;
    hostParentIsContainer = false;
  } else {
    commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (deletedFiber.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectEndTime - componentEffectStartTime > 0.05) {
    logComponentUnmount(
      deletedFiber,
      componentEffectStartTime,
      componentEffectEndTime
    );
  }
  popComponentEffectStart(prevEffectStart);
  detachFiberMutation(deletedFiber);
}
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  let child = parent.child;
  while (child !== null) {
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
    child = child.sibling;
  }
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  onCommitUnmount(deletedFiber);
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  switch (deletedFiber.tag) {
    case HostHoistable: {
      if (void 0) {
        if (!offscreenSubtreeWasHidden) {
          safelyDetachRef(deletedFiber, nearestMountedAncestor);
        }
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        if (deletedFiber.memoizedState) {
          (void 0)(deletedFiber.memoizedState);
        } else if (deletedFiber.stateNode) {
          (void 0)(deletedFiber.stateNode);
        }
        break;
      }
    }
    case HostSingleton: {
      if (void 0) {
        if (!offscreenSubtreeWasHidden) {
          safelyDetachRef(deletedFiber, nearestMountedAncestor);
        }
        const prevHostParent = hostParent;
        const prevHostParentIsContainer = hostParentIsContainer;
        if ((void 0)(deletedFiber.type)) {
          hostParent = deletedFiber.stateNode;
          hostParentIsContainer = false;
        }
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        commitHostSingletonRelease(deletedFiber);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      }
    }
    case HostComponent: {
      if (!offscreenSubtreeWasHidden) {
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      }
      if (enableFragmentRefs && deletedFiber.tag === HostComponent) {
        commitFragmentInstanceDeletionEffects(deletedFiber);
      }
    }
    case HostText: {
      if (void 0) {
        const prevHostParent = hostParent;
        const prevHostParentIsContainer = hostParentIsContainer;
        hostParent = null;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        if (hostParent !== null) {
          if (hostParentIsContainer) {
            commitHostRemoveChildFromContainer(
              deletedFiber,
              nearestMountedAncestor,
              hostParent,
              deletedFiber.stateNode
            );
          } else {
            commitHostRemoveChild(
              deletedFiber,
              nearestMountedAncestor,
              hostParent,
              deletedFiber.stateNode
            );
          }
        }
      } else {
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
      }
      break;
    }
    case DehydratedFragment: {
      if (enableSuspenseCallback) {
        const hydrationCallbacks = finishedRoot.hydrationCallbacks;
        if (hydrationCallbacks !== null) {
          try {
            const onDeleted = hydrationCallbacks.onDeleted;
            if (onDeleted) {
              onDeleted(
                deletedFiber.stateNode
              );
            }
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
        }
      }
      if (void 0) {
        if (hostParent !== null) {
          if (hostParentIsContainer) {
            (void 0)(
              hostParent,
              deletedFiber.stateNode
            );
          } else {
            (void 0)(
              hostParent,
              deletedFiber.stateNode
            );
          }
        }
      }
      break;
    }
    case HostPortal: {
      if (void 0) {
        const prevHostParent = hostParent;
        const prevHostParentIsContainer = hostParentIsContainer;
        hostParent = deletedFiber.stateNode.containerInfo;
        hostParentIsContainer = true;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
      } else {
        if (void 0) {
          commitHostPortalContainerChildren(
            deletedFiber.stateNode,
            deletedFiber,
            (void 0)()
          );
        }
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
      }
      break;
    }
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      if (enableHiddenSubtreeInsertionEffectCleanup || !offscreenSubtreeWasHidden) {
        commitHookEffectListUnmount(
          Insertion,
          deletedFiber,
          nearestMountedAncestor
        );
      }
      if (!offscreenSubtreeWasHidden) {
        commitHookLayoutUnmountEffects(
          deletedFiber,
          nearestMountedAncestor,
          Layout
        );
      }
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    }
    case ClassComponent: {
      if (!offscreenSubtreeWasHidden) {
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
        const instance = deletedFiber.stateNode;
        if (typeof instance.componentWillUnmount === "function") {
          safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            instance
          );
        }
      }
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    }
    case ScopeComponent: {
      if (enableScopeAPI) {
        if (!offscreenSubtreeWasHidden) {
          safelyDetachRef(deletedFiber, nearestMountedAncestor);
        }
      }
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    }
    case OffscreenComponent: {
      if (disableLegacyMode || deletedFiber.mode & ConcurrentMode) {
        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      } else {
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
      }
      break;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        if (false) {
          if (deletedFiber.flags & ViewTransitionNamedStatic) {
            untrackNamedViewTransition(deletedFiber);
          }
        }
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      }
    }
    case Fragment: {
      if (enableFragmentRefs) {
        if (!offscreenSubtreeWasHidden) {
          safelyDetachRef(deletedFiber, nearestMountedAncestor);
        }
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      }
    }
    default: {
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (deletedFiber.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectDuration > 0.05) {
    logComponentEffect(
      deletedFiber,
      componentEffectStartTime,
      componentEffectEndTime,
      componentEffectDuration,
      componentEffectErrors
    );
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function commitSuspenseCallback(finishedWork) {
  const newState = finishedWork.memoizedState;
  if (enableSuspenseCallback && newState !== null) {
    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;
    if (typeof suspenseCallback === "function") {
      const retryQueue = finishedWork.updateQueue;
      if (retryQueue !== null) {
        suspenseCallback(new Set(retryQueue));
      }
    } else if (false) {
      if (suspenseCallback !== void 0) {
        console.error("Unexpected type for suspenseCallback.");
      }
    }
  }
}
function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
  if (!void 0) {
    return;
  }
  const newState = finishedWork.memoizedState;
  if (newState === null) {
    const current2 = finishedWork.alternate;
    if (current2 !== null) {
      const prevState = current2.memoizedState;
      if (prevState !== null) {
        const activityInstance = prevState.dehydrated;
        commitHostHydratedActivity(activityInstance, finishedWork);
        if (enableSuspenseCallback) {
          try {
            const hydrationCallbacks = finishedRoot.hydrationCallbacks;
            if (hydrationCallbacks !== null) {
              const onHydrated = hydrationCallbacks.onHydrated;
              if (onHydrated) {
                onHydrated(activityInstance);
              }
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
    }
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (!void 0) {
    return;
  }
  const newState = finishedWork.memoizedState;
  if (newState === null) {
    const current2 = finishedWork.alternate;
    if (current2 !== null) {
      const prevState = current2.memoizedState;
      if (prevState !== null) {
        const suspenseInstance = prevState.dehydrated;
        if (suspenseInstance !== null) {
          commitHostHydratedSuspense(suspenseInstance, finishedWork);
          if (enableSuspenseCallback) {
            try {
              const hydrationCallbacks = finishedRoot.hydrationCallbacks;
              if (hydrationCallbacks !== null) {
                const onHydrated = hydrationCallbacks.onHydrated;
                if (onHydrated) {
                  onHydrated(suspenseInstance);
                }
              }
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
      }
    }
  }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case ActivityComponent:
    case SuspenseComponent:
    case SuspenseListComponent: {
      let retryCache = finishedWork.stateNode;
      if (retryCache === null) {
        retryCache = finishedWork.stateNode = new PossiblyWeakSet();
      }
      return retryCache;
    }
    case OffscreenComponent: {
      const instance = finishedWork.stateNode;
      let retryCache = instance._retryCache;
      if (retryCache === null) {
        retryCache = instance._retryCache = new PossiblyWeakSet();
      }
      return retryCache;
    }
    default: {
      throw new Error(
        `Unexpected Suspense handler tag (${finishedWork.tag}). This is a bug in React.`
      );
    }
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  const retryCache = getRetryCache(finishedWork);
  wakeables.forEach((wakeable) => {
    const retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
    if (!retryCache.has(wakeable)) {
      retryCache.add(wakeable);
      if (enableUpdaterTracking) {
        if (isDevToolsPresent) {
          if (inProgressLanes !== null && inProgressRoot !== null) {
            restorePendingUpdaters(inProgressRoot, inProgressLanes);
          } else {
            throw Error(
              "Expected finished root and lanes to be set. This is a bug in React."
            );
          }
        }
      }
      wakeable.then(retry, retry);
    }
  });
}
function isSuspenseBoundaryBeingHidden(current2, finishedWork) {
  if (current2 !== null) {
    const oldState = current2.memoizedState;
    if (oldState === null || oldState.dehydrated !== null) {
      const newState = finishedWork.memoizedState;
      return newState !== null && newState.dehydrated === null;
    }
  }
  return false;
}
function commitMutationEffects(root2, finishedWork, committedLanes) {
  inProgressLanes = committedLanes;
  inProgressRoot = root2;
  rootViewTransitionAffected = false;
  inUpdateViewTransition = false;
  resetComponentEffectTimers();
  commitMutationEffectsOnFiber(finishedWork, root2, committedLanes);
  inProgressLanes = null;
  inProgressRoot = null;
}
function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root2, parentFiber, childToDelete);
    }
  }
  if (parentFiber.subtreeFlags & (enablePersistedModeClonedFlag ? MutationMask | Cloned : MutationMask)) {
    let child = parentFiber.child;
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root2, lanes);
      child = child.sibling;
    }
  }
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  const current2 = finishedWork.alternate;
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      if (flags & Update) {
        commitHookEffectListUnmount(
          Insertion | HasEffect,
          finishedWork,
          finishedWork.return
        );
        commitHookEffectListMount(Insertion | HasEffect, finishedWork);
        commitHookLayoutUnmountEffects(
          finishedWork,
          finishedWork.return,
          Layout | HasEffect
        );
      }
      break;
    }
    case ClassComponent: {
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      if (flags & Ref) {
        if (!offscreenSubtreeWasHidden && current2 !== null) {
          safelyDetachRef(current2, current2.return);
        }
      }
      if (flags & Callback && offscreenSubtreeIsHidden) {
        const updateQueue = finishedWork.updateQueue;
        if (updateQueue !== null) {
          deferHiddenCallbacks(updateQueue);
        }
      }
      break;
    }
    case HostHoistable: {
      if (void 0) {
        const hoistableRoot = currentHoistableRoot;
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        commitReconciliationEffects(finishedWork, lanes);
        if (flags & Ref) {
          if (!offscreenSubtreeWasHidden && current2 !== null) {
            safelyDetachRef(current2, current2.return);
          }
        }
        if (flags & Update) {
          const currentResource = current2 !== null ? current2.memoizedState : null;
          const newResource = finishedWork.memoizedState;
          if (current2 === null) {
            if (newResource === null) {
              if (finishedWork.stateNode === null) {
                finishedWork.stateNode = (void 0)(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.memoizedProps,
                  finishedWork
                );
              } else {
                (void 0)(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                );
              }
            } else {
              finishedWork.stateNode = (void 0)(
                hoistableRoot,
                newResource,
                finishedWork.memoizedProps
              );
            }
          } else if (currentResource !== newResource) {
            if (currentResource === null) {
              if (current2.stateNode !== null) {
                (void 0)(current2.stateNode);
              }
            } else {
              (void 0)(currentResource);
            }
            if (newResource === null) {
              (void 0)(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              );
            } else {
              (void 0)(
                hoistableRoot,
                newResource,
                finishedWork.memoizedProps
              );
            }
          } else if (newResource === null && finishedWork.stateNode !== null) {
            commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current2.memoizedProps
            );
          }
        }
        break;
      }
    }
    case HostSingleton: {
      if (void 0) {
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        commitReconciliationEffects(finishedWork, lanes);
        if (flags & Ref) {
          if (!offscreenSubtreeWasHidden && current2 !== null) {
            safelyDetachRef(current2, current2.return);
          }
        }
        if (current2 !== null && flags & Update) {
          const newProps = finishedWork.memoizedProps;
          const oldProps = current2.memoizedProps;
          commitHostUpdate(finishedWork, newProps, oldProps);
        }
        break;
      }
    }
    case HostComponent: {
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      if (flags & Ref) {
        if (!offscreenSubtreeWasHidden && current2 !== null) {
          safelyDetachRef(current2, current2.return);
        }
      }
      if (void 0) {
        if (finishedWork.flags & ContentReset) {
          commitHostResetTextContent(finishedWork);
        }
        if (flags & Update) {
          const instance = finishedWork.stateNode;
          if (instance != null) {
            const newProps = finishedWork.memoizedProps;
            const oldProps = current2 !== null ? current2.memoizedProps : newProps;
            commitHostUpdate(finishedWork, newProps, oldProps);
          }
        }
        if (flags & FormReset) {
          needsFormReset = true;
          if (false) {
            if (finishedWork.type !== "form") {
              console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              );
            }
          }
        }
      } else {
        if (enableEagerAlternateStateNodeCleanup) {
          if (void 0) {
            if (finishedWork.alternate !== null) {
              finishedWork.alternate.stateNode = finishedWork.stateNode;
            }
          }
        }
      }
      break;
    }
    case HostText: {
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      if (flags & Update) {
        if (void 0) {
          if (finishedWork.stateNode === null) {
            throw new Error(
              "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
            );
          }
          const newText = finishedWork.memoizedProps;
          const oldText = current2 !== null ? current2.memoizedProps : newText;
          commitHostTextUpdate(finishedWork, newText, oldText);
        }
      }
      break;
    }
    case HostRoot: {
      const prevProfilerEffectDuration = pushNestedEffectDurations();
      pushRootMutationContext();
      if (void 0) {
        (void 0)();
        const previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = (void 0)(root2.containerInfo);
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        currentHoistableRoot = previousHoistableRoot;
        commitReconciliationEffects(finishedWork, lanes);
      } else {
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        commitReconciliationEffects(finishedWork, lanes);
      }
      if (flags & Update) {
        if (void 0 && void 0) {
          if (current2 !== null) {
            const prevRootState = current2.memoizedState;
            if (prevRootState.isDehydrated) {
              commitHostHydratedContainer(root2, finishedWork);
            }
          }
        }
        if (void 0) {
          commitHostRootContainerChildren(root2, finishedWork);
        }
      }
      if (needsFormReset) {
        needsFormReset = false;
        recursivelyResetForms(finishedWork);
      }
      if (enableProfilerTimer && enableProfilerCommitHooks) {
        root2.effectDuration += popNestedEffectDurations(
          prevProfilerEffectDuration
        );
      }
      popMutationContext(false);
      if (enableDefaultTransitionIndicator && rootMutationContext && includesLoadingIndicatorLanes(lanes)) {
        markIndicatorHandled(root2);
      }
      break;
    }
    case HostPortal: {
      const prevMutationContext = pushMutationContext();
      if (void 0) {
        const previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = (void 0)(
          finishedWork.stateNode.containerInfo
        );
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        commitReconciliationEffects(finishedWork, lanes);
        currentHoistableRoot = previousHoistableRoot;
      } else {
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        commitReconciliationEffects(finishedWork, lanes);
      }
      if (viewTransitionMutationContext && inUpdateViewTransition) {
        rootViewTransitionAffected = true;
      }
      popMutationContext(prevMutationContext);
      if (flags & Update) {
        if (void 0) {
          commitHostPortalContainerChildren(
            finishedWork.stateNode,
            finishedWork,
            finishedWork.stateNode.pendingChildren
          );
        }
      }
      break;
    }
    case Profiler: {
      const prevProfilerEffectDuration = pushNestedEffectDurations();
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      if (enableProfilerTimer && enableProfilerCommitHooks) {
        const profilerInstance = finishedWork.stateNode;
        profilerInstance.effectDuration += bubbleNestedEffectDurations(
          prevProfilerEffectDuration
        );
      }
      break;
    }
    case ActivityComponent: {
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      if (flags & Update) {
        const retryQueue = finishedWork.updateQueue;
        if (retryQueue !== null) {
          finishedWork.updateQueue = null;
          attachSuspenseRetryListeners(finishedWork, retryQueue);
        }
      }
      break;
    }
    case SuspenseComponent: {
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      const offscreenFiber = finishedWork.child;
      if (offscreenFiber.flags & Visibility) {
        const isShowingFallback = finishedWork.memoizedState !== null;
        const wasShowingFallback = current2 !== null && current2.memoizedState !== null;
        if (alwaysThrottleRetries) {
          if (isShowingFallback !== wasShowingFallback) {
            markCommitTimeOfFallback();
          }
        } else {
          if (isShowingFallback && !wasShowingFallback) {
            markCommitTimeOfFallback();
          }
        }
      }
      if (flags & Update) {
        try {
          commitSuspenseCallback(finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        const retryQueue = finishedWork.updateQueue;
        if (retryQueue !== null) {
          finishedWork.updateQueue = null;
          attachSuspenseRetryListeners(finishedWork, retryQueue);
        }
      }
      break;
    }
    case OffscreenComponent: {
      const newState = finishedWork.memoizedState;
      const isHidden = newState !== null;
      const wasHidden = current2 !== null && current2.memoizedState !== null;
      if (disableLegacyMode || finishedWork.mode & ConcurrentMode) {
        const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
        if (
          // If this was the root of the reappear.
          wasHidden && !isHidden && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectEndTime - componentEffectStartTime > 0.05
        ) {
          logComponentReappeared(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime
          );
        }
      } else {
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      }
      commitReconciliationEffects(finishedWork, lanes);
      if (flags & Visibility) {
        const offscreenInstance = finishedWork.stateNode;
        if (isHidden) {
          offscreenInstance._visibility &= ~OffscreenVisible;
        } else {
          offscreenInstance._visibility |= OffscreenVisible;
        }
        const isUpdate = current2 !== null;
        if (isHidden) {
          if (isUpdate && !wasHidden && !offscreenSubtreeIsHidden && !offscreenSubtreeWasHidden) {
            if (disableLegacyMode || (finishedWork.mode & ConcurrentMode) !== NoMode) {
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectEndTime - componentEffectStartTime > 0.05) {
                logComponentDisappeared(
                  finishedWork,
                  componentEffectStartTime,
                  componentEffectEndTime
                );
              }
            }
          }
        }
        if (void 0) {
          hideOrUnhideAllChildren(finishedWork, isHidden);
        }
      }
      if (flags & Update) {
        const offscreenQueue = finishedWork.updateQueue;
        if (offscreenQueue !== null) {
          const retryQueue = offscreenQueue.retryQueue;
          if (retryQueue !== null) {
            offscreenQueue.retryQueue = null;
            attachSuspenseRetryListeners(finishedWork, retryQueue);
          }
        }
      }
      break;
    }
    case SuspenseListComponent: {
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      if (flags & Update) {
        const retryQueue = finishedWork.updateQueue;
        if (retryQueue !== null) {
          finishedWork.updateQueue = null;
          attachSuspenseRetryListeners(finishedWork, retryQueue);
        }
      }
      break;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        if (flags & Ref) {
          if (!offscreenSubtreeWasHidden && current2 !== null) {
            safelyDetachRef(current2, current2.return);
          }
        }
        const prevMutationContext = pushMutationContext();
        const prevUpdate = inUpdateViewTransition;
        const isViewTransitionEligible = enableViewTransition && includesOnlyViewTransitionEligibleLanes(lanes);
        const props = finishedWork.memoizedProps;
        inUpdateViewTransition = isViewTransitionEligible && getViewTransitionClassName(props.default, props.update) !== "none";
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        commitReconciliationEffects(finishedWork, lanes);
        if (isViewTransitionEligible) {
          if (current2 === null) {
          } else if (viewTransitionMutationContext) {
            finishedWork.flags |= Update;
          }
        }
        inUpdateViewTransition = prevUpdate;
        popMutationContext(prevMutationContext);
        break;
      }
      break;
    }
    case ScopeComponent: {
      if (enableScopeAPI) {
        recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
        commitReconciliationEffects(finishedWork, lanes);
        if (flags & Ref) {
          if (!offscreenSubtreeWasHidden && current2 !== null) {
            safelyDetachRef(finishedWork, finishedWork.return);
          }
          if (!offscreenSubtreeIsHidden) {
            safelyAttachRef(finishedWork, finishedWork.return);
          }
        }
        if (flags & Update) {
          const scopeInstance = finishedWork.stateNode;
          (void 0)(scopeInstance, finishedWork);
        }
      }
      break;
    }
    case Fragment:
      if (enableFragmentRefs) {
        if (current2 && current2.stateNode !== null) {
          (void 0)(finishedWork, current2.stateNode);
        }
      }
    // Fallthrough
    default: {
      recursivelyTraverseMutationEffects(root2, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0) {
    if (componentEffectDuration > 0.05) {
      logComponentEffect(
        finishedWork,
        componentEffectStartTime,
        componentEffectEndTime,
        componentEffectDuration,
        componentEffectErrors
      );
    }
    if (
      // Insertion
      finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null && componentEffectEndTime - componentEffectStartTime > 0.05
    ) {
      const isHydration = isHydratingParent(
        finishedWork.return.alternate,
        finishedWork.return
      );
      if (!isHydration) {
        logComponentMount(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime
        );
      }
    }
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function commitReconciliationEffects(finishedWork, committedLanes) {
  const flags = finishedWork.flags;
  if (flags & Placement) {
    commitHostPlacement(finishedWork);
    finishedWork.flags &= ~Placement;
  }
  if (flags & Hydrating) {
    finishedWork.flags &= ~Hydrating;
  }
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & FormReset) {
    let child = parentFiber.child;
    while (child !== null) {
      resetFormOnFiber(child);
      child = child.sibling;
    }
  }
}
function resetFormOnFiber(fiber) {
  recursivelyResetForms(fiber);
  if (fiber.tag === HostComponent && fiber.flags & FormReset) {
    const formInstance = fiber.stateNode;
    (void 0)(formInstance);
  }
}
function commitAfterMutationEffects(root2, finishedWork, committedLanes) {
  if (!enableViewTransition) {
    return;
  }
  commitAfterMutationEffectsOnFiber(finishedWork, root2, committedLanes);
}
function recursivelyTraverseAfterMutationEffects(root2, parentFiber, lanes) {
  if (parentFiber.subtreeFlags & BeforeAndAfterMutationTransitionMask) {
    let child = parentFiber.child;
    while (child !== null) {
      commitAfterMutationEffectsOnFiber(child, root2, lanes);
      child = child.sibling;
    }
  } else {
    measureNestedViewTransitions(parentFiber, false);
  }
}
function commitAfterMutationEffectsOnFiber(finishedWork, root2, lanes) {
  const current2 = finishedWork.alternate;
  if (current2 === null) {
    commitEnterViewTransitions(finishedWork, false);
    return;
  }
  switch (finishedWork.tag) {
    case HostRoot: {
      viewTransitionContextChanged = false;
      pushViewTransitionCancelableScope();
      recursivelyTraverseAfterMutationEffects(root2, finishedWork, lanes);
      if (!viewTransitionContextChanged && !rootViewTransitionAffected) {
        const cancelableChildren = viewTransitionCancelableChildren;
        if (cancelableChildren !== null) {
          for (let i = 0; i < cancelableChildren.length; i += 3) {
            (void 0)(
              cancelableChildren[i],
              cancelableChildren[i + 1],
              cancelableChildren[i + 2]
            );
          }
        }
        (void 0)(root2.containerInfo);
      }
      popViewTransitionCancelableScope(null);
      break;
    }
    case HostComponent: {
      recursivelyTraverseAfterMutationEffects(root2, finishedWork, lanes);
      break;
    }
    case HostPortal: {
      const prevContextChanged = viewTransitionContextChanged;
      viewTransitionContextChanged = false;
      recursivelyTraverseAfterMutationEffects(root2, finishedWork, lanes);
      if (viewTransitionContextChanged) {
        rootViewTransitionAffected = true;
      }
      viewTransitionContextChanged = prevContextChanged;
      break;
    }
    case OffscreenComponent: {
      const isModernRoot = disableLegacyMode || (finishedWork.mode & ConcurrentMode) !== NoMode;
      if (isModernRoot) {
        const isHidden = finishedWork.memoizedState !== null;
        if (isHidden) {
        } else {
          const wasHidden = current2.memoizedState !== null;
          if (wasHidden) {
            commitEnterViewTransitions(finishedWork, false);
          } else {
            recursivelyTraverseAfterMutationEffects(root2, finishedWork, lanes);
          }
        }
      } else {
        recursivelyTraverseAfterMutationEffects(root2, finishedWork, lanes);
      }
      break;
    }
    case ViewTransitionComponent: {
      const prevContextChanged = viewTransitionContextChanged;
      const prevCancelableChildren = pushViewTransitionCancelableScope();
      viewTransitionContextChanged = false;
      recursivelyTraverseAfterMutationEffects(root2, finishedWork, lanes);
      if (viewTransitionContextChanged) {
        finishedWork.flags |= Update;
      }
      const inViewport = measureUpdateViewTransition(
        current2,
        finishedWork,
        false
      );
      if ((finishedWork.flags & Update) === NoFlags || !inViewport) {
        if (prevCancelableChildren === null) {
        } else {
          prevCancelableChildren.push.apply(
            prevCancelableChildren,
            viewTransitionCancelableChildren
          );
          popViewTransitionCancelableScope(prevCancelableChildren);
        }
      } else {
        const props = finishedWork.memoizedProps;
        scheduleViewTransitionEvent(finishedWork, props.onUpdate);
        popViewTransitionCancelableScope(prevCancelableChildren);
      }
      if ((finishedWork.flags & AffectedParentLayout) !== NoFlags) {
        viewTransitionContextChanged = true;
      } else {
        viewTransitionContextChanged = prevContextChanged;
      }
      break;
    }
    default: {
      recursivelyTraverseAfterMutationEffects(root2, finishedWork, lanes);
      break;
    }
  }
}
function commitLayoutEffects(finishedWork, root2, committedLanes) {
  inProgressLanes = committedLanes;
  inProgressRoot = root2;
  resetComponentEffectTimers();
  const current2 = finishedWork.alternate;
  commitLayoutEffectOnFiber(root2, current2, finishedWork, committedLanes);
  inProgressLanes = null;
  inProgressRoot = null;
}
function recursivelyTraverseLayoutEffects(root2, parentFiber, lanes) {
  if (parentFiber.subtreeFlags & LayoutMask) {
    let child = parentFiber.child;
    while (child !== null) {
      const current2 = child.alternate;
      commitLayoutEffectOnFiber(root2, current2, child, lanes);
      child = child.sibling;
    }
  }
}
function disappearLayoutEffects(finishedWork) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent: {
      commitHookLayoutUnmountEffects(
        finishedWork,
        finishedWork.return,
        Layout
      );
      recursivelyTraverseDisappearLayoutEffects(finishedWork);
      break;
    }
    case ClassComponent: {
      safelyDetachRef(finishedWork, finishedWork.return);
      const instance = finishedWork.stateNode;
      if (typeof instance.componentWillUnmount === "function") {
        safelyCallComponentWillUnmount(
          finishedWork,
          finishedWork.return,
          instance
        );
      }
      recursivelyTraverseDisappearLayoutEffects(finishedWork);
      break;
    }
    case HostSingleton: {
      if (void 0) {
        commitHostSingletonRelease(finishedWork);
      }
    }
    case HostHoistable:
    case HostComponent: {
      safelyDetachRef(finishedWork, finishedWork.return);
      if (enableFragmentRefs && finishedWork.tag === HostComponent) {
        commitFragmentInstanceDeletionEffects(finishedWork);
      }
      recursivelyTraverseDisappearLayoutEffects(finishedWork);
      break;
    }
    case OffscreenComponent: {
      const isHidden = finishedWork.memoizedState !== null;
      if (isHidden) {
      } else {
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      break;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        if (false) {
          if (finishedWork.flags & ViewTransitionNamedStatic) {
            untrackNamedViewTransition(finishedWork);
          }
        }
        safelyDetachRef(finishedWork, finishedWork.return);
      }
      recursivelyTraverseDisappearLayoutEffects(finishedWork);
      break;
    }
    case Fragment: {
      if (enableFragmentRefs) {
        safelyDetachRef(finishedWork, finishedWork.return);
      }
    }
    default: {
      recursivelyTraverseDisappearLayoutEffects(finishedWork);
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectDuration > 0.05) {
    logComponentEffect(
      finishedWork,
      componentEffectStartTime,
      componentEffectEndTime,
      componentEffectDuration,
      componentEffectErrors
    );
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  let child = parentFiber.child;
  while (child !== null) {
    disappearLayoutEffects(child);
    child = child.sibling;
  }
}
function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      recursivelyTraverseReappearLayoutEffects(
        finishedRoot,
        finishedWork,
        includeWorkInProgressEffects
      );
      commitHookLayoutEffects(finishedWork, Layout);
      break;
    }
    case ClassComponent: {
      recursivelyTraverseReappearLayoutEffects(
        finishedRoot,
        finishedWork,
        includeWorkInProgressEffects
      );
      commitClassDidMount(finishedWork);
      commitClassHiddenCallbacks(finishedWork);
      if (includeWorkInProgressEffects && flags & Callback) {
        commitClassCallbacks(finishedWork);
      }
      safelyAttachRef(finishedWork, finishedWork.return);
      break;
    }
    // Unlike commitLayoutEffectsOnFiber, we don't need to handle HostRoot
    // because this function only visits nodes that are inside an
    // Offscreen fiber.
    // case HostRoot: {
    //  ...
    // }
    case HostSingleton: {
      if (void 0) {
        commitHostSingletonAcquisition(finishedWork);
      }
    }
    case HostHoistable:
    case HostComponent: {
      if (enableFragmentRefs && finishedWork.tag === HostComponent) {
        commitFragmentInstanceInsertionEffects(finishedWork);
      }
      recursivelyTraverseReappearLayoutEffects(
        finishedRoot,
        finishedWork,
        includeWorkInProgressEffects
      );
      if (includeWorkInProgressEffects && current2 === null && flags & Update) {
        commitHostMount(finishedWork);
      }
      safelyAttachRef(finishedWork, finishedWork.return);
      break;
    }
    case Profiler: {
      if (includeWorkInProgressEffects && flags & Update) {
        const prevProfilerEffectDuration = pushNestedEffectDurations();
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        const profilerInstance = finishedWork.stateNode;
        if (enableProfilerTimer && enableProfilerCommitHooks) {
          profilerInstance.effectDuration += bubbleNestedEffectDurations(
            prevProfilerEffectDuration
          );
        }
        commitProfilerUpdate(
          finishedWork,
          current2,
          commitStartTime,
          profilerInstance.effectDuration
        );
      } else {
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
      }
      break;
    }
    case ActivityComponent: {
      recursivelyTraverseReappearLayoutEffects(
        finishedRoot,
        finishedWork,
        includeWorkInProgressEffects
      );
      if (includeWorkInProgressEffects && flags & Update) {
        commitActivityHydrationCallbacks(finishedRoot, finishedWork);
      }
      break;
    }
    case SuspenseComponent: {
      recursivelyTraverseReappearLayoutEffects(
        finishedRoot,
        finishedWork,
        includeWorkInProgressEffects
      );
      if (includeWorkInProgressEffects && flags & Update) {
        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      }
      break;
    }
    case OffscreenComponent: {
      const offscreenState = finishedWork.memoizedState;
      const isHidden = offscreenState !== null;
      if (isHidden) {
      } else {
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
      }
      safelyAttachRef(finishedWork, finishedWork.return);
      break;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        if (false) {
          if (flags & ViewTransitionNamedStatic) {
            trackNamedViewTransition(finishedWork);
          }
        }
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      }
      break;
    }
    case Fragment: {
      if (enableFragmentRefs) {
        safelyAttachRef(finishedWork, finishedWork.return);
      }
    }
    default: {
      recursivelyTraverseReappearLayoutEffects(
        finishedRoot,
        finishedWork,
        includeWorkInProgressEffects
      );
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectDuration > 0.05) {
    logComponentEffect(
      finishedWork,
      componentEffectStartTime,
      componentEffectEndTime,
      componentEffectDuration,
      componentEffectErrors
    );
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
  const childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & LayoutMask) !== NoFlags;
  let child = parentFiber.child;
  while (child !== null) {
    const current2 = child.alternate;
    reappearLayoutEffects(
      finishedRoot,
      current2,
      child,
      childShouldIncludeWorkInProgressEffects
    );
    child = child.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current2, finishedWork, instance) {
  let previousCache = null;
  if (current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null) {
    previousCache = current2.memoizedState.cachePool.pool;
  }
  let nextCache = null;
  if (finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null) {
    nextCache = finishedWork.memoizedState.cachePool.pool;
  }
  if (nextCache !== previousCache) {
    if (nextCache != null) {
      retainCache(nextCache);
    }
    if (previousCache != null) {
      releaseCache(previousCache);
    }
  }
  if (enableTransitionTracing) {
    const offscreenState = finishedWork.memoizedState;
    const queue = finishedWork.updateQueue;
    const isHidden = offscreenState !== null;
    if (queue !== null) {
      if (isHidden) {
        const transitions = queue.transitions;
        if (transitions !== null) {
          transitions.forEach((transition) => {
            if (instance._transitions === null) {
              instance._transitions = /* @__PURE__ */ new Set();
            }
            instance._transitions.add(transition);
          });
        }
        const markerInstances = queue.markerInstances;
        if (markerInstances !== null) {
          markerInstances.forEach((markerInstance) => {
            const markerTransitions = markerInstance.transitions;
            if (markerTransitions !== null) {
              markerTransitions.forEach((transition) => {
                if (instance._transitions === null) {
                  instance._transitions = /* @__PURE__ */ new Set();
                } else if (instance._transitions.has(transition)) {
                  if (markerInstance.pendingBoundaries === null) {
                    markerInstance.pendingBoundaries = /* @__PURE__ */ new Map();
                  }
                  if (instance._pendingMarkers === null) {
                    instance._pendingMarkers = /* @__PURE__ */ new Set();
                  }
                  instance._pendingMarkers.add(markerInstance);
                }
              });
            }
          });
        }
      }
      finishedWork.updateQueue = null;
    }
    commitTransitionProgress(finishedWork);
    if (!isHidden) {
      instance._transitions = null;
      instance._pendingMarkers = null;
    }
  }
}
function commitCachePassiveMountEffect(current2, finishedWork) {
  let previousCache = null;
  if (finishedWork.alternate !== null) {
    previousCache = finishedWork.alternate.memoizedState.cache;
  }
  const nextCache = finishedWork.memoizedState.cache;
  if (nextCache !== previousCache) {
    retainCache(nextCache);
    if (previousCache != null) {
      releaseCache(previousCache);
    }
  }
}
function commitTracingMarkerPassiveMountEffect(finishedWork) {
  const instance = finishedWork.stateNode;
  if (instance.transitions !== null && instance.pendingBoundaries === null) {
    addMarkerCompleteCallbackToPendingTransition(
      finishedWork.memoizedProps.name,
      instance.transitions
    );
    instance.transitions = null;
    instance.pendingBoundaries = null;
    instance.aborts = null;
    instance.name = null;
  }
}
function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions, renderEndTime) {
  resetComponentEffectTimers();
  commitPassiveMountOnFiber(
    root2,
    finishedWork,
    committedLanes,
    committedTransitions,
    enableProfilerTimer && enableComponentPerformanceTrack ? renderEndTime : 0
  );
}
function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions, endTime) {
  const isViewTransitionEligible = enableViewTransition && includesOnlyViewTransitionEligibleLanes(committedLanes);
  const subtreeMask = isViewTransitionEligible ? PassiveTransitionMask : PassiveMask;
  if (parentFiber.subtreeFlags & subtreeMask || // If this subtree rendered with profiling this commit, we need to visit it to log it.
  enableProfilerTimer && enableComponentPerformanceTrack && parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child)) {
    let child = parentFiber.child;
    while (child !== null) {
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        const nextSibling = child.sibling;
        commitPassiveMountOnFiber(
          root2,
          child,
          committedLanes,
          committedTransitions,
          nextSibling !== null ? nextSibling.actualStartTime : endTime
        );
        child = nextSibling;
      } else {
        commitPassiveMountOnFiber(
          root2,
          child,
          committedLanes,
          committedTransitions,
          0
        );
        child = child.sibling;
      }
    }
  } else if (isViewTransitionEligible) {
    restoreNestedViewTransitions(parentFiber);
  }
}
var inHydratedSubtree = false;
function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  const isViewTransitionEligible = enableViewTransition ? includesOnlyViewTransitionEligibleLanes(committedLanes) : false;
  if (isViewTransitionEligible && finishedWork.alternate === null && // We can't use the Placement flag here because it gets reset earlier. Instead,
  // we check if this is the root of the insertion by checking if the parent
  // was previous existing.
  finishedWork.return !== null && finishedWork.return.alternate !== null) {
    restoreEnterOrExitViewTransitions(finishedWork);
  }
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      if (enableProfilerTimer && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && finishedWork.actualStartTime > 0 && (finishedWork.flags & PerformedWork) !== NoFlags) {
        logComponentRender(
          finishedWork,
          finishedWork.actualStartTime,
          endTime,
          inHydratedSubtree
        );
      }
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      if (flags & Passive) {
        commitHookPassiveMountEffects(
          finishedWork,
          Passive2 | HasEffect
        );
      }
      break;
    }
    case ClassComponent: {
      if (enableProfilerTimer && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && finishedWork.actualStartTime > 0) {
        if ((finishedWork.flags & DidCapture) !== NoFlags) {
          logComponentErrored(
            finishedWork,
            finishedWork.actualStartTime,
            endTime,
            // TODO: The captured values are all hidden inside the updater/callback closures so
            // we can't get to the errors but they're there so we should be able to log them.
            []
          );
        } else if ((finishedWork.flags & PerformedWork) !== NoFlags) {
          logComponentRender(
            finishedWork,
            finishedWork.actualStartTime,
            endTime,
            inHydratedSubtree
          );
        }
      }
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      break;
    }
    case HostRoot: {
      const prevProfilerEffectDuration = pushNestedEffectDurations();
      const wasInHydratedSubtree = inHydratedSubtree;
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        inHydratedSubtree = finishedWork.alternate !== null && finishedWork.alternate.memoizedState.isDehydrated && (finishedWork.flags & ForceClientRender) === NoFlags;
      }
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        inHydratedSubtree = wasInHydratedSubtree;
      }
      if (isViewTransitionEligible) {
        if (void 0) {
          (void 0)(finishedRoot.containerInfo);
        }
      }
      if (flags & Passive) {
        let previousCache = null;
        if (finishedWork.alternate !== null) {
          previousCache = finishedWork.alternate.memoizedState.cache;
        }
        const nextCache = finishedWork.memoizedState.cache;
        if (nextCache !== previousCache) {
          retainCache(nextCache);
          if (previousCache != null) {
            releaseCache(previousCache);
          }
        }
        if (enableTransitionTracing) {
          const root2 = finishedWork.stateNode;
          const incompleteTransitions = root2.incompleteTransitions;
          if (committedTransitions !== null) {
            committedTransitions.forEach((transition) => {
              addTransitionStartCallbackToPendingTransition(transition);
            });
            clearTransitionsForLanes(finishedRoot, committedLanes);
          }
          incompleteTransitions.forEach((markerInstance, transition) => {
            const pendingBoundaries = markerInstance.pendingBoundaries;
            if (pendingBoundaries === null || pendingBoundaries.size === 0) {
              if (markerInstance.aborts === null) {
                addTransitionCompleteCallbackToPendingTransition(transition);
              }
              incompleteTransitions.delete(transition);
            }
          });
          clearTransitionsForLanes(finishedRoot, committedLanes);
        }
      }
      if (enableProfilerTimer && enableProfilerCommitHooks) {
        finishedRoot.passiveEffectDuration += popNestedEffectDurations(
          prevProfilerEffectDuration
        );
      }
      break;
    }
    case Profiler: {
      if (flags & Passive) {
        const prevProfilerEffectDuration = pushNestedEffectDurations();
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          endTime
        );
        const profilerInstance = finishedWork.stateNode;
        if (enableProfilerTimer && enableProfilerCommitHooks) {
          profilerInstance.passiveEffectDuration += bubbleNestedEffectDurations(
            prevProfilerEffectDuration
          );
        }
        commitProfilerPostCommit(
          finishedWork,
          finishedWork.alternate,
          // This value will still reflect the previous commit phase.
          // It does not get reset until the start of the next commit phase.
          commitStartTime,
          profilerInstance.passiveEffectDuration
        );
      } else {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          endTime
        );
      }
      break;
    }
    case ActivityComponent: {
      const wasInHydratedSubtree = inHydratedSubtree;
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        const prevState = finishedWork.alternate !== null ? finishedWork.alternate.memoizedState : null;
        const nextState = finishedWork.memoizedState;
        if (prevState !== null && nextState === null) {
          const deletions = finishedWork.deletions;
          if (deletions !== null && deletions.length > 0 && deletions[0].tag === DehydratedFragment) {
            inHydratedSubtree = false;
            const hydrationErrors2 = prevState.hydrationErrors;
            if (hydrationErrors2 !== null) {
              const startTime2 = finishedWork.actualStartTime;
              logComponentErrored(
                finishedWork,
                startTime2,
                endTime,
                hydrationErrors2
              );
            }
          } else {
            inHydratedSubtree = true;
          }
        } else {
          inHydratedSubtree = false;
        }
      }
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        inHydratedSubtree = wasInHydratedSubtree;
      }
      break;
    }
    case SuspenseComponent: {
      const wasInHydratedSubtree = inHydratedSubtree;
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        const prevState = finishedWork.alternate !== null ? finishedWork.alternate.memoizedState : null;
        const nextState = finishedWork.memoizedState;
        if (prevState !== null && prevState.dehydrated !== null && (nextState === null || nextState.dehydrated === null)) {
          const deletions = finishedWork.deletions;
          if (deletions !== null && deletions.length > 0 && deletions[0].tag === DehydratedFragment) {
            inHydratedSubtree = false;
            const hydrationErrors2 = prevState.hydrationErrors;
            if (hydrationErrors2 !== null) {
              const startTime2 = finishedWork.actualStartTime;
              logComponentErrored(
                finishedWork,
                startTime2,
                endTime,
                hydrationErrors2
              );
            }
          } else {
            inHydratedSubtree = true;
          }
        } else {
          inHydratedSubtree = false;
        }
      }
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        inHydratedSubtree = wasInHydratedSubtree;
      }
      break;
    }
    case LegacyHiddenComponent: {
      if (enableLegacyHidden) {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          endTime
        );
        if (flags & Passive) {
          const current2 = finishedWork.alternate;
          const instance = finishedWork.stateNode;
          commitOffscreenPassiveMountEffects(current2, finishedWork, instance);
        }
      }
      break;
    }
    case OffscreenComponent: {
      const instance = finishedWork.stateNode;
      const current2 = finishedWork.alternate;
      const nextState = finishedWork.memoizedState;
      const isHidden = nextState !== null;
      if (isHidden) {
        if (isViewTransitionEligible && current2 !== null && current2.memoizedState === null) {
          restoreEnterOrExitViewTransitions(current2);
        }
        if (instance._visibility & OffscreenPassiveEffectsConnected) {
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
        } else {
          if (disableLegacyMode || finishedWork.mode & ConcurrentMode) {
            recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
          } else {
            instance._visibility |= OffscreenPassiveEffectsConnected;
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
          }
        }
      } else {
        if (isViewTransitionEligible && current2 !== null && current2.memoizedState !== null) {
          restoreEnterOrExitViewTransitions(finishedWork);
        }
        if (instance._visibility & OffscreenPassiveEffectsConnected) {
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            endTime
          );
        } else {
          instance._visibility |= OffscreenPassiveEffectsConnected;
          const includeWorkInProgressEffects = (finishedWork.subtreeFlags & PassiveMask) !== NoFlags;
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects,
            endTime
          );
          if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && !inHydratedSubtree) {
            const startTime2 = finishedWork.actualStartTime;
            if (startTime2 >= 0 && endTime - startTime2 > 0.05) {
              logComponentReappeared(finishedWork, startTime2, endTime);
            }
            if (componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectEndTime - componentEffectStartTime > 0.05) {
              logComponentReappeared(
                finishedWork,
                componentEffectStartTime,
                componentEffectEndTime
              );
            }
          }
        }
      }
      if (flags & Passive) {
        commitOffscreenPassiveMountEffects(current2, finishedWork, instance);
      }
      break;
    }
    case CacheComponent: {
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      if (flags & Passive) {
        const current2 = finishedWork.alternate;
        commitCachePassiveMountEffect(current2, finishedWork);
      }
      break;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        if (isViewTransitionEligible) {
          const current2 = finishedWork.alternate;
          if (current2 === null) {
          } else {
            restoreUpdateViewTransition(current2, finishedWork);
          }
        }
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          endTime
        );
        break;
      }
    }
    case TracingMarkerComponent: {
      if (enableTransitionTracing) {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          endTime
        );
        if (flags & Passive) {
          commitTracingMarkerPassiveMountEffect(finishedWork);
        }
        break;
      }
    }
    default: {
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode) {
    const isMount = !inHydratedSubtree && finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null;
    if (isMount) {
      const startTime2 = finishedWork.actualStartTime;
      if (startTime2 >= 0 && endTime - startTime2 > 0.05) {
        logComponentMount(finishedWork, startTime2, endTime);
      }
    }
    if (componentEffectStartTime >= 0 && componentEffectEndTime >= 0) {
      if (componentEffectDuration > 0.05) {
        logComponentEffect(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime,
          componentEffectDuration,
          componentEffectErrors
        );
      }
      if (isMount && componentEffectEndTime - componentEffectStartTime > 0.05) {
        logComponentMount(
          finishedWork,
          componentEffectStartTime,
          componentEffectEndTime
        );
      }
    }
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
  const childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & PassiveMask) !== NoFlags;
  let child = parentFiber.child;
  while (child !== null) {
    if (enableProfilerTimer && enableComponentPerformanceTrack) {
      const nextSibling = child.sibling;
      reconnectPassiveEffects(
        finishedRoot,
        child,
        committedLanes,
        committedTransitions,
        childShouldIncludeWorkInProgressEffects,
        nextSibling !== null ? nextSibling.actualStartTime : endTime
      );
      child = nextSibling;
    } else {
      reconnectPassiveEffects(
        finishedRoot,
        child,
        committedLanes,
        committedTransitions,
        childShouldIncludeWorkInProgressEffects,
        endTime
      );
      child = child.sibling;
    }
  }
}
function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  if (enableProfilerTimer && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && finishedWork.actualStartTime > 0 && (finishedWork.flags & PerformedWork) !== NoFlags) {
    logComponentRender(
      finishedWork,
      finishedWork.actualStartTime,
      endTime,
      inHydratedSubtree
    );
  }
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      recursivelyTraverseReconnectPassiveEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        includeWorkInProgressEffects,
        endTime
      );
      commitHookPassiveMountEffects(finishedWork, Passive2);
      break;
    }
    // Unlike commitPassiveMountOnFiber, we don't need to handle HostRoot
    // because this function only visits nodes that are inside an
    // Offscreen fiber.
    // case HostRoot: {
    //  ...
    // }
    case LegacyHiddenComponent: {
      if (enableLegacyHidden) {
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects,
          endTime
        );
        if (includeWorkInProgressEffects && flags & Passive) {
          const current2 = finishedWork.alternate;
          const instance = finishedWork.stateNode;
          commitOffscreenPassiveMountEffects(current2, finishedWork, instance);
        }
      }
      break;
    }
    case OffscreenComponent: {
      const instance = finishedWork.stateNode;
      const nextState = finishedWork.memoizedState;
      const isHidden = nextState !== null;
      if (isHidden) {
        if (instance._visibility & OffscreenPassiveEffectsConnected) {
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects,
            endTime
          );
        } else {
          if (disableLegacyMode || finishedWork.mode & ConcurrentMode) {
            recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              endTime
            );
          } else {
            instance._visibility |= OffscreenPassiveEffectsConnected;
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
              endTime
            );
          }
        }
      } else {
        instance._visibility |= OffscreenPassiveEffectsConnected;
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects,
          endTime
        );
      }
      if (includeWorkInProgressEffects && flags & Passive) {
        const current2 = finishedWork.alternate;
        commitOffscreenPassiveMountEffects(current2, finishedWork, instance);
      }
      break;
    }
    case CacheComponent: {
      recursivelyTraverseReconnectPassiveEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        includeWorkInProgressEffects,
        endTime
      );
      if (includeWorkInProgressEffects && flags & Passive) {
        const current2 = finishedWork.alternate;
        commitCachePassiveMountEffect(current2, finishedWork);
      }
      break;
    }
    case TracingMarkerComponent: {
      if (enableTransitionTracing) {
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects,
          endTime
        );
        if (includeWorkInProgressEffects && flags & Passive) {
          commitTracingMarkerPassiveMountEffect(finishedWork);
        }
        break;
      }
    }
    default: {
      recursivelyTraverseReconnectPassiveEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        includeWorkInProgressEffects,
        endTime
      );
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectDuration > 0.05) {
    logComponentEffect(
      finishedWork,
      componentEffectStartTime,
      componentEffectEndTime,
      componentEffectDuration,
      componentEffectErrors
    );
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function recursivelyTraverseAtomicPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, endTime) {
  if (parentFiber.subtreeFlags & PassiveMask) {
    let child = parentFiber.child;
    while (child !== null) {
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        const nextSibling = child.sibling;
        commitAtomicPassiveEffects(
          finishedRoot,
          child,
          committedLanes,
          committedTransitions,
          nextSibling !== null ? nextSibling.actualStartTime : endTime
        );
        child = nextSibling;
      } else {
        commitAtomicPassiveEffects(
          finishedRoot,
          child,
          committedLanes,
          committedTransitions,
          endTime
        );
        child = child.sibling;
      }
    }
  }
}
function commitAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
  if (enableProfilerTimer && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && finishedWork.actualStartTime > 0 && (finishedWork.flags & PerformedWork) !== NoFlags) {
    logComponentRender(
      finishedWork,
      finishedWork.actualStartTime,
      endTime,
      inHydratedSubtree
    );
  }
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case OffscreenComponent: {
      recursivelyTraverseAtomicPassiveEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      if (flags & Passive) {
        const current2 = finishedWork.alternate;
        const instance = finishedWork.stateNode;
        commitOffscreenPassiveMountEffects(current2, finishedWork, instance);
      }
      break;
    }
    case CacheComponent: {
      recursivelyTraverseAtomicPassiveEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      if (flags & Passive) {
        const current2 = finishedWork.alternate;
        commitCachePassiveMountEffect(current2, finishedWork);
      }
      break;
    }
    default: {
      recursivelyTraverseAtomicPassiveEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        endTime
      );
      break;
    }
  }
}
function commitPassiveUnmountEffects(finishedWork) {
  resetComponentEffectTimers();
  commitPassiveUnmountOnFiber(finishedWork);
}
var suspenseyCommitFlag = ShouldSuspendCommit;
function accumulateSuspenseyCommit(finishedWork, committedLanes) {
  resetAppearingViewTransitions();
  accumulateSuspenseyCommitOnFiber(finishedWork, committedLanes);
}
function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag) {
    let child = parentFiber.child;
    while (child !== null) {
      accumulateSuspenseyCommitOnFiber(child, committedLanes);
      child = child.sibling;
    }
  }
}
function accumulateSuspenseyCommitOnFiber(fiber, committedLanes) {
  switch (fiber.tag) {
    case HostHoistable: {
      recursivelyAccumulateSuspenseyCommit(fiber, committedLanes);
      if (fiber.flags & suspenseyCommitFlag) {
        if (fiber.memoizedState !== null) {
          (void 0)(
            // This should always be set by visiting HostRoot first
            currentHoistableRoot,
            fiber.memoizedState,
            fiber.memoizedProps
          );
        } else {
          const instance = fiber.stateNode;
          const type = fiber.type;
          const props = fiber.memoizedProps;
          if (includesOnlySuspenseyCommitEligibleLanes(committedLanes) || (void 0)(type, props)) {
            (void 0)(instance, type, props);
          }
        }
      }
      break;
    }
    case HostComponent: {
      recursivelyAccumulateSuspenseyCommit(fiber, committedLanes);
      if (fiber.flags & suspenseyCommitFlag) {
        const instance = fiber.stateNode;
        const type = fiber.type;
        const props = fiber.memoizedProps;
        if (includesOnlySuspenseyCommitEligibleLanes(committedLanes) || (void 0)(type, props)) {
          (void 0)(instance, type, props);
        }
      }
      break;
    }
    case HostRoot:
    case HostPortal: {
      if (void 0) {
        const previousHoistableRoot = currentHoistableRoot;
        const container = fiber.stateNode.containerInfo;
        currentHoistableRoot = (void 0)(container);
        recursivelyAccumulateSuspenseyCommit(fiber, committedLanes);
        currentHoistableRoot = previousHoistableRoot;
      } else {
        recursivelyAccumulateSuspenseyCommit(fiber, committedLanes);
      }
      break;
    }
    case OffscreenComponent: {
      const isHidden = fiber.memoizedState !== null;
      if (isHidden) {
      } else {
        const current2 = fiber.alternate;
        const wasHidden = current2 !== null && current2.memoizedState !== null;
        if (wasHidden) {
          const prevFlags = suspenseyCommitFlag;
          suspenseyCommitFlag = MaySuspendCommit;
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes);
          suspenseyCommitFlag = prevFlags;
        } else {
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes);
        }
      }
      break;
    }
    case ViewTransitionComponent: {
      if (enableViewTransition) {
        if ((fiber.flags & suspenseyCommitFlag) !== NoFlags) {
          const props = fiber.memoizedProps;
          const name = props.name;
          if (name != null && name !== "auto") {
            const state = fiber.stateNode;
            state.paired = null;
            trackAppearingViewTransition(name, state);
          }
        }
        recursivelyAccumulateSuspenseyCommit(fiber, committedLanes);
        break;
      }
    }
    default: {
      recursivelyAccumulateSuspenseyCommit(fiber, committedLanes);
    }
  }
}
function detachAlternateSiblings(parentFiber) {
  const previousFiber = parentFiber.alternate;
  if (previousFiber !== null) {
    let detachedChild = previousFiber.child;
    if (detachedChild !== null) {
      previousFiber.child = null;
      do {
        const detachedSibling = detachedChild.sibling;
        detachedChild.sibling = null;
        detachedChild = detachedSibling;
      } while (detachedChild !== null);
    }
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  const deletions = parentFiber.deletions;
  if ((parentFiber.flags & ChildDeletion) !== NoFlags) {
    if (deletions !== null) {
      for (let i = 0; i < deletions.length; i++) {
        const childToDelete = deletions[i];
        const prevEffectStart = pushComponentEffectStart();
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
        if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (childToDelete.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectEndTime - componentEffectStartTime > 0.05) {
          logComponentUnmount(
            childToDelete,
            componentEffectStartTime,
            componentEffectEndTime
          );
        }
        popComponentEffectStart(prevEffectStart);
      }
    }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & PassiveMask) {
    let child = parentFiber.child;
    while (child !== null) {
      commitPassiveUnmountOnFiber(child);
      child = child.sibling;
    }
  }
}
function commitPassiveUnmountOnFiber(finishedWork) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (finishedWork.flags & Passive) {
        commitHookPassiveUnmountEffects(
          finishedWork,
          finishedWork.return,
          Passive2 | HasEffect
        );
      }
      break;
    }
    case HostRoot: {
      const prevProfilerEffectDuration = pushNestedEffectDurations();
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (enableProfilerTimer && enableProfilerCommitHooks) {
        const finishedRoot = finishedWork.stateNode;
        finishedRoot.passiveEffectDuration += popNestedEffectDurations(
          prevProfilerEffectDuration
        );
      }
      break;
    }
    case Profiler: {
      const prevProfilerEffectDuration = pushNestedEffectDurations();
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      if (enableProfilerTimer && enableProfilerCommitHooks) {
        const profilerInstance = finishedWork.stateNode;
        profilerInstance.passiveEffectDuration += bubbleNestedEffectDurations(
          prevProfilerEffectDuration
        );
      }
      break;
    }
    case OffscreenComponent: {
      const instance = finishedWork.stateNode;
      const nextState = finishedWork.memoizedState;
      const isHidden = nextState !== null;
      if (isHidden && instance._visibility & OffscreenPassiveEffectsConnected && // For backwards compatibility, don't unmount when a tree suspends. In
      // the future we may change this to unmount after a delay.
      (finishedWork.return === null || finishedWork.return.tag !== SuspenseComponent)) {
        instance._visibility &= ~OffscreenPassiveEffectsConnected;
        recursivelyTraverseDisconnectPassiveEffects(finishedWork);
        if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectEndTime - componentEffectStartTime > 0.05) {
          logComponentDisappeared(
            finishedWork,
            componentEffectStartTime,
            componentEffectEndTime
          );
        }
      } else {
        recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
      break;
    }
    default: {
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectDuration > 0.05) {
    logComponentEffect(
      finishedWork,
      componentEffectStartTime,
      componentEffectEndTime,
      componentEffectDuration,
      componentEffectErrors
    );
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  const deletions = parentFiber.deletions;
  if ((parentFiber.flags & ChildDeletion) !== NoFlags) {
    if (deletions !== null) {
      for (let i = 0; i < deletions.length; i++) {
        const childToDelete = deletions[i];
        const prevEffectStart = pushComponentEffectStart();
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
        if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (childToDelete.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectEndTime - componentEffectStartTime > 0.05) {
          logComponentUnmount(
            childToDelete,
            componentEffectStartTime,
            componentEffectEndTime
          );
        }
        popComponentEffectStart(prevEffectStart);
      }
    }
    detachAlternateSiblings(parentFiber);
  }
  let child = parentFiber.child;
  while (child !== null) {
    disconnectPassiveEffect(child);
    child = child.sibling;
  }
}
function disconnectPassiveEffect(finishedWork) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      commitHookPassiveUnmountEffects(
        finishedWork,
        finishedWork.return,
        Passive2
      );
      recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      break;
    }
    case OffscreenComponent: {
      const instance = finishedWork.stateNode;
      if (instance._visibility & OffscreenPassiveEffectsConnected) {
        instance._visibility &= ~OffscreenPassiveEffectsConnected;
        recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      } else {
      }
      break;
    }
    default: {
      recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (finishedWork.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectDuration > 0.05) {
    logComponentEffect(
      finishedWork,
      componentEffectStartTime,
      componentEffectEndTime,
      componentEffectDuration,
      componentEffectErrors
    );
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
  while (nextEffect !== null) {
    const fiber = nextEffect;
    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
    const child = fiber.child;
    if (child !== null) {
      child.return = fiber;
      nextEffect = child;
    } else {
      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(
        deletedSubtreeRoot
      );
    }
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
  while (nextEffect !== null) {
    const fiber = nextEffect;
    const sibling = fiber.sibling;
    const returnFiber = fiber.return;
    detachFiberAfterEffects(fiber);
    if (fiber === deletedSubtreeRoot) {
      nextEffect = null;
      return;
    }
    if (sibling !== null) {
      sibling.return = returnFiber;
      nextEffect = sibling;
      return;
    }
    nextEffect = returnFiber;
  }
}
function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
  const prevEffectStart = pushComponentEffectStart();
  const prevEffectDuration = pushComponentEffectDuration();
  const prevEffectErrors = pushComponentEffectErrors();
  switch (current2.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent: {
      commitHookPassiveUnmountEffects(
        current2,
        nearestMountedAncestor,
        Passive2
      );
      break;
    }
    // TODO: run passive unmount effects when unmounting a root.
    // Because passive unmount effects are not currently run,
    // the cache instance owned by the root will never be freed.
    // When effects are run, the cache should be freed here:
    // case HostRoot: {
    //   const cache = current.memoizedState.cache;
    //   releaseCache(cache);
    //   break;
    // }
    case LegacyHiddenComponent:
    case OffscreenComponent: {
      if (current2.memoizedState !== null && current2.memoizedState.cachePool !== null) {
        const cache3 = current2.memoizedState.cachePool.pool;
        if (cache3 != null) {
          retainCache(cache3);
        }
      }
      break;
    }
    case SuspenseComponent: {
      if (enableTransitionTracing) {
        const offscreenFiber = current2.child;
        const instance = offscreenFiber.stateNode;
        const transitions = instance._transitions;
        if (transitions !== null) {
          const abortReason = {
            reason: "suspense",
            name: current2.memoizedProps.name || null
          };
          if (current2.memoizedState === null || current2.memoizedState.dehydrated === null) {
            abortParentMarkerTransitionsForDeletedFiber(
              offscreenFiber,
              abortReason,
              transitions,
              instance,
              true
            );
            if (nearestMountedAncestor !== null) {
              abortParentMarkerTransitionsForDeletedFiber(
                nearestMountedAncestor,
                abortReason,
                transitions,
                instance,
                false
              );
            }
          }
        }
      }
      break;
    }
    case CacheComponent: {
      const cache3 = current2.memoizedState.cache;
      releaseCache(cache3);
      break;
    }
    case TracingMarkerComponent: {
      if (enableTransitionTracing) {
        const instance = current2.stateNode;
        const transitions = instance.transitions;
        if (transitions !== null) {
          const abortReason = {
            reason: "marker",
            name: current2.memoizedProps.name
          };
          abortParentMarkerTransitionsForDeletedFiber(
            current2,
            abortReason,
            transitions,
            null,
            true
          );
          if (nearestMountedAncestor !== null) {
            abortParentMarkerTransitionsForDeletedFiber(
              nearestMountedAncestor,
              abortReason,
              transitions,
              null,
              false
            );
          }
        }
      }
      break;
    }
  }
  if (enableProfilerTimer && enableProfilerCommitHooks && enableComponentPerformanceTrack && (current2.mode & ProfileMode) !== NoMode && componentEffectStartTime >= 0 && componentEffectEndTime >= 0 && componentEffectDuration > 0.05) {
    logComponentEffect(
      current2,
      componentEffectStartTime,
      componentEffectEndTime,
      componentEffectDuration,
      componentEffectErrors
    );
  }
  popComponentEffectStart(prevEffectStart);
  popComponentEffectDuration(prevEffectDuration);
  popComponentEffectErrors(prevEffectErrors);
}

// dist/react-reconciler/src/ReactFiberApplyGesture.js
var viewTransitionContextChanged2 = false;
function detectMutationOrInsertClones(finishedWork) {
  return true;
}
var CLONE_UPDATE = 0;
var CLONE_EXIT = 1;
var CLONE_UNHIDE = 2;
var CLONE_APPEARING_PAIR = 3;
var CLONE_UNCHANGED = 4;
var INSERT_EXIT = 5;
var INSERT_APPEND = 6;
var INSERT_APPEARING_PAIR = 7;
function applyViewTransitionToClones(name, className, clones) {
  for (let i = 0; i < clones.length; i++) {
    (void 0)(
      clones[i],
      i === 0 ? name : (
        // If we have multiple Host Instances below, we add a suffix to the name to give
        // each one a unique name.
        name + "_" + i
      ),
      className
    );
  }
}
function trackDeletedPairViewTransitions(deletion) {
  if (appearingViewTransitions === null || appearingViewTransitions.size === 0) {
    return;
  }
  const pairs = appearingViewTransitions;
  if ((deletion.subtreeFlags & ViewTransitionNamedStatic) === NoFlags) {
    return;
  }
  let child = deletion.child;
  while (child !== null) {
    if (child.tag === OffscreenComponent && child.memoizedState === null) {
    } else {
      if (child.tag === ViewTransitionComponent && (child.flags & ViewTransitionNamedStatic) !== NoFlags) {
        const props = child.memoizedProps;
        const name = props.name;
        if (name != null && name !== "auto") {
          const pair = pairs.get(name);
          if (pair !== void 0) {
            pairs.delete(name);
            const className = getViewTransitionClassName(
              props.default,
              props.share
            );
            if (className !== "none") {
              const oldInstance = pair;
              const newInstance = child.stateNode;
              oldInstance.paired = newInstance;
              newInstance.paired = oldInstance;
              const clones = oldInstance.clones;
              if (clones !== null) {
                applyViewTransitionToClones(name, className, clones);
              }
            }
            if (pairs.size === 0) {
              break;
            }
          }
        }
      }
      trackDeletedPairViewTransitions(child);
    }
    child = child.sibling;
  }
}
function trackEnterViewTransitions2(deletion) {
  if (deletion.tag === ViewTransitionComponent) {
    const props = deletion.memoizedProps;
    const name = getViewTransitionName(props, deletion.stateNode);
    const pair = appearingViewTransitions !== null ? appearingViewTransitions.get(name) : void 0;
    const className = getViewTransitionClassName(
      props.default,
      pair !== void 0 ? props.share : props.enter
    );
    if (className !== "none") {
      if (pair !== void 0) {
        appearingViewTransitions.delete(name);
        const oldInstance = pair;
        const newInstance = deletion.stateNode;
        oldInstance.paired = newInstance;
        newInstance.paired = oldInstance;
        const clones = oldInstance.clones;
        if (clones !== null) {
          applyViewTransitionToClones(name, className, clones);
        }
      }
    }
    trackDeletedPairViewTransitions(deletion);
  } else if ((deletion.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
    let child = deletion.child;
    while (child !== null) {
      trackEnterViewTransitions2(child);
      child = child.sibling;
    }
  } else {
    trackDeletedPairViewTransitions(deletion);
  }
}
function applyAppearingPairViewTransition(child) {
  if ((child.flags & ViewTransitionNamedStatic) !== NoFlags) {
    const state = child.stateNode;
    if (state.paired) {
      const props = child.memoizedProps;
      if (props.name == null || props.name === "auto") {
        throw new Error(
          "Found a pair with an auto name. This is a bug in React."
        );
      }
      const name = props.name;
      const className = getViewTransitionClassName(
        props.default,
        props.share
      );
      if (className !== "none") {
        const clones = state.clones;
        if (clones !== null) {
          applyViewTransitionToClones(name, className, clones);
        }
      }
    }
  }
}
function applyExitViewTransition(placement) {
  const state = placement.stateNode;
  const props = placement.memoizedProps;
  const name = getViewTransitionName(props, state);
  const className = getViewTransitionClassName(
    props.default,
    // Note that just because we don't have a pair yet doesn't mean we won't find one
    // later. However, that doesn't matter because if we do the class name that wins
    // is the one applied by the "new" side anyway.
    state.paired ? props.share : props.exit
  );
  if (className !== "none") {
    const clones = state.clones;
    if (clones !== null) {
      applyViewTransitionToClones(name, className, clones);
    }
  }
}
function applyNestedViewTransition(child) {
  const state = child.stateNode;
  const props = child.memoizedProps;
  const name = getViewTransitionName(props, state);
  const className = getViewTransitionClassName(
    props.default,
    props.update
  );
  if (className !== "none") {
    const clones = state.clones;
    if (clones !== null) {
      applyViewTransitionToClones(name, className, clones);
    }
  }
}
function applyUpdateViewTransition(current2, finishedWork) {
  const state = finishedWork.stateNode;
  const newProps = current2.memoizedProps;
  const oldProps = finishedWork.memoizedProps;
  const oldName = getViewTransitionName(oldProps, state);
  const className = getViewTransitionClassName(
    newProps.default,
    newProps.update
  );
  if (className === "none") {
    return;
  }
  const clones = state.clones;
  if (clones !== null) {
    applyViewTransitionToClones(oldName, className, clones);
  }
}
function recursivelyInsertNew(parentFiber, hostParentClone, parentViewTransition, visitPhase) {
  if (visitPhase === INSERT_APPEARING_PAIR && parentViewTransition === null && (parentFiber.subtreeFlags & ViewTransitionNamedStatic) === NoFlags) {
    return;
  }
  let child = parentFiber.child;
  while (child !== null) {
    recursivelyInsertNewFiber(
      child,
      hostParentClone,
      parentViewTransition,
      visitPhase
    );
    child = child.sibling;
  }
}
function recursivelyInsertNewFiber(finishedWork, hostParentClone, parentViewTransition, visitPhase) {
  switch (finishedWork.tag) {
    case HostHoistable: {
      if (void 0) {
        recursivelyInsertNew(
          finishedWork,
          hostParentClone,
          parentViewTransition,
          visitPhase
        );
        break;
      }
    }
    case HostSingleton: {
      if (void 0) {
        recursivelyInsertNew(
          finishedWork,
          hostParentClone,
          parentViewTransition,
          visitPhase
        );
        if (false) {
          if (finishedWork.flags & Update) {
            console.error(
              "startGestureTransition() caused something to render a new <%s>. This is not possible in the current implementation. Make sure that the swipe doesn't mount any new <%s> elements.",
              finishedWork.type,
              finishedWork.type
            );
          }
        }
        break;
      }
    }
    case HostComponent: {
      const instance = finishedWork.stateNode;
      if (visitPhase !== INSERT_APPEARING_PAIR) {
        (void 0)(hostParentClone, instance);
        trackHostMutation();
        recursivelyInsertNew(
          finishedWork,
          instance,
          null,
          INSERT_APPEARING_PAIR
        );
      } else {
        recursivelyInsertNew(finishedWork, instance, null, visitPhase);
      }
      if (parentViewTransition !== null) {
        if (parentViewTransition.clones === null) {
          parentViewTransition.clones = [instance];
        } else {
          parentViewTransition.clones.push(instance);
        }
      }
      break;
    }
    case HostText: {
      const textInstance = finishedWork.stateNode;
      if (textInstance === null) {
        throw new Error(
          "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
        );
      }
      if (visitPhase !== INSERT_APPEARING_PAIR) {
        (void 0)(hostParentClone, textInstance);
        trackHostMutation();
      }
      break;
    }
    case HostPortal: {
      break;
    }
    case OffscreenComponent: {
      const newState = finishedWork.memoizedState;
      const isHidden = newState !== null;
      if (!isHidden) {
        recursivelyInsertNew(
          finishedWork,
          hostParentClone,
          parentViewTransition,
          visitPhase
        );
      }
      break;
    }
    case ViewTransitionComponent:
      const prevMutationContext = pushMutationContext();
      const viewTransitionState = finishedWork.stateNode;
      viewTransitionState.clones = null;
      let nextPhase;
      if (visitPhase === INSERT_EXIT) {
        nextPhase = INSERT_APPEND;
      } else {
        nextPhase = visitPhase;
      }
      recursivelyInsertNew(
        finishedWork,
        hostParentClone,
        viewTransitionState,
        nextPhase
      );
      if (visitPhase === INSERT_EXIT) {
        applyExitViewTransition(finishedWork);
      } else if (visitPhase === INSERT_APPEARING_PAIR || visitPhase === INSERT_APPEND) {
        applyAppearingPairViewTransition(finishedWork);
      }
      popMutationContext(prevMutationContext);
      break;
    default: {
      recursivelyInsertNew(
        finishedWork,
        hostParentClone,
        parentViewTransition,
        visitPhase
      );
      break;
    }
  }
}
function recursivelyInsertClonesFromExistingTree(parentFiber, hostParentClone, parentViewTransition, visitPhase) {
  let child = parentFiber.child;
  while (child !== null) {
    switch (child.tag) {
      case HostComponent: {
        const instance = child.stateNode;
        let nextPhase2;
        switch (visitPhase) {
          case CLONE_EXIT:
          case CLONE_UNHIDE:
          case CLONE_APPEARING_PAIR:
            nextPhase2 = (child.subtreeFlags & ViewTransitionNamedStatic) !== NoFlags ? CLONE_APPEARING_PAIR : CLONE_UNCHANGED;
            break;
          default:
            nextPhase2 = CLONE_UNCHANGED;
        }
        let clone;
        if (nextPhase2 !== CLONE_UNCHANGED) {
          clone = (void 0)(instance, false);
          recursivelyInsertClonesFromExistingTree(
            child,
            clone,
            null,
            nextPhase2
          );
        } else {
          clone = (void 0)(instance, true);
        }
        (void 0)(hostParentClone, clone);
        if (parentViewTransition !== null) {
          if (parentViewTransition.clones === null) {
            parentViewTransition.clones = [clone];
          } else {
            parentViewTransition.clones.push(clone);
          }
        }
        if (visitPhase === CLONE_EXIT || visitPhase === CLONE_UNHIDE) {
          (void 0)(clone, child.memoizedProps);
          trackHostMutation();
        }
        break;
      }
      case HostText: {
        const textInstance = child.stateNode;
        if (textInstance === null) {
          throw new Error(
            "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        const clone = (void 0)(textInstance);
        (void 0)(hostParentClone, clone);
        if (visitPhase === CLONE_EXIT || visitPhase === CLONE_UNHIDE) {
          (void 0)(clone, child.memoizedProps);
          trackHostMutation();
        }
        break;
      }
      case HostPortal: {
        break;
      }
      case OffscreenComponent: {
        const newState = child.memoizedState;
        const isHidden = newState !== null;
        if (!isHidden) {
          recursivelyInsertClonesFromExistingTree(
            child,
            hostParentClone,
            parentViewTransition,
            visitPhase
          );
        }
        break;
      }
      case ViewTransitionComponent:
        const prevMutationContext = pushMutationContext();
        const viewTransitionState = child.stateNode;
        viewTransitionState.clones = null;
        child.flags &= ~Update;
        let nextPhase;
        if (visitPhase === CLONE_EXIT) {
          nextPhase = CLONE_UNHIDE;
        } else if (visitPhase === CLONE_UPDATE) {
          nextPhase = CLONE_UNCHANGED;
        } else {
          nextPhase = visitPhase;
        }
        recursivelyInsertClonesFromExistingTree(
          child,
          hostParentClone,
          viewTransitionState,
          nextPhase
        );
        if (visitPhase === CLONE_EXIT) {
          applyExitViewTransition(child);
        } else if (visitPhase === CLONE_APPEARING_PAIR || visitPhase === CLONE_UNHIDE) {
          applyAppearingPairViewTransition(child);
        } else if (visitPhase === CLONE_UPDATE) {
          applyNestedViewTransition(child);
        }
        popMutationContext(prevMutationContext);
        break;
      default: {
        recursivelyInsertClonesFromExistingTree(
          child,
          hostParentClone,
          parentViewTransition,
          visitPhase
        );
        break;
      }
    }
    child = child.sibling;
  }
}
function recursivelyInsertClones(parentFiber, hostParentClone, parentViewTransition, visitPhase) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      trackEnterViewTransitions2(childToDelete);
      trackHostMutation();
    }
  }
  if (parentFiber.alternate === null || (parentFiber.subtreeFlags & MutationMask) !== NoFlags) {
    let child = parentFiber.child;
    while (child !== null) {
      insertDestinationClonesOfFiber(
        child,
        hostParentClone,
        parentViewTransition,
        visitPhase
      );
      child = child.sibling;
    }
  } else {
    recursivelyInsertClonesFromExistingTree(
      parentFiber,
      hostParentClone,
      parentViewTransition,
      visitPhase
    );
  }
}
function insertDestinationClonesOfFiber(finishedWork, hostParentClone, parentViewTransition, visitPhase) {
  const current2 = finishedWork.alternate;
  if (current2 === null) {
    recursivelyInsertNewFiber(
      finishedWork,
      hostParentClone,
      parentViewTransition,
      INSERT_EXIT
    );
    return;
  }
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostHoistable: {
      if (void 0) {
        recursivelyInsertClones(
          finishedWork,
          hostParentClone,
          parentViewTransition,
          visitPhase
        );
        break;
      }
    }
    case HostSingleton: {
      if (void 0) {
        recursivelyInsertClones(
          finishedWork,
          hostParentClone,
          parentViewTransition,
          visitPhase
        );
        if (false) {
          if (flags & Update) {
            const newProps = finishedWork.memoizedProps;
            const oldProps = current2.memoizedProps;
            const instance = finishedWork.stateNode;
            const type = finishedWork.type;
            const prev = pushMutationContext();
            try {
              (void 0)(instance, type, oldProps, newProps, finishedWork);
              if (viewTransitionMutationContext) {
                console.error(
                  "startGestureTransition() caused something to mutate <%s>. This is not possible in the current implementation. Make sure that the swipe doesn't update any state which causes <%s> to change.",
                  finishedWork.type,
                  finishedWork.type
                );
              }
              (void 0)(instance, type, newProps, oldProps, finishedWork);
            } finally {
              popMutationContext(prev);
            }
          }
        }
        break;
      }
    }
    case HostComponent: {
      const instance = finishedWork.stateNode;
      let clone;
      if (finishedWork.child === null) {
        clone = (void 0)(instance, true);
        if (finishedWork.flags & ContentReset) {
          (void 0)(clone);
          trackHostMutation();
        }
      } else {
        clone = (void 0)(instance, false);
      }
      if (flags & Update) {
        const newProps = finishedWork.memoizedProps;
        const oldProps = current2.memoizedProps;
        const type = finishedWork.type;
        (void 0)(clone, type, oldProps, newProps, finishedWork);
      }
      if (visitPhase === CLONE_EXIT || visitPhase === CLONE_UNHIDE) {
        (void 0)(hostParentClone, clone);
        (void 0)(clone, finishedWork.memoizedProps);
        recursivelyInsertClones(
          finishedWork,
          clone,
          null,
          CLONE_APPEARING_PAIR
        );
        trackHostMutation();
      } else {
        (void 0)(hostParentClone, clone);
        recursivelyInsertClones(finishedWork, clone, null, visitPhase);
      }
      if (parentViewTransition !== null) {
        if (parentViewTransition.clones === null) {
          parentViewTransition.clones = [clone];
        } else {
          parentViewTransition.clones.push(clone);
        }
      }
      break;
    }
    case HostText: {
      const textInstance = finishedWork.stateNode;
      if (textInstance === null) {
        throw new Error(
          "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
        );
      }
      const clone = (void 0)(textInstance);
      if (flags & Update) {
        const newText = finishedWork.memoizedProps;
        const oldText = current2.memoizedProps;
        (void 0)(clone, newText, oldText);
        trackHostMutation();
      }
      (void 0)(hostParentClone, clone);
      if (visitPhase === CLONE_EXIT || visitPhase === CLONE_UNHIDE) {
        (void 0)(clone, finishedWork.memoizedProps);
        trackHostMutation();
      }
      break;
    }
    case HostPortal: {
      break;
    }
    case OffscreenComponent: {
      const newState = finishedWork.memoizedState;
      const isHidden = newState !== null;
      if (!isHidden) {
        let nextPhase2;
        if (visitPhase === CLONE_UPDATE && (flags & Visibility) !== NoFlags) {
          nextPhase2 = CLONE_EXIT;
        } else {
          nextPhase2 = visitPhase;
        }
        recursivelyInsertClones(
          finishedWork,
          hostParentClone,
          parentViewTransition,
          nextPhase2
        );
      } else if (current2 !== null && current2.memoizedState === null) {
        trackEnterViewTransitions2(current2);
        trackHostMutation();
      }
      break;
    }
    case ViewTransitionComponent:
      const prevMutationContext = pushMutationContext();
      const viewTransitionState = finishedWork.stateNode;
      viewTransitionState.clones = null;
      let nextPhase;
      if (visitPhase === CLONE_EXIT) {
        nextPhase = CLONE_UNHIDE;
      } else {
        nextPhase = visitPhase;
      }
      recursivelyInsertClones(
        finishedWork,
        hostParentClone,
        viewTransitionState,
        nextPhase
      );
      if (viewTransitionMutationContext) {
        finishedWork.flags |= Update;
      }
      if (visitPhase === CLONE_EXIT) {
        applyExitViewTransition(finishedWork);
      } else if (visitPhase === CLONE_APPEARING_PAIR || visitPhase === CLONE_UNHIDE) {
        applyAppearingPairViewTransition(finishedWork);
      } else if (visitPhase === CLONE_UPDATE) {
        applyUpdateViewTransition(current2, finishedWork);
      }
      popMutationContext(prevMutationContext);
      break;
    default: {
      recursivelyInsertClones(
        finishedWork,
        hostParentClone,
        parentViewTransition,
        visitPhase
      );
      break;
    }
  }
}
function insertDestinationClones(root2, finishedWork) {
  const needsClone = detectMutationOrInsertClones(finishedWork);
  if (needsClone) {
    if (false) {
      if (!didWarnForRootClone) {
        didWarnForRootClone = true;
        console.warn(
          "startGestureTransition() caused something to mutate or relayout the root. This currently requires a clone of the whole document. Make sure to add a <ViewTransition> directly around an absolutely positioned DOM node to minimize the impact of any changes caused by the Gesture Transition."
        );
      }
    }
    const rootClone = (void 0)(root2.containerInfo);
    root2.gestureClone = rootClone;
    recursivelyInsertClones(finishedWork, rootClone, null, CLONE_UPDATE);
  } else {
    root2.gestureClone = null;
    (void 0)(root2.containerInfo);
  }
}
function measureExitViewTransitions(placement) {
  if (placement.tag === ViewTransitionComponent) {
    const props = placement.memoizedProps;
    const name = props.name;
    if (name != null && name !== "auto") {
    }
  } else if ((placement.subtreeFlags & ViewTransitionStatic) !== NoFlags) {
    let child = placement.child;
    while (child !== null) {
      measureExitViewTransitions(child);
      child = child.sibling;
    }
  } else {
  }
}
function recursivelyApplyViewTransitions(parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      commitEnterViewTransitions(childToDelete, true);
    }
  }
  if (parentFiber.alternate === null || (parentFiber.subtreeFlags & MutationMask) !== NoFlags) {
    let child = parentFiber.child;
    while (child !== null) {
      applyViewTransitionsOnFiber(child);
      child = child.sibling;
    }
  } else {
    measureNestedViewTransitions(parentFiber, true);
  }
}
function applyViewTransitionsOnFiber(finishedWork) {
  const current2 = finishedWork.alternate;
  if (current2 === null) {
    measureExitViewTransitions(finishedWork);
    return;
  }
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostPortal: {
      break;
    }
    case OffscreenComponent: {
      if (flags & Visibility) {
        const newState = finishedWork.memoizedState;
        const isHidden = newState !== null;
        if (!isHidden) {
          measureExitViewTransitions(finishedWork);
        } else if (current2 !== null && current2.memoizedState === null) {
          commitEnterViewTransitions(current2, true);
        }
      }
      break;
    }
    case ViewTransitionComponent: {
      const prevContextChanged = viewTransitionContextChanged2;
      const prevCancelableChildren = pushViewTransitionCancelableScope();
      viewTransitionContextChanged2 = false;
      recursivelyApplyViewTransitions(finishedWork);
      if (viewTransitionContextChanged2) {
        finishedWork.flags |= Update;
      }
      const inViewport = measureUpdateViewTransition(
        current2,
        finishedWork,
        true
      );
      if ((finishedWork.flags & Update) === NoFlags || !inViewport) {
        if (prevCancelableChildren === null) {
        } else {
          prevCancelableChildren.push.apply(
            prevCancelableChildren,
            viewTransitionCancelableChildren
          );
          popViewTransitionCancelableScope(prevCancelableChildren);
        }
      } else {
        popViewTransitionCancelableScope(prevCancelableChildren);
      }
      if ((finishedWork.flags & AffectedParentLayout) !== NoFlags) {
        viewTransitionContextChanged2 = true;
      } else {
        viewTransitionContextChanged2 = prevContextChanged;
      }
      const viewTransitionState = finishedWork.stateNode;
      viewTransitionState.clones = null;
      break;
    }
    default: {
      recursivelyApplyViewTransitions(finishedWork);
      break;
    }
  }
}
function applyDepartureTransitions(root2, finishedWork) {
  viewTransitionContextChanged2 = false;
  pushViewTransitionCancelableScope();
  recursivelyApplyViewTransitions(finishedWork);
  const rootClone = root2.gestureClone;
  if (rootClone !== null) {
    root2.gestureClone = null;
    (void 0)(root2.containerInfo, rootClone);
  }
  if (!viewTransitionContextChanged2) {
    const cancelableChildren = viewTransitionCancelableChildren;
    if (cancelableChildren !== null) {
      for (let i = 0; i < cancelableChildren.length; i += 3) {
        (void 0)(
          cancelableChildren[i],
          cancelableChildren[i + 1],
          cancelableChildren[i + 2]
        );
      }
    }
    (void 0)(root2.containerInfo);
    (void 0)(root2.containerInfo);
  }
  popViewTransitionCancelableScope(null);
}
function recursivelyRestoreViewTransitions(parentFiber) {
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      restoreEnterOrExitViewTransitions(childToDelete);
    }
  }
  if (parentFiber.alternate === null || (parentFiber.subtreeFlags & MutationMask) !== NoFlags) {
    let child = parentFiber.child;
    while (child !== null) {
      restoreViewTransitionsOnFiber(child);
      child = child.sibling;
    }
  } else {
    restoreNestedViewTransitions(parentFiber);
  }
}
function restoreViewTransitionsOnFiber(finishedWork) {
  const current2 = finishedWork.alternate;
  if (current2 === null) {
    restoreEnterOrExitViewTransitions(finishedWork);
    return;
  }
  const flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case HostPortal: {
      break;
    }
    case OffscreenComponent: {
      if (flags & Visibility) {
        const newState = finishedWork.memoizedState;
        const isHidden = newState !== null;
        if (!isHidden) {
          restoreEnterOrExitViewTransitions(finishedWork);
        } else if (current2 !== null && current2.memoizedState === null) {
          restoreEnterOrExitViewTransitions(current2);
        }
      }
      break;
    }
    case ViewTransitionComponent:
      restoreUpdateViewTransitionForGesture(current2, finishedWork);
      recursivelyRestoreViewTransitions(finishedWork);
      break;
    default: {
      recursivelyRestoreViewTransitions(finishedWork);
      break;
    }
  }
}
function startGestureAnimations(root2, finishedWork) {
  restoreViewTransitionsOnFiber(finishedWork);
  (void 0)(root2.containerInfo);
}

// dist/react-reconciler/src/ReactFiberAsyncDispatcher.js
function getCacheForType2(resourceType) {
  const cache3 = readContext(CacheContext);
  let cacheForType = cache3.data.get(resourceType);
  if (cacheForType === void 0) {
    cacheForType = resourceType();
    cache3.data.set(resourceType, cacheForType);
  }
  return cacheForType;
}
var DefaultAsyncDispatcher = {
  getCacheForType: getCacheForType2
};
if (false) {
  DefaultAsyncDispatcher.getOwner = () => {
    return current;
  };
}

// dist/react-reconciler/src/ReactTestSelectors.js
var COMPONENT_TYPE = 0;
var HAS_PSEUDO_CLASS_TYPE = 1;
var ROLE_TYPE = 2;
var TEST_NAME_TYPE = 3;
var TEXT_TYPE = 4;
if (typeof Symbol === "function" && Symbol.for) {
  const symbolFor = Symbol.for;
  COMPONENT_TYPE = symbolFor("selector.component");
  HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
  ROLE_TYPE = symbolFor("selector.role");
  TEST_NAME_TYPE = symbolFor("selector.test_id");
  TEXT_TYPE = symbolFor("selector.text");
}

// dist/react-reconciler/src/ReactPostPaintCallback.js
var postPaintCallbackScheduled = false;
var callbacks = [];
function schedulePostPaintCallback(callback) {
  callbacks.push(callback);
  if (!postPaintCallbackScheduled) {
    postPaintCallbackScheduled = true;
    (void 0)((endTime) => {
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](endTime);
      }
      postPaintCallbackScheduled = false;
      callbacks = [];
    });
  }
}

// dist/react-reconciler/src/ReactFiberWorkLoop.js
var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
var NoContext = (
  /*             */
  0
);
var BatchedContext = (
  /*               */
  1
);
var RenderContext = (
  /*         */
  2
);
var CommitContext = (
  /*         */
  4
);
var RootInProgress = 0;
var RootFatalErrored = 1;
var RootErrored = 2;
var RootSuspended = 3;
var RootSuspendedWithDelay = 4;
var RootSuspendedAtTheShell = 6;
var RootCompleted = 5;
var executionContext = NoContext;
var workInProgressRoot = null;
var workInProgress = null;
var workInProgressRootRenderLanes = NoLanes;
var NotSuspended = 0;
var SuspendedOnError = 1;
var SuspendedOnData = 2;
var SuspendedOnImmediate = 3;
var SuspendedOnInstance = 4;
var SuspendedOnInstanceAndReadyToContinue = 5;
var SuspendedOnDeprecatedThrowPromise = 6;
var SuspendedAndReadyToContinue = 7;
var SuspendedOnHydration = 8;
var SuspendedOnAction = 9;
var workInProgressSuspendedReason = NotSuspended;
var workInProgressThrownValue = null;
var workInProgressRootDidSkipSuspendedSiblings = false;
var workInProgressRootIsPrerendering = false;
var workInProgressRootDidAttachPingListener = false;
var entangledRenderLanes = NoLanes;
var workInProgressRootExitStatus = RootInProgress;
var workInProgressRootSkippedLanes = NoLanes;
var workInProgressRootInterleavedUpdatedLanes = NoLanes;
var workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
var workInProgressRootPingedLanes = NoLanes;
var workInProgressDeferredLane = NoLane;
var workInProgressSuspendedRetryLanes = NoLanes;
var workInProgressRootConcurrentErrors = null;
var workInProgressRootRecoverableErrors = null;
var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
var didIncludeCommitPhaseUpdate = false;
var globalMostRecentFallbackTime = 0;
var FALLBACK_THROTTLE_MS = 300;
var workInProgressRootRenderTargetTime = Infinity;
var RENDER_TIMEOUT_MS = 500;
var workInProgressTransitions = null;
function getWorkInProgressTransitions() {
  return workInProgressTransitions;
}
var currentPendingTransitionCallbacks = null;
var currentEndTime = null;
function addTransitionStartCallbackToPendingTransition(transition) {
  if (enableTransitionTracing) {
    if (currentPendingTransitionCallbacks === null) {
      currentPendingTransitionCallbacks = {
        transitionStart: [],
        transitionProgress: null,
        transitionComplete: null,
        markerProgress: null,
        markerIncomplete: null,
        markerComplete: null
      };
    }
    if (currentPendingTransitionCallbacks.transitionStart === null) {
      currentPendingTransitionCallbacks.transitionStart = [];
    }
    currentPendingTransitionCallbacks.transitionStart.push(transition);
  }
}
function addMarkerProgressCallbackToPendingTransition(markerName, transitions, pendingBoundaries) {
  if (enableTransitionTracing) {
    if (currentPendingTransitionCallbacks === null) {
      currentPendingTransitionCallbacks = {
        transitionStart: null,
        transitionProgress: null,
        transitionComplete: null,
        markerProgress: /* @__PURE__ */ new Map(),
        markerIncomplete: null,
        markerComplete: null
      };
    }
    if (currentPendingTransitionCallbacks.markerProgress === null) {
      currentPendingTransitionCallbacks.markerProgress = /* @__PURE__ */ new Map();
    }
    currentPendingTransitionCallbacks.markerProgress.set(markerName, {
      pendingBoundaries,
      transitions
    });
  }
}
function addMarkerIncompleteCallbackToPendingTransition(markerName, transitions, aborts) {
  if (enableTransitionTracing) {
    if (currentPendingTransitionCallbacks === null) {
      currentPendingTransitionCallbacks = {
        transitionStart: null,
        transitionProgress: null,
        transitionComplete: null,
        markerProgress: null,
        markerIncomplete: /* @__PURE__ */ new Map(),
        markerComplete: null
      };
    }
    if (currentPendingTransitionCallbacks.markerIncomplete === null) {
      currentPendingTransitionCallbacks.markerIncomplete = /* @__PURE__ */ new Map();
    }
    currentPendingTransitionCallbacks.markerIncomplete.set(markerName, {
      transitions,
      aborts
    });
  }
}
function addMarkerCompleteCallbackToPendingTransition(markerName, transitions) {
  if (enableTransitionTracing) {
    if (currentPendingTransitionCallbacks === null) {
      currentPendingTransitionCallbacks = {
        transitionStart: null,
        transitionProgress: null,
        transitionComplete: null,
        markerProgress: null,
        markerIncomplete: null,
        markerComplete: /* @__PURE__ */ new Map()
      };
    }
    if (currentPendingTransitionCallbacks.markerComplete === null) {
      currentPendingTransitionCallbacks.markerComplete = /* @__PURE__ */ new Map();
    }
    currentPendingTransitionCallbacks.markerComplete.set(
      markerName,
      transitions
    );
  }
}
function addTransitionProgressCallbackToPendingTransition(transition, boundaries) {
  if (enableTransitionTracing) {
    if (currentPendingTransitionCallbacks === null) {
      currentPendingTransitionCallbacks = {
        transitionStart: null,
        transitionProgress: /* @__PURE__ */ new Map(),
        transitionComplete: null,
        markerProgress: null,
        markerIncomplete: null,
        markerComplete: null
      };
    }
    if (currentPendingTransitionCallbacks.transitionProgress === null) {
      currentPendingTransitionCallbacks.transitionProgress = /* @__PURE__ */ new Map();
    }
    currentPendingTransitionCallbacks.transitionProgress.set(
      transition,
      boundaries
    );
  }
}
function addTransitionCompleteCallbackToPendingTransition(transition) {
  if (enableTransitionTracing) {
    if (currentPendingTransitionCallbacks === null) {
      currentPendingTransitionCallbacks = {
        transitionStart: null,
        transitionProgress: null,
        transitionComplete: [],
        markerProgress: null,
        markerIncomplete: null,
        markerComplete: null
      };
    }
    if (currentPendingTransitionCallbacks.transitionComplete === null) {
      currentPendingTransitionCallbacks.transitionComplete = [];
    }
    currentPendingTransitionCallbacks.transitionComplete.push(transition);
  }
}
function resetRenderTimer() {
  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
}
function getRenderTargetTime() {
  return workInProgressRootRenderTargetTime;
}
var legacyErrorBoundariesThatAlreadyFailed = null;
var IMMEDIATE_COMMIT = 0;
var SUSPENDED_COMMIT = 1;
var THROTTLED_COMMIT = 2;
var NO_PENDING_EFFECTS = 0;
var PENDING_MUTATION_PHASE = 1;
var PENDING_LAYOUT_PHASE = 2;
var PENDING_AFTER_MUTATION_PHASE = 3;
var PENDING_SPAWNED_WORK = 4;
var PENDING_PASSIVE_PHASE = 5;
var PENDING_GESTURE_MUTATION_PHASE = 6;
var PENDING_GESTURE_ANIMATION_PHASE = 7;
var pendingEffectsStatus = 0;
var pendingEffectsRoot = null;
var pendingFinishedWork = null;
var pendingEffectsLanes = NoLanes;
var pendingEffectsRemainingLanes = NoLanes;
var pendingEffectsRenderEndTime = -0;
var pendingPassiveTransitions = null;
var pendingRecoverableErrors = null;
var pendingViewTransition = null;
var pendingViewTransitionEvents = null;
var pendingTransitionTypes = null;
var pendingDidIncludeRenderPhaseUpdate = false;
var pendingSuspendedCommitReason = IMMEDIATE_COMMIT;
var NESTED_UPDATE_LIMIT = 50;
var nestedUpdateCount = 0;
var rootWithNestedUpdates = null;
var nestedPassiveUpdateCount = 0;
var rootWithPassiveNestedUpdates = null;
function getWorkInProgressRoot() {
  return workInProgressRoot;
}
function getCommittingRoot() {
  return pendingEffectsRoot;
}
function getWorkInProgressRootRenderLanes() {
  return workInProgressRootRenderLanes;
}
function hasPendingCommitEffects() {
  return pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE;
}
function getRootWithPendingPassiveEffects() {
  return pendingEffectsStatus === PENDING_PASSIVE_PHASE ? pendingEffectsRoot : null;
}
function getPendingPassiveEffectsLanes() {
  return pendingEffectsLanes;
}
function getPendingTransitionTypes() {
  return pendingTransitionTypes;
}
function isWorkLoopSuspendedOnData() {
  return workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction;
}
function requestUpdateLane(fiber) {
  const mode = fiber.mode;
  if (!disableLegacyMode && (mode & ConcurrentMode) === NoMode) {
    return SyncLane;
  } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
    return pickArbitraryLane(workInProgressRootRenderLanes);
  }
  const transition = requestCurrentTransition();
  if (transition !== null) {
    if (enableGestureTransition) {
      if (transition.gesture) {
        throw new Error(
          "Cannot setState on regular state inside a startGestureTransition. Gestures can only update the useOptimistic() hook. There should be no side-effects associated with starting a Gesture until its Action is invoked. Move side-effects to the Action instead."
        );
      }
    }
    if (false) {
      if (!transition._updatedFibers) {
        transition._updatedFibers = /* @__PURE__ */ new Set();
      }
      transition._updatedFibers.add(fiber);
    }
    return requestTransitionLane(transition);
  }
  return eventPriorityToLane((void 0)());
}
function requestRetryLane(fiber) {
  const mode = fiber.mode;
  if (!disableLegacyMode && (mode & ConcurrentMode) === NoMode) {
    return SyncLane;
  }
  return claimNextRetryLane();
}
function requestDeferredLane() {
  if (workInProgressDeferredLane === NoLane) {
    const isPrerendering = includesSomeLane(workInProgressRootRenderLanes, OffscreenLane) && !getIsHydrating();
    if (isPrerendering) {
      workInProgressDeferredLane = OffscreenLane;
    } else {
      workInProgressDeferredLane = claimNextTransitionLane();
    }
  }
  const suspenseHandler = getSuspenseHandler();
  if (suspenseHandler !== null) {
    suspenseHandler.flags |= DidDefer;
  }
  return workInProgressDeferredLane;
}
function scheduleViewTransitionEvent(fiber, callback) {
  if (enableViewTransition) {
    if (callback != null) {
      const state = fiber.stateNode;
      let instance = state.ref;
      if (instance === null) {
        instance = state.ref = (void 0)(
          getViewTransitionName(fiber.memoizedProps, state)
        );
      }
      if (pendingViewTransitionEvents === null) {
        pendingViewTransitionEvents = [];
      }
      pendingViewTransitionEvents.push(callback.bind(null, instance));
    }
  }
}
function peekDeferredLane() {
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root2, fiber, lane) {
  if (false) {
    if (isRunningInsertionEffect) {
      console.error("useInsertionEffect must not schedule updates.");
    }
  }
  if (false) {
    if (isFlushingPassiveEffects) {
      didScheduleUpdateDuringPassiveEffects = true;
    }
  }
  if (
    // Suspended render phase
    root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || // Suspended commit phase
    root2.cancelPendingCommit !== null
  ) {
    prepareFreshStack(root2, NoLanes);
    const didAttemptEntireTree = false;
    markRootSuspended2(
      root2,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      didAttemptEntireTree
    );
  }
  markRootUpdated2(root2, lane);
  if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
    warnAboutRenderPhaseUpdatesInDEV(fiber);
    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(
      workInProgressRootRenderPhaseUpdatedLanes,
      lane
    );
  } else {
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        addFiberToLanesMap(root2, fiber, lane);
      }
    }
    warnIfUpdatesNotWrappedWithActDEV(fiber);
    if (enableTransitionTracing) {
      const transition = ReactSharedInternals_default.T;
      if (transition !== null && transition.name != null) {
        if (transition.startTime === -1) {
          transition.startTime = now();
        }
        addTransitionToLanesMap(root2, transition, lane);
      }
    }
    if (root2 === workInProgressRoot) {
      if ((executionContext & RenderContext) === NoContext) {
        workInProgressRootInterleavedUpdatedLanes = mergeLanes(
          workInProgressRootInterleavedUpdatedLanes,
          lane
        );
      }
      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
        const didAttemptEntireTree = false;
        markRootSuspended2(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          didAttemptEntireTree
        );
      }
    }
    ensureRootIsScheduled(root2);
    if (lane === SyncLane && executionContext === NoContext && !disableLegacyMode && (fiber.mode & ConcurrentMode) === NoMode) {
      if (false) {
      } else {
        resetRenderTimer();
        flushSyncWorkOnLegacyRootsOnly();
      }
    }
  }
}
function isUnsafeClassRenderPhaseUpdate(fiber) {
  return (executionContext & RenderContext) !== NoContext;
}
function performWorkOnRoot(root2, lanes, forceSync) {
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    throw new Error("Should not already be working.");
  }
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    if (workInProgressRootRenderLanes !== NoLanes && workInProgress !== null) {
      const yieldedFiber = workInProgress;
      const yieldEndTime = now();
      switch (yieldReason) {
        case SuspendedOnImmediate:
        case SuspendedOnData:
          logSuspendedYieldTime(yieldStartTime, yieldEndTime, yieldedFiber);
          break;
        case SuspendedOnAction:
          logActionYieldTime(yieldStartTime, yieldEndTime, yieldedFiber);
          break;
        default:
          logYieldTime(yieldStartTime, yieldEndTime);
      }
    }
  }
  const shouldTimeSlice = !forceSync && !includesBlockingLane(lanes) && !includesExpiredLane(root2, lanes) || // If we're prerendering, then we should use the concurrent work loop
  // even if the lanes are synchronous, so that prerendering never blocks
  // the main thread.
  // TODO: We should consider doing this whenever a sync lane is suspended,
  // even for regular pings.
  checkIfRootIsPrerendering(root2, lanes);
  let exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true);
  let renderWasConcurrent = shouldTimeSlice;
  do {
    if (exitStatus === RootInProgress) {
      if (workInProgressRootIsPrerendering && !shouldTimeSlice) {
        const didAttemptEntireTree = false;
        markRootSuspended2(root2, lanes, NoLane, didAttemptEntireTree);
      }
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        startYieldTimer(workInProgressSuspendedReason);
      }
      break;
    } else {
      let renderEndTime = 0;
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        renderEndTime = now();
      }
      const finishedWork = root2.current.alternate;
      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
        if (enableProfilerTimer && enableComponentPerformanceTrack) {
          setCurrentTrackFromLanes(lanes);
          logInconsistentRender(renderStartTime, renderEndTime);
          finalizeRender(lanes, renderEndTime);
        }
        exitStatus = renderRootSync(root2, lanes, false);
        renderWasConcurrent = false;
        continue;
      }
      if ((disableLegacyMode || root2.tag !== LegacyRoot) && exitStatus === RootErrored) {
        const lanesThatJustErrored = lanes;
        const errorRetryLanes = getLanesToRetrySynchronouslyOnError(
          root2,
          lanesThatJustErrored
        );
        if (errorRetryLanes !== NoLanes) {
          if (enableProfilerTimer && enableComponentPerformanceTrack) {
            setCurrentTrackFromLanes(lanes);
            logErroredRenderPhase(renderStartTime, renderEndTime, lanes);
            finalizeRender(lanes, renderEndTime);
          }
          lanes = errorRetryLanes;
          exitStatus = recoverFromConcurrentError(
            root2,
            lanesThatJustErrored,
            errorRetryLanes
          );
          renderWasConcurrent = false;
          if (exitStatus !== RootErrored) {
            continue;
          } else {
            if (enableProfilerTimer && enableComponentPerformanceTrack) {
              renderEndTime = now();
            }
          }
        }
      }
      if (exitStatus === RootFatalErrored) {
        if (enableProfilerTimer && enableComponentPerformanceTrack) {
          setCurrentTrackFromLanes(lanes);
          logErroredRenderPhase(renderStartTime, renderEndTime, lanes);
          finalizeRender(lanes, renderEndTime);
        }
        prepareFreshStack(root2, NoLanes);
        const didAttemptEntireTree = true;
        markRootSuspended2(root2, lanes, NoLane, didAttemptEntireTree);
        break;
      }
      finishConcurrentRender(
        root2,
        exitStatus,
        finishedWork,
        lanes,
        renderEndTime
      );
    }
    break;
  } while (true);
  ensureRootIsScheduled(root2);
}
function recoverFromConcurrentError(root2, originallyAttemptedLanes, errorRetryLanes) {
  const errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
  const wasRootDehydrated = void 0 && isRootDehydrated(root2);
  if (wasRootDehydrated) {
    const rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
    rootWorkInProgress.flags |= ForceClientRender;
  }
  const exitStatus = renderRootSync(root2, errorRetryLanes, false);
  if (exitStatus !== RootErrored) {
    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
      root2.errorRecoveryDisabledLanes = mergeLanes(
        root2.errorRecoveryDisabledLanes,
        originallyAttemptedLanes
      );
      workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes;
      return RootSuspendedWithDelay;
    }
    const errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
    if (errorsFromSecondAttempt !== null) {
      queueRecoverableErrors(errorsFromSecondAttempt);
    }
  } else {
  }
  return exitStatus;
}
function queueRecoverableErrors(errors) {
  if (workInProgressRootRecoverableErrors === null) {
    workInProgressRootRecoverableErrors = errors;
  } else {
    workInProgressRootRecoverableErrors.push.apply(
      workInProgressRootRecoverableErrors,
      errors
    );
  }
}
function finishConcurrentRender(root2, exitStatus, finishedWork, lanes, renderEndTime) {
  switch (exitStatus) {
    case RootInProgress:
    case RootFatalErrored: {
      throw new Error("Root did not complete. This is a bug in React.");
    }
    case RootSuspendedWithDelay: {
      if (!includesOnlyTransitions(lanes)) {
        break;
      }
    }
    // Fallthrough
    case RootSuspendedAtTheShell: {
      if (enableProfilerTimer && enableComponentPerformanceTrack) {
        setCurrentTrackFromLanes(lanes);
        logSuspendedRenderPhase(renderStartTime, renderEndTime, lanes);
        finalizeRender(lanes, renderEndTime);
        trackSuspendedTime(lanes, renderEndTime);
      }
      const didAttemptEntireTree = !workInProgressRootDidSkipSuspendedSiblings;
      markRootSuspended2(
        root2,
        lanes,
        workInProgressDeferredLane,
        didAttemptEntireTree
      );
      return;
    }
    case RootErrored: {
      workInProgressRootRecoverableErrors = null;
      break;
    }
    case RootSuspended:
    case RootCompleted: {
      break;
    }
    default: {
      throw new Error("Unknown root exit status.");
    }
  }
  if (shouldForceFlushFallbacksInDEV()) {
    commitRoot(
      root2,
      finishedWork,
      lanes,
      workInProgressRootRecoverableErrors,
      workInProgressTransitions,
      workInProgressRootDidIncludeRecursiveRenderUpdate,
      workInProgressDeferredLane,
      workInProgressRootInterleavedUpdatedLanes,
      workInProgressSuspendedRetryLanes,
      exitStatus,
      IMMEDIATE_COMMIT,
      renderStartTime,
      renderEndTime
    );
  } else {
    if (includesOnlyRetries(lanes) && (alwaysThrottleRetries || exitStatus === RootSuspended)) {
      const msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
      if (msUntilTimeout > 10) {
        const didAttemptEntireTree = !workInProgressRootDidSkipSuspendedSiblings;
        markRootSuspended2(
          root2,
          lanes,
          workInProgressDeferredLane,
          didAttemptEntireTree
        );
        const nextLanes = getNextLanes(root2, NoLanes, true);
        if (nextLanes !== NoLanes) {
          return;
        }
        root2.timeoutHandle = (void 0)(
          commitRootWhenReady.bind(
            null,
            root2,
            finishedWork,
            workInProgressRootRecoverableErrors,
            workInProgressTransitions,
            workInProgressRootDidIncludeRecursiveRenderUpdate,
            lanes,
            workInProgressDeferredLane,
            workInProgressRootInterleavedUpdatedLanes,
            workInProgressSuspendedRetryLanes,
            workInProgressRootDidSkipSuspendedSiblings,
            exitStatus,
            THROTTLED_COMMIT,
            renderStartTime,
            renderEndTime
          ),
          msUntilTimeout
        );
        return;
      }
    }
    commitRootWhenReady(
      root2,
      finishedWork,
      workInProgressRootRecoverableErrors,
      workInProgressTransitions,
      workInProgressRootDidIncludeRecursiveRenderUpdate,
      lanes,
      workInProgressDeferredLane,
      workInProgressRootInterleavedUpdatedLanes,
      workInProgressSuspendedRetryLanes,
      workInProgressRootDidSkipSuspendedSiblings,
      exitStatus,
      IMMEDIATE_COMMIT,
      renderStartTime,
      renderEndTime
    );
  }
}
function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
  root2.timeoutHandle = void 0;
  const BothVisibilityAndMaySuspendCommit = Visibility | MaySuspendCommit;
  const subtreeFlags = finishedWork.subtreeFlags;
  const isViewTransitionEligible = enableViewTransition && includesOnlyViewTransitionEligibleLanes(lanes);
  const isGestureTransition = enableGestureTransition && isGestureRender(lanes);
  const maySuspendCommit2 = subtreeFlags & ShouldSuspendCommit || (subtreeFlags & BothVisibilityAndMaySuspendCommit) === BothVisibilityAndMaySuspendCommit;
  if (isViewTransitionEligible || maySuspendCommit2 || isGestureTransition) {
    (void 0)();
    accumulateSuspenseyCommit(finishedWork, lanes);
    if (isViewTransitionEligible || isGestureTransition) {
      if (!enableGestureTransition || root2.stoppingGestures === null) {
        (void 0)(root2.containerInfo);
      }
    }
    const schedulePendingCommit = (void 0)();
    if (schedulePendingCommit !== null) {
      root2.cancelPendingCommit = schedulePendingCommit(
        commitRoot.bind(
          null,
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          exitStatus,
          SUSPENDED_COMMIT,
          completedRenderStartTime,
          completedRenderEndTime
        )
      );
      const didAttemptEntireTree = !didSkipSuspendedSiblings;
      markRootSuspended2(root2, lanes, spawnedLane, didAttemptEntireTree);
      return;
    }
  }
  commitRoot(
    root2,
    finishedWork,
    lanes,
    recoverableErrors,
    transitions,
    didIncludeRenderPhaseUpdate,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes,
    exitStatus,
    suspendedCommitReason,
    completedRenderStartTime,
    completedRenderEndTime
  );
}
function isRenderConsistentWithExternalStores(finishedWork) {
  let node = finishedWork;
  while (true) {
    const tag = node.tag;
    if ((tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent) && node.flags & StoreConsistency) {
      const updateQueue = node.updateQueue;
      if (updateQueue !== null) {
        const checks = updateQueue.stores;
        if (checks !== null) {
          for (let i = 0; i < checks.length; i++) {
            const check = checks[i];
            const getSnapshot = check.getSnapshot;
            const renderedValue = check.value;
            try {
              if (!objectIs_default(getSnapshot(), renderedValue)) {
                return false;
              }
            } catch (error) {
              return false;
            }
          }
        }
      }
    }
    const child = node.child;
    if (node.subtreeFlags & StoreConsistency && child !== null) {
      child.return = node;
      node = child;
      continue;
    }
    if (node === finishedWork) {
      return true;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === finishedWork) {
        return true;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return true;
}
function markRootUpdated2(root2, updatedLanes) {
  markRootUpdated(root2, updatedLanes);
  if (enableInfiniteRenderLoopDetection) {
    if (executionContext & RenderContext) {
      workInProgressRootDidIncludeRecursiveRenderUpdate = true;
    } else if (executionContext & CommitContext) {
      didIncludeCommitPhaseUpdate = true;
    }
    throwIfInfiniteUpdateLoopDetected();
  }
}
function markRootPinged2(root2, pingedLanes) {
  markRootPinged(root2, pingedLanes);
  if (enableInfiniteRenderLoopDetection) {
    if (executionContext & RenderContext) {
      workInProgressRootDidIncludeRecursiveRenderUpdate = true;
    } else if (executionContext & CommitContext) {
      didIncludeCommitPhaseUpdate = true;
    }
    throwIfInfiniteUpdateLoopDetected();
  }
}
function markRootSuspended2(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
  suspendedLanes = removeLanes(
    suspendedLanes,
    workInProgressRootInterleavedUpdatedLanes
  );
  markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree);
}
function flushRoot(root2, lanes) {
  if (lanes !== NoLanes) {
    upgradePendingLanesToSync(root2, lanes);
    ensureRootIsScheduled(root2);
    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
      resetRenderTimer();
      flushSyncWorkOnAllRoots();
    }
  }
}
function getExecutionContext() {
  return executionContext;
}
function batchedUpdates(fn, a) {
  if (disableLegacyMode) {
    return fn(a);
  } else {
    const prevExecutionContext = executionContext;
    executionContext |= BatchedContext;
    try {
      return fn(a);
    } finally {
      executionContext = prevExecutionContext;
      if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      true) {
        resetRenderTimer();
        flushSyncWorkOnLegacyRootsOnly();
      }
    }
  }
}
function flushSyncWork() {
  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
    flushSyncWorkOnAllRoots();
    return false;
  }
  return true;
}
function isAlreadyRendering() {
  return (executionContext & (RenderContext | CommitContext)) !== NoContext;
}
function isInvalidExecutionContextForEventFunction() {
  return (executionContext & RenderContext) !== NoContext;
}
function setEntangledRenderLanes(newEntangledRenderLanes) {
  entangledRenderLanes = newEntangledRenderLanes;
}
function getEntangledRenderLanes() {
  return entangledRenderLanes;
}
function resetWorkInProgressStack() {
  if (workInProgress === null) return;
  let interruptedWork;
  if (workInProgressSuspendedReason === NotSuspended) {
    interruptedWork = workInProgress.return;
  } else {
    resetSuspendedWorkLoopOnUnwind(workInProgress);
    interruptedWork = workInProgress;
  }
  while (interruptedWork !== null) {
    const current2 = interruptedWork.alternate;
    unwindInterruptedWork(
      current2,
      interruptedWork,
      workInProgressRootRenderLanes
    );
    interruptedWork = interruptedWork.return;
  }
  workInProgress = null;
}
function finalizeRender(lanes, finalizationTime) {
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    if (includesSyncLane(lanes) || includesBlockingLane(lanes)) {
      clampBlockingTimers(finalizationTime);
    }
    if (includesTransitionLane(lanes)) {
      clampTransitionTimers(finalizationTime);
    }
  }
}
function prepareFreshStack(root2, lanes) {
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    markAllLanesInOrder();
    const previousRenderStartTime = renderStartTime;
    recordRenderTime();
    if (workInProgressRootRenderLanes !== NoLanes && previousRenderStartTime > 0) {
      setCurrentTrackFromLanes(workInProgressRootRenderLanes);
      if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay) {
        logSuspendedRenderPhase(
          previousRenderStartTime,
          renderStartTime,
          lanes
        );
      } else {
        logInterruptedRenderPhase(
          previousRenderStartTime,
          renderStartTime,
          lanes
        );
      }
      finalizeRender(workInProgressRootRenderLanes, renderStartTime);
    }
    if (includesSyncLane(lanes) || includesBlockingLane(lanes)) {
      const clampedUpdateTime = blockingUpdateTime >= 0 && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
      const clampedEventTime = blockingEventTime >= 0 && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
      if (blockingSuspendedTime >= 0) {
        setCurrentTrackFromLanes(lanes);
        logSuspendedWithDelayPhase(
          blockingSuspendedTime,
          // Clamp the suspended time to the first event/update.
          clampedEventTime >= 0 ? clampedEventTime : clampedUpdateTime >= 0 ? clampedUpdateTime : renderStartTime,
          lanes
        );
      }
      logBlockingStart(
        clampedUpdateTime,
        clampedEventTime,
        blockingEventType,
        blockingEventIsRepeat,
        blockingSpawnedUpdate,
        renderStartTime,
        lanes,
        blockingUpdateTask
      );
      clearBlockingTimers();
    }
    if (includesTransitionLane(lanes)) {
      const clampedStartTime = transitionStartTime >= 0 && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime;
      const clampedUpdateTime = transitionUpdateTime >= 0 && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime;
      const clampedEventTime = transitionEventTime >= 0 && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime;
      if (transitionSuspendedTime >= 0) {
        setCurrentTrackFromLanes(lanes);
        logSuspendedWithDelayPhase(
          transitionSuspendedTime,
          // Clamp the suspended time to the first event/update.
          clampedEventTime >= 0 ? clampedEventTime : clampedUpdateTime >= 0 ? clampedUpdateTime : renderStartTime,
          lanes
        );
      }
      logTransitionStart(
        clampedStartTime,
        clampedUpdateTime,
        clampedEventTime,
        transitionEventType,
        transitionEventIsRepeat,
        renderStartTime,
        transitionUpdateTask
      );
      clearTransitionTimers();
    }
  }
  const timeoutHandle = root2.timeoutHandle;
  if (timeoutHandle !== void 0) {
    root2.timeoutHandle = void 0;
    (void 0)(timeoutHandle);
  }
  const cancelPendingCommit = root2.cancelPendingCommit;
  if (cancelPendingCommit !== null) {
    root2.cancelPendingCommit = null;
    cancelPendingCommit();
  }
  resetWorkInProgressStack();
  workInProgressRoot = root2;
  const rootWorkInProgress = createWorkInProgress(root2.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = NotSuspended;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = false;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
  workInProgressRootDidAttachPingListener = false;
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressDeferredLane = NoLane;
  workInProgressSuspendedRetryLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = false;
  entangledRenderLanes = getEntangledLanes(root2, lanes);
  finishQueueingConcurrentUpdates();
  if (false) {
    resetOwnerStackLimit();
    ReactStrictModeWarnings_default.discardPendingWarnings();
  }
  return rootWorkInProgress;
}
function resetSuspendedWorkLoopOnUnwind(fiber) {
  resetContextDependencies();
  resetHooksOnUnwind(fiber);
  resetChildReconcilerOnUnwind();
}
function handleThrow(root2, thrownValue) {
  resetHooksAfterThrow();
  if (false) {
    resetCurrentFiber();
  }
  if (thrownValue === SuspenseException || thrownValue === SuspenseActionException) {
    thrownValue = getSuspendedThenable();
    workInProgressSuspendedReason = SuspendedOnImmediate;
  } else if (thrownValue === SuspenseyCommitException) {
    thrownValue = getSuspendedThenable();
    workInProgressSuspendedReason = SuspendedOnInstance;
  } else if (thrownValue === SelectiveHydrationException) {
    workInProgressSuspendedReason = SuspendedOnHydration;
  } else {
    const isWakeable = thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function";
    workInProgressSuspendedReason = isWakeable ? (
      // A wakeable object was thrown by a legacy Suspense implementation.
      // This has slightly different behavior than suspending with `use`.
      SuspendedOnDeprecatedThrowPromise
    ) : (
      // This is a regular error. If something earlier in the component already
      // suspended, we must clear the thenable state to unblock the work loop.
      SuspendedOnError
    );
  }
  workInProgressThrownValue = thrownValue;
  const erroredWork = workInProgress;
  if (erroredWork === null) {
    workInProgressRootExitStatus = RootFatalErrored;
    logUncaughtError(
      root2,
      createCapturedValueAtFiber(thrownValue, root2.current)
    );
    return;
  }
  if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
    stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
  }
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
    switch (workInProgressSuspendedReason) {
      case SuspendedOnError: {
        markComponentErrored(
          erroredWork,
          thrownValue,
          workInProgressRootRenderLanes
        );
        break;
      }
      case SuspendedOnData:
      case SuspendedOnAction:
      case SuspendedOnImmediate:
      case SuspendedOnDeprecatedThrowPromise:
      case SuspendedAndReadyToContinue: {
        const wakeable = thrownValue;
        markComponentSuspended(
          erroredWork,
          wakeable,
          workInProgressRootRenderLanes
        );
        break;
      }
      case SuspendedOnInstance: {
        break;
      }
      case SuspendedOnHydration: {
        break;
      }
    }
  }
}
function shouldRemainOnPreviousScreen() {
  const handler = getSuspenseHandler();
  if (handler === null) {
    return true;
  }
  if (includesOnlyTransitions(workInProgressRootRenderLanes)) {
    if (getShellBoundary() === null) {
      return true;
    } else {
      return false;
    }
  }
  if (includesOnlyRetries(workInProgressRootRenderLanes) || // In this context, an OffscreenLane counts as a Retry
  // TODO: It's become increasingly clear that Retries and Offscreen are
  // deeply connected. They probably can be unified further.
  includesSomeLane(workInProgressRootRenderLanes, OffscreenLane)) {
    return handler === getShellBoundary();
  }
  return false;
}
function pushDispatcher(container) {
  const prevDispatcher = ReactSharedInternals_default.H;
  ReactSharedInternals_default.H = ContextOnlyDispatcher;
  if (prevDispatcher === null) {
    return ContextOnlyDispatcher;
  } else {
    return prevDispatcher;
  }
}
function popDispatcher(prevDispatcher) {
  ReactSharedInternals_default.H = prevDispatcher;
}
function pushAsyncDispatcher() {
  const prevAsyncDispatcher = ReactSharedInternals_default.A;
  ReactSharedInternals_default.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function popAsyncDispatcher(prevAsyncDispatcher) {
  ReactSharedInternals_default.A = prevAsyncDispatcher;
}
function markCommitTimeOfFallback() {
  globalMostRecentFallbackTime = now();
}
function markSkippedUpdateLanes(lane) {
  workInProgressRootSkippedLanes = mergeLanes(
    lane,
    workInProgressRootSkippedLanes
  );
}
function renderDidSuspend() {
  if (workInProgressRootExitStatus === RootInProgress) {
    workInProgressRootExitStatus = RootSuspended;
  }
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = RootSuspendedWithDelay;
  if (!workInProgressRootDidSkipSuspendedSiblings && // Check if the root will be blocked from committing.
  // TODO: Consider aligning this better with the rest of the logic. Maybe
  // we should only set the exit status to RootSuspendedWithDelay if this
  // condition is true? And remove the equivalent checks elsewhere.
  (includesOnlyTransitions(workInProgressRootRenderLanes) || getSuspenseHandler() === null)) {
    workInProgressRootIsPrerendering = true;
  }
  if ((includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)) && workInProgressRoot !== null) {
    const didAttemptEntireTree = false;
    markRootSuspended2(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      didAttemptEntireTree
    );
  }
}
function renderDidError() {
  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
    workInProgressRootExitStatus = RootErrored;
  }
}
function queueConcurrentError(error) {
  if (workInProgressRootConcurrentErrors === null) {
    workInProgressRootConcurrentErrors = [error];
  } else {
    workInProgressRootConcurrentErrors.push(error);
  }
}
function renderHasNotSuspendedYet() {
  return workInProgressRootExitStatus === RootInProgress;
}
function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher(root2.containerInfo);
  const prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        const memoizedUpdaters = root2.memoizedUpdaters;
        if (memoizedUpdaters.size > 0) {
          restorePendingUpdaters(root2, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }
        movePendingFibersToMemoized(root2, lanes);
      }
    }
    workInProgressTransitions = getTransitionsForLanes(root2, lanes);
    prepareFreshStack(root2, lanes);
  }
  if (enableSchedulingProfiler) {
    markRenderStarted(lanes);
  }
  let didSuspendInShell = false;
  let exitStatus = workInProgressRootExitStatus;
  outer: do {
    try {
      if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {
        const unitOfWork = workInProgress;
        const thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case SuspendedOnHydration: {
            resetWorkInProgressStack();
            exitStatus = RootSuspendedAtTheShell;
            break outer;
          }
          case SuspendedOnImmediate:
          case SuspendedOnData:
          case SuspendedOnAction:
          case SuspendedOnDeprecatedThrowPromise: {
            if (getSuspenseHandler() === null) {
              didSuspendInShell = true;
            }
            const reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
            if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
              exitStatus = RootInProgress;
              break outer;
            }
            break;
          }
          default: {
            const reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
            break;
          }
        }
      }
      workLoopSync();
      exitStatus = workInProgressRootExitStatus;
      break;
    } catch (thrownValue) {
      handleThrow(root2, thrownValue);
    }
  } while (true);
  if (didSuspendInShell) {
    root2.shellSuspendCounter++;
  }
  resetContextDependencies();
  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);
  popAsyncDispatcher(prevAsyncDispatcher);
  if (enableSchedulingProfiler) {
    markRenderStopped();
  }
  if (workInProgress !== null) {
  } else {
    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes;
    finishQueueingConcurrentUpdates();
  }
  return exitStatus;
}
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function renderRootConcurrent(root2, lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher(root2.containerInfo);
  const prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        const memoizedUpdaters = root2.memoizedUpdaters;
        if (memoizedUpdaters.size > 0) {
          restorePendingUpdaters(root2, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }
        movePendingFibersToMemoized(root2, lanes);
      }
    }
    workInProgressTransitions = getTransitionsForLanes(root2, lanes);
    resetRenderTimer();
    prepareFreshStack(root2, lanes);
  } else {
    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
  }
  if (enableSchedulingProfiler) {
    markRenderStarted(lanes);
  }
  outer: do {
    try {
      if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {
        const unitOfWork = workInProgress;
        const thrownValue = workInProgressThrownValue;
        resumeOrUnwind: switch (workInProgressSuspendedReason) {
          case SuspendedOnError: {
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(
              root2,
              unitOfWork,
              thrownValue,
              SuspendedOnError
            );
            break;
          }
          case SuspendedOnData:
          case SuspendedOnAction: {
            const thenable = thrownValue;
            if (isThenableResolved(thenable)) {
              workInProgressSuspendedReason = NotSuspended;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(unitOfWork);
              break;
            }
            const onResolution = () => {
              if ((workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) && workInProgressRoot === root2) {
                workInProgressSuspendedReason = SuspendedAndReadyToContinue;
              }
              ensureRootIsScheduled(root2);
            };
            thenable.then(onResolution, onResolution);
            break outer;
          }
          case SuspendedOnImmediate: {
            workInProgressSuspendedReason = SuspendedAndReadyToContinue;
            break outer;
          }
          case SuspendedOnInstance: {
            workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
            break outer;
          }
          case SuspendedAndReadyToContinue: {
            const thenable = thrownValue;
            if (isThenableResolved(thenable)) {
              workInProgressSuspendedReason = NotSuspended;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(unitOfWork);
            } else {
              workInProgressSuspendedReason = NotSuspended;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(
                root2,
                unitOfWork,
                thrownValue,
                SuspendedAndReadyToContinue
              );
            }
            break;
          }
          case SuspendedOnInstanceAndReadyToContinue: {
            let resource = null;
            switch (workInProgress.tag) {
              case HostHoistable: {
                resource = workInProgress.memoizedState;
              }
              // intentional fallthrough
              case HostComponent:
              case HostSingleton: {
                const hostFiber = workInProgress;
                const type = hostFiber.type;
                const props = hostFiber.pendingProps;
                const isReady = resource ? (void 0)(resource) : (void 0)(hostFiber.stateNode, type, props);
                if (isReady) {
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  const sibling = hostFiber.sibling;
                  if (sibling !== null) {
                    workInProgress = sibling;
                  } else {
                    const returnFiber = hostFiber.return;
                    if (returnFiber !== null) {
                      workInProgress = returnFiber;
                      completeUnitOfWork(returnFiber);
                    } else {
                      workInProgress = null;
                    }
                  }
                  break resumeOrUnwind;
                }
                break;
              }
              default: {
                if (false) {
                  console.error(
                    "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                  );
                }
                break;
              }
            }
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(
              root2,
              unitOfWork,
              thrownValue,
              SuspendedOnInstanceAndReadyToContinue
            );
            break;
          }
          case SuspendedOnDeprecatedThrowPromise: {
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(
              root2,
              unitOfWork,
              thrownValue,
              SuspendedOnDeprecatedThrowPromise
            );
            break;
          }
          case SuspendedOnHydration: {
            resetWorkInProgressStack();
            workInProgressRootExitStatus = RootSuspendedAtTheShell;
            break outer;
          }
          default: {
            throw new Error(
              "Unexpected SuspendedReason. This is a bug in React."
            );
          }
        }
      }
      if (false) {
        workLoopSync();
      } else if (enableThrottledScheduling) {
        workLoopConcurrent(includesNonIdleWork(lanes));
      } else {
        workLoopConcurrentByScheduler();
      }
      break;
    } catch (thrownValue) {
      handleThrow(root2, thrownValue);
    }
  } while (true);
  resetContextDependencies();
  popDispatcher(prevDispatcher);
  popAsyncDispatcher(prevAsyncDispatcher);
  executionContext = prevExecutionContext;
  if (workInProgress !== null) {
    if (enableSchedulingProfiler) {
      markRenderYielded();
    }
    return RootInProgress;
  } else {
    if (enableSchedulingProfiler) {
      markRenderStopped();
    }
    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes;
    finishQueueingConcurrentUpdates();
    return workInProgressRootExitStatus;
  }
}
function workLoopConcurrent(nonIdle) {
  if (workInProgress !== null) {
    const yieldAfter = now() + (nonIdle ? 25 : 5);
    do {
      performUnitOfWork(workInProgress);
    } while (workInProgress !== null && now() < yieldAfter);
  }
}
function workLoopConcurrentByScheduler() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(unitOfWork) {
  const current2 = unitOfWork.alternate;
  let next;
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    if (false) {
      next = runWithFiberInDEV(
        unitOfWork,
        beginWork,
        current2,
        unitOfWork,
        entangledRenderLanes
      );
    } else {
      next = beginWork(current2, unitOfWork, entangledRenderLanes);
    }
    stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
  } else {
    if (false) {
      next = runWithFiberInDEV(
        unitOfWork,
        beginWork,
        current2,
        unitOfWork,
        entangledRenderLanes
      );
    } else {
      next = beginWork(current2, unitOfWork, entangledRenderLanes);
    }
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
function replaySuspendedUnitOfWork(unitOfWork) {
  let next;
  if (false) {
    next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
  } else {
    next = replayBeginWork(unitOfWork);
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
function replayBeginWork(unitOfWork) {
  const current2 = unitOfWork.alternate;
  let next;
  const isProfilingMode = enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode;
  if (isProfilingMode) {
    startProfilerTimer(unitOfWork);
  }
  switch (unitOfWork.tag) {
    case SimpleMemoComponent:
    case FunctionComponent: {
      const Component2 = unitOfWork.type;
      const unresolvedProps = unitOfWork.pendingProps;
      const resolvedProps = disableDefaultPropsExceptForClasses || unitOfWork.elementType === Component2 ? unresolvedProps : resolveDefaultPropsOnNonClassComponent(Component2, unresolvedProps);
      let context;
      if (!disableLegacyContext) {
        const unmaskedContext = getUnmaskedContext(unitOfWork, Component2, true);
        context = getMaskedContext(unitOfWork, unmaskedContext);
      }
      next = replayFunctionComponent(
        current2,
        unitOfWork,
        resolvedProps,
        Component2,
        context,
        workInProgressRootRenderLanes
      );
      break;
    }
    case ForwardRef: {
      const Component2 = unitOfWork.type.render;
      const unresolvedProps = unitOfWork.pendingProps;
      const resolvedProps = disableDefaultPropsExceptForClasses || unitOfWork.elementType === Component2 ? unresolvedProps : resolveDefaultPropsOnNonClassComponent(Component2, unresolvedProps);
      next = replayFunctionComponent(
        current2,
        unitOfWork,
        resolvedProps,
        Component2,
        unitOfWork.ref,
        workInProgressRootRenderLanes
      );
      break;
    }
    case HostComponent: {
      resetHooksOnUnwind(unitOfWork);
    }
    default: {
      unwindInterruptedWork(current2, unitOfWork, workInProgressRootRenderLanes);
      unitOfWork = workInProgress = resetWorkInProgress(
        unitOfWork,
        entangledRenderLanes
      );
      next = beginWork(current2, unitOfWork, entangledRenderLanes);
      break;
    }
  }
  if (isProfilingMode) {
    stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
  }
  return next;
}
function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
  resetSuspendedWorkLoopOnUnwind(unitOfWork);
  const returnFiber = unitOfWork.return;
  try {
    const didFatal = throwException(
      root2,
      returnFiber,
      unitOfWork,
      thrownValue,
      workInProgressRootRenderLanes
    );
    if (didFatal) {
      panicOnRootError(root2, thrownValue);
      return;
    }
  } catch (error) {
    if (returnFiber !== null) {
      workInProgress = returnFiber;
      throw error;
    } else {
      panicOnRootError(root2, thrownValue);
      return;
    }
  }
  if (unitOfWork.flags & Incomplete) {
    let skipSiblings;
    if (
      // The current algorithm for both hydration and error handling assumes
      // that the tree is rendered sequentially. So we always skip the siblings.
      getIsHydrating() || suspendedReason === SuspendedOnError
    ) {
      skipSiblings = true;
    } else if (
      // Check whether this is a prerender
      !workInProgressRootIsPrerendering && // Offscreen rendering is also a form of speculative rendering
      !includesSomeLane(workInProgressRootRenderLanes, OffscreenLane)
    ) {
      skipSiblings = true;
      workInProgressRootDidSkipSuspendedSiblings = true;
      if (suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) {
        const boundary = getSuspenseHandler();
        if (boundary !== null && boundary.tag === SuspenseComponent) {
          boundary.flags |= ScheduleRetry;
        }
      }
    } else {
      skipSiblings = false;
    }
    unwindUnitOfWork(unitOfWork, skipSiblings);
  } else {
    completeUnitOfWork(unitOfWork);
  }
}
function markSpawnedRetryLane(lane) {
  workInProgressSuspendedRetryLanes = mergeLanes(
    workInProgressSuspendedRetryLanes,
    lane
  );
}
function panicOnRootError(root2, error) {
  workInProgressRootExitStatus = RootFatalErrored;
  logUncaughtError(root2, createCapturedValueAtFiber(error, root2.current));
  workInProgress = null;
}
function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  do {
    if ((completedWork.flags & Incomplete) !== NoFlags) {
      const skipSiblings = workInProgressRootDidSkipSuspendedSiblings;
      unwindUnitOfWork(completedWork, skipSiblings);
      return;
    }
    const current2 = completedWork.alternate;
    const returnFiber = completedWork.return;
    let next;
    startProfilerTimer(completedWork);
    if (false) {
      next = runWithFiberInDEV(
        completedWork,
        completeWork,
        current2,
        completedWork,
        entangledRenderLanes
      );
    } else {
      next = completeWork(current2, completedWork, entangledRenderLanes);
    }
    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {
      stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
    }
    if (next !== null) {
      workInProgress = next;
      return;
    }
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
  if (workInProgressRootExitStatus === RootInProgress) {
    workInProgressRootExitStatus = RootCompleted;
  }
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  let incompleteWork = unitOfWork;
  do {
    const current2 = incompleteWork.alternate;
    const next = unwindWork(current2, incompleteWork, entangledRenderLanes);
    if (next !== null) {
      next.flags &= HostEffectMask;
      workInProgress = next;
      return;
    }
    if (enableProfilerTimer && (incompleteWork.mode & ProfileMode) !== NoMode) {
      stopProfilerTimerIfRunningAndRecordIncompleteDuration(incompleteWork);
      let actualDuration = incompleteWork.actualDuration;
      let child = incompleteWork.child;
      while (child !== null) {
        actualDuration += child.actualDuration;
        child = child.sibling;
      }
      incompleteWork.actualDuration = actualDuration;
    }
    const returnFiber = incompleteWork.return;
    if (returnFiber !== null) {
      returnFiber.flags |= Incomplete;
      returnFiber.subtreeFlags = NoFlags;
      returnFiber.deletions = null;
    }
    if (!skipSiblings) {
      const siblingFiber = incompleteWork.sibling;
      if (siblingFiber !== null) {
        workInProgress = siblingFiber;
        return;
      }
    }
    incompleteWork = returnFiber;
    workInProgress = incompleteWork;
  } while (incompleteWork !== null);
  workInProgressRootExitStatus = RootSuspendedAtTheShell;
  workInProgress = null;
}
function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
  root2.cancelPendingCommit = null;
  do {
    flushPendingEffects();
  } while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
  flushRenderPhaseStrictModeWarningsInDEV();
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    throw new Error("Should not already be working.");
  }
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    setCurrentTrackFromLanes(lanes);
    if (exitStatus === RootErrored) {
      logErroredRenderPhase(
        completedRenderStartTime,
        completedRenderEndTime,
        lanes
      );
    } else if (recoverableErrors !== null) {
      const hydrationFailed = finishedWork !== null && finishedWork.alternate !== null && finishedWork.alternate.memoizedState.isDehydrated && (finishedWork.flags & ForceClientRender) !== NoFlags;
      logRecoveredRenderPhase(
        completedRenderStartTime,
        completedRenderEndTime,
        lanes,
        recoverableErrors,
        hydrationFailed
      );
    } else {
      logRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes);
    }
  }
  if (enableSchedulingProfiler) {
    markCommitStarted(lanes);
  }
  if (finishedWork === null) {
    if (enableSchedulingProfiler) {
      markCommitStopped();
    }
    if (enableGestureTransition) {
      if (root2.stoppingGestures !== null) {
        stopCompletedGestures(root2);
      }
    }
    return;
  } else {
    if (false) {
      if (lanes === NoLanes) {
        console.error(
          "finishedLanes should not be empty during a commit. This is a bug in React."
        );
      }
    }
  }
  if (finishedWork === root2.current) {
    throw new Error(
      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
    );
  }
  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
  const concurrentlyUpdatedLanes2 = getConcurrentlyUpdatedLanes();
  remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes2);
  if (enableGestureTransition && root2.pendingGestures === null) {
    remainingLanes &= ~GestureLane;
  }
  markRootFinished(
    root2,
    lanes,
    remainingLanes,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes
  );
  didIncludeCommitPhaseUpdate = false;
  if (root2 === workInProgressRoot) {
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  } else {
  }
  pendingFinishedWork = finishedWork;
  pendingEffectsRoot = root2;
  pendingEffectsLanes = lanes;
  pendingEffectsRemainingLanes = remainingLanes;
  pendingPassiveTransitions = transitions;
  pendingRecoverableErrors = recoverableErrors;
  pendingDidIncludeRenderPhaseUpdate = didIncludeRenderPhaseUpdate;
  if (enableProfilerTimer) {
    pendingEffectsRenderEndTime = completedRenderEndTime;
    pendingSuspendedCommitReason = suspendedCommitReason;
  }
  if (enableGestureTransition && isGestureRender(lanes)) {
    commitGestureOnRoot(
      root2,
      finishedWork,
      recoverableErrors,
      enableProfilerTimer ? suspendedCommitReason === IMMEDIATE_COMMIT ? completedRenderEndTime : commitStartTime : 0
    );
    return;
  }
  let passiveSubtreeMask;
  if (enableViewTransition) {
    pendingViewTransitionEvents = null;
    if (includesOnlyViewTransitionEligibleLanes(lanes)) {
      pendingTransitionTypes = claimQueuedTransitionTypes(root2);
      passiveSubtreeMask = PassiveTransitionMask;
    } else {
      pendingTransitionTypes = null;
      passiveSubtreeMask = PassiveMask;
    }
  } else {
    passiveSubtreeMask = PassiveMask;
  }
  if (
    // If this subtree rendered with profiling this commit, we need to visit it to log it.
    enableProfilerTimer && enableComponentPerformanceTrack && finishedWork.actualDuration !== 0 || (finishedWork.subtreeFlags & passiveSubtreeMask) !== NoFlags || (finishedWork.flags & passiveSubtreeMask) !== NoFlags
  ) {
    if (enableYieldingBeforePassive) {
    } else {
      root2.callbackNode = null;
      root2.callbackPriority = NoLane;
      scheduleCallback4(NormalPriority2, () => {
        if (enableProfilerTimer && enableComponentPerformanceTrack) {
          (void 0)();
        }
        flushPassiveEffects(true);
        return null;
      });
    }
  } else {
    root2.callbackNode = null;
    root2.callbackPriority = NoLane;
  }
  if (enableProfilerTimer) {
    resetCommitErrors();
    recordCommitTime();
    if (enableComponentPerformanceTrack) {
      if (suspendedCommitReason === SUSPENDED_COMMIT) {
        logSuspendedCommitPhase(completedRenderEndTime, commitStartTime);
      } else if (suspendedCommitReason === THROTTLED_COMMIT) {
        logSuspenseThrottlePhase(completedRenderEndTime, commitStartTime);
      }
    }
  }
  resetShouldStartViewTransition();
  const subtreeHasBeforeMutationEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask)) !== NoFlags;
  const rootHasBeforeMutationEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask)) !== NoFlags;
  if (subtreeHasBeforeMutationEffects || rootHasBeforeMutationEffect) {
    const prevTransition = ReactSharedInternals_default.T;
    ReactSharedInternals_default.T = null;
    const previousPriority = (void 0)();
    (void 0)(DiscreteEventPriority);
    const prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    try {
      commitBeforeMutationEffects(root2, finishedWork, lanes);
    } finally {
      executionContext = prevExecutionContext;
      (void 0)(previousPriority);
      ReactSharedInternals_default.T = prevTransition;
    }
  }
  let willStartViewTransition = shouldStartViewTransition;
  if (enableGestureTransition) {
    if (root2.stoppingGestures !== null) {
      stopCompletedGestures(root2);
      willStartViewTransition = false;
    }
  }
  pendingEffectsStatus = PENDING_MUTATION_PHASE;
  if (enableViewTransition && willStartViewTransition) {
    pendingViewTransition = (void 0)(
      root2.containerInfo,
      pendingTransitionTypes,
      flushMutationEffects,
      flushLayoutEffects,
      flushAfterMutationEffects,
      flushSpawnedWork,
      flushPassiveEffects,
      reportViewTransitionError
    );
  } else {
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
  }
}
function reportViewTransitionError(error) {
  if (pendingEffectsStatus === NO_PENDING_EFFECTS) {
    return;
  }
  const root2 = pendingEffectsRoot;
  const onRecoverableError = root2.onRecoverableError;
  onRecoverableError(error, makeErrorInfo(null));
}
function flushAfterMutationEffects() {
  if (pendingEffectsStatus !== PENDING_AFTER_MUTATION_PHASE) {
    return;
  }
  pendingEffectsStatus = NO_PENDING_EFFECTS;
  const root2 = pendingEffectsRoot;
  const finishedWork = pendingFinishedWork;
  const lanes = pendingEffectsLanes;
  commitAfterMutationEffects(root2, finishedWork, lanes);
  pendingEffectsStatus = PENDING_SPAWNED_WORK;
}
function flushMutationEffects() {
  if (pendingEffectsStatus !== PENDING_MUTATION_PHASE) {
    return;
  }
  pendingEffectsStatus = NO_PENDING_EFFECTS;
  const root2 = pendingEffectsRoot;
  const finishedWork = pendingFinishedWork;
  const lanes = pendingEffectsLanes;
  const subtreeMutationHasEffects = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
  const rootMutationHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
  if (subtreeMutationHasEffects || rootMutationHasEffect) {
    const prevTransition = ReactSharedInternals_default.T;
    ReactSharedInternals_default.T = null;
    const previousPriority = (void 0)();
    (void 0)(DiscreteEventPriority);
    const prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    try {
      commitMutationEffects(root2, finishedWork, lanes);
      if (enableCreateEventHandleAPI) {
        if (shouldFireAfterActiveInstanceBlur) {
          (void 0)();
        }
      }
      (void 0)(root2.containerInfo);
    } finally {
      executionContext = prevExecutionContext;
      (void 0)(previousPriority);
      ReactSharedInternals_default.T = prevTransition;
    }
  }
  root2.current = finishedWork;
  pendingEffectsStatus = PENDING_LAYOUT_PHASE;
}
function flushLayoutEffects() {
  if (pendingEffectsStatus !== PENDING_LAYOUT_PHASE) {
    return;
  }
  pendingEffectsStatus = NO_PENDING_EFFECTS;
  const root2 = pendingEffectsRoot;
  const finishedWork = pendingFinishedWork;
  const lanes = pendingEffectsLanes;
  if (enableDefaultTransitionIndicator) {
    const cleanUpIndicator = root2.pendingIndicator;
    if (cleanUpIndicator !== null && root2.indicatorLanes === NoLanes) {
      const prevTransition = ReactSharedInternals_default.T;
      ReactSharedInternals_default.T = null;
      const previousPriority = (void 0)();
      (void 0)(DiscreteEventPriority);
      const prevExecutionContext = executionContext;
      executionContext |= CommitContext;
      root2.pendingIndicator = null;
      try {
        cleanUpIndicator();
      } catch (x) {
        reportGlobalError_default(x);
      } finally {
        executionContext = prevExecutionContext;
        (void 0)(previousPriority);
        ReactSharedInternals_default.T = prevTransition;
      }
    }
  }
  const subtreeHasLayoutEffects = (finishedWork.subtreeFlags & LayoutMask) !== NoFlags;
  const rootHasLayoutEffect = (finishedWork.flags & LayoutMask) !== NoFlags;
  if (subtreeHasLayoutEffects || rootHasLayoutEffect) {
    const prevTransition = ReactSharedInternals_default.T;
    ReactSharedInternals_default.T = null;
    const previousPriority = (void 0)();
    (void 0)(DiscreteEventPriority);
    const prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    try {
      if (enableSchedulingProfiler) {
        markLayoutEffectsStarted(lanes);
      }
      commitLayoutEffects(finishedWork, root2, lanes);
      if (enableSchedulingProfiler) {
        markLayoutEffectsStopped();
      }
    } finally {
      executionContext = prevExecutionContext;
      (void 0)(previousPriority);
      ReactSharedInternals_default.T = prevTransition;
    }
  }
  pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
}
function flushSpawnedWork() {
  if (pendingEffectsStatus !== PENDING_SPAWNED_WORK && // If a startViewTransition times out, we might flush this earlier than
  // after mutation phase. In that case, we just skip the after mutation phase.
  pendingEffectsStatus !== PENDING_AFTER_MUTATION_PHASE) {
    return;
  }
  pendingEffectsStatus = NO_PENDING_EFFECTS;
  pendingViewTransition = null;
  requestPaint2();
  const root2 = pendingEffectsRoot;
  const finishedWork = pendingFinishedWork;
  const lanes = pendingEffectsLanes;
  const completedRenderEndTime = pendingEffectsRenderEndTime;
  const recoverableErrors = pendingRecoverableErrors;
  const didIncludeRenderPhaseUpdate = pendingDidIncludeRenderPhaseUpdate;
  const suspendedCommitReason = pendingSuspendedCommitReason;
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    recordCommitEndTime();
    logCommitPhase(
      suspendedCommitReason === IMMEDIATE_COMMIT ? completedRenderEndTime : commitStartTime,
      commitEndTime,
      commitErrors
    );
  }
  const passiveSubtreeMask = enableViewTransition && includesOnlyViewTransitionEligibleLanes(lanes) ? PassiveTransitionMask : PassiveMask;
  const rootDidHavePassiveEffects = (
    // If this subtree rendered with profiling this commit, we need to visit it to log it.
    enableProfilerTimer && enableComponentPerformanceTrack && finishedWork.actualDuration !== 0 || (finishedWork.subtreeFlags & passiveSubtreeMask) !== NoFlags || (finishedWork.flags & passiveSubtreeMask) !== NoFlags
  );
  if (rootDidHavePassiveEffects) {
    pendingEffectsStatus = PENDING_PASSIVE_PHASE;
  } else {
    pendingEffectsStatus = NO_PENDING_EFFECTS;
    pendingEffectsRoot = null;
    pendingFinishedWork = null;
    releaseRootPooledCache(root2, root2.pendingLanes);
    if (false) {
      nestedPassiveUpdateCount = 0;
      rootWithPassiveNestedUpdates = null;
    }
  }
  let remainingLanes = root2.pendingLanes;
  if (remainingLanes === NoLanes) {
    legacyErrorBoundariesThatAlreadyFailed = null;
  }
  if (false) {
    if (!rootDidHavePassiveEffects) {
      commitDoubleInvokeEffectsInDEV(root2, false);
    }
  }
  const renderPriority = lanesToEventPriority(lanes);
  onCommitRoot(finishedWork.stateNode, renderPriority);
  if (enableUpdaterTracking) {
    if (isDevToolsPresent) {
      root2.memoizedUpdaters.clear();
    }
  }
  if (false) {
    onCommitRoot2();
  }
  if (recoverableErrors !== null) {
    const prevTransition = ReactSharedInternals_default.T;
    const previousUpdateLanePriority = (void 0)();
    (void 0)(DiscreteEventPriority);
    ReactSharedInternals_default.T = null;
    try {
      const onRecoverableError = root2.onRecoverableError;
      for (let i = 0; i < recoverableErrors.length; i++) {
        const recoverableError = recoverableErrors[i];
        const errorInfo = makeErrorInfo(recoverableError.stack);
        if (false) {
          runWithFiberInDEV(
            recoverableError.source,
            onRecoverableError,
            recoverableError.value,
            errorInfo
          );
        } else {
          onRecoverableError(recoverableError.value, errorInfo);
        }
      }
    } finally {
      ReactSharedInternals_default.T = prevTransition;
      (void 0)(previousUpdateLanePriority);
    }
  }
  if (enableViewTransition) {
    const pendingEvents = pendingViewTransitionEvents;
    let pendingTypes = pendingTransitionTypes;
    pendingTransitionTypes = null;
    if (pendingEvents !== null) {
      pendingViewTransitionEvents = null;
      if (pendingTypes === null) {
        pendingTypes = [];
      }
      for (let i = 0; i < pendingEvents.length; i++) {
        const viewTransitionEvent = pendingEvents[i];
        viewTransitionEvent(pendingTypes);
      }
    }
  }
  if (includesSyncLane(pendingEffectsLanes) && (disableLegacyMode || root2.tag !== LegacyRoot)) {
    flushPendingEffects();
  }
  ensureRootIsScheduled(root2);
  remainingLanes = root2.pendingLanes;
  if (
    // Check if there was a recursive update spawned by this render, in either
    // the render phase or the commit phase. We track these explicitly because
    // we can't infer from the remaining lanes alone.
    enableInfiniteRenderLoopDetection && (didIncludeRenderPhaseUpdate || didIncludeCommitPhaseUpdate) || // Was the finished render the result of an update (not hydration)?
    includesSomeLane(lanes, UpdateLanes) && // Did it schedule a sync update?
    includesSomeLane(remainingLanes, SyncUpdateLanes)
  ) {
    if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {
      markNestedUpdateScheduled();
    }
    if (root2 === rootWithNestedUpdates) {
      nestedUpdateCount++;
    } else {
      nestedUpdateCount = 0;
      rootWithNestedUpdates = root2;
    }
  } else {
    nestedUpdateCount = 0;
  }
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    if (!rootDidHavePassiveEffects) {
      finalizeRender(lanes, commitEndTime);
    }
  }
  if (void 0) {
    (void 0)();
  }
  flushSyncWorkOnAllRoots();
  if (enableSchedulingProfiler) {
    markCommitStopped();
  }
  if (enableTransitionTracing) {
    const prevRootTransitionCallbacks = root2.transitionCallbacks;
    if (prevRootTransitionCallbacks !== null) {
      schedulePostPaintCallback((endTime) => {
        const prevPendingTransitionCallbacks = currentPendingTransitionCallbacks;
        if (prevPendingTransitionCallbacks !== null) {
          currentPendingTransitionCallbacks = null;
          scheduleCallback4(IdlePriority2, () => {
            processTransitionCallbacks(
              prevPendingTransitionCallbacks,
              endTime,
              prevRootTransitionCallbacks
            );
          });
        } else {
          currentEndTime = endTime;
        }
      });
    }
  }
}
function commitGestureOnRoot(root2, finishedWork, recoverableErrors, renderEndTime) {
  const finishedGesture = root2.pendingGestures;
  if (finishedGesture === null) {
    ensureRootIsScheduled(root2);
    return;
  }
  deleteScheduledGesture(root2, finishedGesture);
  const prevTransition = ReactSharedInternals_default.T;
  ReactSharedInternals_default.T = null;
  const previousPriority = (void 0)();
  (void 0)(DiscreteEventPriority);
  const prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  try {
    insertDestinationClones(root2, finishedWork);
  } finally {
    executionContext = prevExecutionContext;
    (void 0)(previousPriority);
    ReactSharedInternals_default.T = prevTransition;
  }
  pendingTransitionTypes = finishedGesture.types;
  pendingEffectsStatus = PENDING_GESTURE_MUTATION_PHASE;
  pendingViewTransition = finishedGesture.running = (void 0)(
    root2.containerInfo,
    finishedGesture.provider,
    finishedGesture.rangeStart,
    finishedGesture.rangeEnd,
    pendingTransitionTypes,
    flushGestureMutations,
    flushGestureAnimations,
    reportViewTransitionError
  );
}
function flushGestureMutations() {
  if (!enableGestureTransition) {
    return;
  }
  if (pendingEffectsStatus !== PENDING_GESTURE_MUTATION_PHASE) {
    return;
  }
  pendingEffectsStatus = NO_PENDING_EFFECTS;
  const root2 = pendingEffectsRoot;
  const finishedWork = pendingFinishedWork;
  const prevTransition = ReactSharedInternals_default.T;
  ReactSharedInternals_default.T = null;
  const previousPriority = (void 0)();
  (void 0)(DiscreteEventPriority);
  const prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  try {
    applyDepartureTransitions(root2, finishedWork);
  } finally {
    executionContext = prevExecutionContext;
    (void 0)(previousPriority);
    ReactSharedInternals_default.T = prevTransition;
  }
  pendingEffectsStatus = PENDING_GESTURE_ANIMATION_PHASE;
}
function flushGestureAnimations() {
  if (!enableGestureTransition) {
    return;
  }
  flushGestureMutations();
  if (pendingEffectsStatus !== PENDING_GESTURE_ANIMATION_PHASE) {
    return;
  }
  pendingEffectsStatus = NO_PENDING_EFFECTS;
  const root2 = pendingEffectsRoot;
  const finishedWork = pendingFinishedWork;
  pendingEffectsRoot = null;
  pendingFinishedWork = null;
  pendingEffectsLanes = NoLanes;
  pendingViewTransition = null;
  const prevTransition = ReactSharedInternals_default.T;
  ReactSharedInternals_default.T = null;
  const previousPriority = (void 0)();
  (void 0)(DiscreteEventPriority);
  const prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  try {
    startGestureAnimations(root2, finishedWork);
  } finally {
    executionContext = prevExecutionContext;
    (void 0)(previousPriority);
    ReactSharedInternals_default.T = prevTransition;
  }
  ensureRootIsScheduled(root2);
}
function makeErrorInfo(componentStack) {
  const errorInfo = {
    componentStack
  };
  if (false) {
    Object.defineProperty(errorInfo, "digest", {
      get() {
        console.error(
          'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
        );
      }
    });
  }
  return errorInfo;
}
function releaseRootPooledCache(root2, remainingLanes) {
  const pooledCacheLanes = root2.pooledCacheLanes &= remainingLanes;
  if (pooledCacheLanes === NoLanes) {
    const pooledCache = root2.pooledCache;
    if (pooledCache != null) {
      root2.pooledCache = null;
      releaseCache(pooledCache);
    }
  }
}
function flushPendingEffects(wasDelayedCommit) {
  if (enableViewTransition && pendingViewTransition !== null) {
    (void 0)(pendingViewTransition);
    if (false) {
      if (!didWarnAboutInterruptedViewTransitions) {
        didWarnAboutInterruptedViewTransitions = true;
        console.warn(
          "A flushSync update cancelled a View Transition because it was called while the View Transition was still preparing. To preserve the synchronous semantics, React had to skip the View Transition. If you can, try to avoid flushSync() in a scenario that's likely to interfere."
        );
      }
    }
    pendingViewTransition = null;
  }
  flushGestureMutations();
  flushGestureAnimations();
  flushMutationEffects();
  flushLayoutEffects();
  flushSpawnedWork();
  return flushPassiveEffects(wasDelayedCommit);
}
function flushPassiveEffects(wasDelayedCommit) {
  if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) {
    return false;
  }
  const root2 = pendingEffectsRoot;
  const remainingLanes = pendingEffectsRemainingLanes;
  pendingEffectsRemainingLanes = NoLanes;
  const renderPriority = lanesToEventPriority(pendingEffectsLanes);
  const priority = lowerEventPriority(DefaultEventPriority, renderPriority);
  const prevTransition = ReactSharedInternals_default.T;
  const previousPriority = (void 0)();
  try {
    (void 0)(priority);
    ReactSharedInternals_default.T = null;
    return flushPassiveEffectsImpl(wasDelayedCommit);
  } finally {
    (void 0)(previousPriority);
    ReactSharedInternals_default.T = prevTransition;
    releaseRootPooledCache(root2, remainingLanes);
  }
}
function flushPassiveEffectsImpl(wasDelayedCommit) {
  const transitions = pendingPassiveTransitions;
  pendingPassiveTransitions = null;
  const root2 = pendingEffectsRoot;
  const lanes = pendingEffectsLanes;
  pendingEffectsStatus = NO_PENDING_EFFECTS;
  pendingEffectsRoot = null;
  pendingFinishedWork = null;
  pendingEffectsLanes = NoLanes;
  if (enableYieldingBeforePassive) {
    root2.callbackNode = null;
    root2.callbackPriority = NoLane;
  }
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    throw new Error("Cannot flush passive effects while already rendering.");
  }
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    setCurrentTrackFromLanes(lanes);
  }
  if (false) {
    isFlushingPassiveEffects = true;
    didScheduleUpdateDuringPassiveEffects = false;
  }
  let passiveEffectStartTime = 0;
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    resetCommitErrors();
    passiveEffectStartTime = now();
    logPaintYieldPhase(
      commitEndTime,
      passiveEffectStartTime,
      !!wasDelayedCommit
    );
  }
  if (enableSchedulingProfiler) {
    markPassiveEffectsStarted(lanes);
  }
  const prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  commitPassiveUnmountEffects(root2.current);
  commitPassiveMountEffects(
    root2,
    root2.current,
    lanes,
    transitions,
    pendingEffectsRenderEndTime
  );
  if (enableSchedulingProfiler) {
    markPassiveEffectsStopped();
  }
  if (false) {
    commitDoubleInvokeEffectsInDEV(root2, true);
  }
  executionContext = prevExecutionContext;
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    const passiveEffectsEndTime = now();
    logPassiveCommitPhase(
      passiveEffectStartTime,
      passiveEffectsEndTime,
      commitErrors
    );
    finalizeRender(lanes, passiveEffectsEndTime);
  }
  flushSyncWorkOnAllRoots();
  if (enableTransitionTracing) {
    const prevPendingTransitionCallbacks = currentPendingTransitionCallbacks;
    const prevRootTransitionCallbacks = root2.transitionCallbacks;
    const prevEndTime = currentEndTime;
    if (prevPendingTransitionCallbacks !== null && prevRootTransitionCallbacks !== null && prevEndTime !== null) {
      currentPendingTransitionCallbacks = null;
      currentEndTime = null;
      scheduleCallback4(IdlePriority2, () => {
        processTransitionCallbacks(
          prevPendingTransitionCallbacks,
          prevEndTime,
          prevRootTransitionCallbacks
        );
      });
    }
  }
  if (false) {
    if (didScheduleUpdateDuringPassiveEffects) {
      if (root2 === rootWithPassiveNestedUpdates) {
        nestedPassiveUpdateCount++;
      } else {
        nestedPassiveUpdateCount = 0;
        rootWithPassiveNestedUpdates = root2;
      }
    } else {
      nestedPassiveUpdateCount = 0;
    }
    isFlushingPassiveEffects = false;
    didScheduleUpdateDuringPassiveEffects = false;
  }
  if (enableYieldingBeforePassive) {
    ensureRootIsScheduled(root2);
  }
  onPostCommitRoot(root2);
  if (enableProfilerTimer && enableProfilerCommitHooks) {
    const stateNode = root2.current.stateNode;
    stateNode.effectDuration = 0;
    stateNode.passiveEffectDuration = 0;
  }
  return true;
}
function isAlreadyFailedLegacyErrorBoundary(instance) {
  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
}
function markLegacyErrorBoundaryAsFailed(instance) {
  if (legacyErrorBoundariesThatAlreadyFailed === null) {
    legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
  } else {
    legacyErrorBoundariesThatAlreadyFailed.add(instance);
  }
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  const errorInfo = createCapturedValueAtFiber(error, sourceFiber);
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    recordEffectError(errorInfo);
  }
  const update = createRootErrorUpdate(
    rootFiber.stateNode,
    errorInfo,
    SyncLane
  );
  const root2 = enqueueUpdate2(rootFiber, update, SyncLane);
  if (root2 !== null) {
    markRootUpdated2(root2, SyncLane);
    ensureRootIsScheduled(root2);
  }
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (false) {
    setIsRunningInsertionEffect(false);
  }
  if (sourceFiber.tag === HostRoot) {
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    return;
  }
  let fiber = nearestMountedAncestor;
  while (fiber !== null) {
    if (fiber.tag === HostRoot) {
      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
      return;
    } else if (fiber.tag === ClassComponent) {
      const ctor = fiber.type;
      const instance = fiber.stateNode;
      if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
        const errorInfo = createCapturedValueAtFiber(error, sourceFiber);
        if (enableProfilerTimer && enableComponentPerformanceTrack) {
          recordEffectError(errorInfo);
        }
        const update = createClassErrorUpdate(SyncLane);
        const root2 = enqueueUpdate2(fiber, update, SyncLane);
        if (root2 !== null) {
          initializeClassErrorUpdate(update, root2, fiber, errorInfo);
          markRootUpdated2(root2, SyncLane);
          ensureRootIsScheduled(root2);
        }
        return;
      }
    }
    fiber = fiber.return;
  }
  if (false) {
    console.error(
      "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
      error
    );
  }
}
function attachPingListener(root2, wakeable, lanes) {
  let pingCache = root2.pingCache;
  let threadIDs;
  if (pingCache === null) {
    pingCache = root2.pingCache = new PossiblyWeakMap();
    threadIDs = /* @__PURE__ */ new Set();
    pingCache.set(wakeable, threadIDs);
  } else {
    threadIDs = pingCache.get(wakeable);
    if (threadIDs === void 0) {
      threadIDs = /* @__PURE__ */ new Set();
      pingCache.set(wakeable, threadIDs);
    }
  }
  if (!threadIDs.has(lanes)) {
    workInProgressRootDidAttachPingListener = true;
    threadIDs.add(lanes);
    const ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        restorePendingUpdaters(root2, lanes);
      }
    }
    wakeable.then(ping, ping);
  }
}
function pingSuspendedRoot(root2, wakeable, pingedLanes) {
  const pingCache = root2.pingCache;
  if (pingCache !== null) {
    pingCache.delete(wakeable);
  }
  markRootPinged2(root2, pingedLanes);
  if (enableProfilerTimer && enableComponentPerformanceTrack) {
    startPingTimerByLanes(pingedLanes);
  }
  warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
  if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
      if ((executionContext & RenderContext) === NoContext) {
        prepareFreshStack(root2, NoLanes);
      } else {
      }
    } else {
      workInProgressRootPingedLanes = mergeLanes(
        workInProgressRootPingedLanes,
        pingedLanes
      );
    }
    if (workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes) {
      workInProgressSuspendedRetryLanes = NoLanes;
    }
  }
  ensureRootIsScheduled(root2);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  if (retryLane === NoLane) {
    retryLane = requestRetryLane(boundaryFiber);
  }
  const root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  if (root2 !== null) {
    markRootUpdated2(root2, retryLane);
    ensureRootIsScheduled(root2);
  }
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  const suspenseState = boundaryFiber.memoizedState;
  let retryLane = NoLane;
  if (suspenseState !== null) {
    retryLane = suspenseState.retryLane;
  }
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  let retryLane = NoLane;
  let retryCache;
  switch (boundaryFiber.tag) {
    case ActivityComponent:
    case SuspenseComponent:
      retryCache = boundaryFiber.stateNode;
      const suspenseState = boundaryFiber.memoizedState;
      if (suspenseState !== null) {
        retryLane = suspenseState.retryLane;
      }
      break;
    case SuspenseListComponent:
      retryCache = boundaryFiber.stateNode;
      break;
    case OffscreenComponent: {
      const instance = boundaryFiber.stateNode;
      retryCache = instance._retryCache;
      break;
    }
    default:
      throw new Error(
        "Pinged unknown suspense boundary type. This is probably a bug in React."
      );
  }
  if (retryCache !== null) {
    retryCache.delete(wakeable);
  }
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function throwIfInfiniteUpdateLoopDetected() {
  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
    nestedUpdateCount = 0;
    nestedPassiveUpdateCount = 0;
    rootWithNestedUpdates = null;
    rootWithPassiveNestedUpdates = null;
    if (enableInfiniteRenderLoopDetection) {
      if (executionContext & RenderContext && workInProgressRoot !== null) {
        workInProgressRoot.errorRecoveryDisabledLanes = mergeLanes(
          workInProgressRoot.errorRecoveryDisabledLanes,
          workInProgressRootRenderLanes
        );
      }
    }
    throw new Error(
      "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
    );
  }
  if (false) {
    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
      nestedPassiveUpdateCount = 0;
      rootWithPassiveNestedUpdates = null;
      console.error(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      );
    }
  }
}
function flushRenderPhaseStrictModeWarningsInDEV() {
  if (false) {
    ReactStrictModeWarnings_default.flushLegacyContextWarning();
    ReactStrictModeWarnings_default.flushPendingUnsafeLifecycleWarnings();
  }
}
if (false) {
  didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
}
function warnAboutRenderPhaseUpdatesInDEV(fiber) {
  if (false) {
    if (isRendering) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent: {
          const renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
          const dedupeKey = renderingComponentName;
          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
            const setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
            console.error(
              "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
              setStateComponentName,
              renderingComponentName,
              renderingComponentName
            );
          }
          break;
        }
        case ClassComponent: {
          if (!didWarnAboutUpdateInRender) {
            console.error(
              "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
            );
            didWarnAboutUpdateInRender = true;
          }
          break;
        }
      }
    }
  }
}
function restorePendingUpdaters(root2, lanes) {
  if (enableUpdaterTracking) {
    if (isDevToolsPresent) {
      const memoizedUpdaters = root2.memoizedUpdaters;
      memoizedUpdaters.forEach((schedulingFiber) => {
        addFiberToLanesMap(root2, schedulingFiber, lanes);
      });
    }
  }
}
function scheduleCallback4(priorityLevel, callback) {
  if (false) {
    const actQueue = ReactSharedInternals_default.actQueue;
    if (actQueue !== null) {
      actQueue.push(callback);
      return fakeActCallbackNode;
    } else {
      return scheduleCallback(priorityLevel, callback);
    }
  } else {
    return scheduleCallback(priorityLevel, callback);
  }
}
function shouldForceFlushFallbacksInDEV() {
  return false;
}
function warnIfUpdatesNotWrappedWithActDEV(fiber) {
  if (false) {
    if (disableLegacyMode || fiber.mode & ConcurrentMode) {
      if (!isConcurrentActEnvironment()) {
        return;
      }
    } else {
      if (!isLegacyActEnvironment(fiber)) {
        return;
      }
      if (executionContext !== NoContext) {
        return;
      }
      if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
        return;
      }
    }
    if (ReactSharedInternals_default.actQueue === null) {
      runWithFiberInDEV(fiber, () => {
        console.error(
          "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
          getComponentNameFromFiber(fiber)
        );
      });
    }
  }
}
function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
  if (false) {
    if ((disableLegacyMode || root2.tag !== LegacyRoot) && isConcurrentActEnvironment() && ReactSharedInternals_default.actQueue === null) {
      console.error(
        "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
      );
    }
  }
}

// dist/react-reconciler/src/ReactFiber.js
if (false) {
  hasBadMapPolyfill = false;
  try {
    const nonExtensibleObject = Object.preventExtensions({});
    /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
    /* @__PURE__ */ new Set([nonExtensibleObject]);
  } catch (e) {
    hasBadMapPolyfill = true;
  }
}
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.refCleanup = null;
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;
  this.mode = mode;
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
  this.alternate = null;
  if (enableProfilerTimer) {
    this.actualDuration = -0;
    this.actualStartTime = -1.1;
    this.selfBaseDuration = -0;
    this.treeBaseDuration = -0;
  }
  if (false) {
    this._debugInfo = null;
    this._debugOwner = null;
    this._debugStack = null;
    this._debugTask = null;
    this._debugNeedsRemount = false;
    this._debugHookTypes = null;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
      Object.preventExtensions(this);
    }
  }
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function createFiberImplObject(tag, pendingProps, key, mode) {
  const fiber = {
    // Instance
    // tag, key - defined at the bottom as dynamic properties
    elementType: null,
    type: null,
    stateNode: null,
    // Fiber
    return: null,
    child: null,
    sibling: null,
    index: 0,
    ref: null,
    refCleanup: null,
    // pendingProps - defined at the bottom as dynamic properties
    memoizedProps: null,
    updateQueue: null,
    memoizedState: null,
    dependencies: null,
    // Effects
    flags: NoFlags,
    subtreeFlags: NoFlags,
    deletions: null,
    lanes: NoLanes,
    childLanes: NoLanes,
    alternate: null,
    // dynamic properties at the end for more efficient hermes bytecode
    tag,
    key,
    pendingProps,
    mode
  };
  if (enableProfilerTimer) {
    fiber.actualDuration = -0;
    fiber.actualStartTime = -1.1;
    fiber.selfBaseDuration = -0;
    fiber.treeBaseDuration = -0;
  }
  if (false) {
    fiber._debugInfo = null;
    fiber._debugOwner = null;
    fiber._debugStack = null;
    fiber._debugTask = null;
    fiber._debugNeedsRemount = false;
    fiber._debugHookTypes = null;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
      Object.preventExtensions(fiber);
    }
  }
  return fiber;
}
var createFiber = enableObjectFiber ? createFiberImplObject : createFiberImplClass;
function shouldConstruct(Component2) {
  const prototype = Component2.prototype;
  return !!(prototype && prototype.isReactComponent);
}
function isSimpleFunctionComponent(type) {
  return typeof type === "function" && !shouldConstruct(type) && type.defaultProps === void 0;
}
function isFunctionClassComponent(type) {
  return shouldConstruct(type);
}
function createWorkInProgress(current2, pendingProps) {
  let workInProgress2 = current2.alternate;
  if (workInProgress2 === null) {
    workInProgress2 = createFiber(
      current2.tag,
      pendingProps,
      current2.key,
      current2.mode
    );
    workInProgress2.elementType = current2.elementType;
    workInProgress2.type = current2.type;
    workInProgress2.stateNode = current2.stateNode;
    if (false) {
      workInProgress2._debugOwner = current2._debugOwner;
      workInProgress2._debugStack = current2._debugStack;
      workInProgress2._debugTask = current2._debugTask;
      workInProgress2._debugHookTypes = current2._debugHookTypes;
    }
    workInProgress2.alternate = current2;
    current2.alternate = workInProgress2;
  } else {
    workInProgress2.pendingProps = pendingProps;
    workInProgress2.type = current2.type;
    workInProgress2.flags = NoFlags;
    workInProgress2.subtreeFlags = NoFlags;
    workInProgress2.deletions = null;
    if (enableProfilerTimer) {
      workInProgress2.actualDuration = -0;
      workInProgress2.actualStartTime = -1.1;
    }
  }
  workInProgress2.flags = current2.flags & StaticMask;
  workInProgress2.childLanes = current2.childLanes;
  workInProgress2.lanes = current2.lanes;
  workInProgress2.child = current2.child;
  workInProgress2.memoizedProps = current2.memoizedProps;
  workInProgress2.memoizedState = current2.memoizedState;
  workInProgress2.updateQueue = current2.updateQueue;
  const currentDependencies = current2.dependencies;
  workInProgress2.dependencies = currentDependencies === null ? null : false ? {
    lanes: currentDependencies.lanes,
    firstContext: currentDependencies.firstContext,
    _debugThenableState: currentDependencies._debugThenableState
  } : {
    lanes: currentDependencies.lanes,
    firstContext: currentDependencies.firstContext
  };
  workInProgress2.sibling = current2.sibling;
  workInProgress2.index = current2.index;
  workInProgress2.ref = current2.ref;
  workInProgress2.refCleanup = current2.refCleanup;
  if (enableProfilerTimer) {
    workInProgress2.selfBaseDuration = current2.selfBaseDuration;
    workInProgress2.treeBaseDuration = current2.treeBaseDuration;
  }
  if (false) {
    workInProgress2._debugInfo = current2._debugInfo;
    workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
    switch (workInProgress2.tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
        workInProgress2.type = resolveFunctionForHotReloading(current2.type);
        break;
      case ClassComponent:
        workInProgress2.type = resolveClassForHotReloading(current2.type);
        break;
      case ForwardRef:
        workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
        break;
      default:
        break;
    }
  }
  return workInProgress2;
}
function resetWorkInProgress(workInProgress2, renderLanes2) {
  workInProgress2.flags &= StaticMask | Placement;
  const current2 = workInProgress2.alternate;
  if (current2 === null) {
    workInProgress2.childLanes = NoLanes;
    workInProgress2.lanes = renderLanes2;
    workInProgress2.child = null;
    workInProgress2.subtreeFlags = NoFlags;
    workInProgress2.memoizedProps = null;
    workInProgress2.memoizedState = null;
    workInProgress2.updateQueue = null;
    workInProgress2.dependencies = null;
    workInProgress2.stateNode = null;
    if (enableProfilerTimer) {
      workInProgress2.selfBaseDuration = 0;
      workInProgress2.treeBaseDuration = 0;
    }
  } else {
    workInProgress2.childLanes = current2.childLanes;
    workInProgress2.lanes = current2.lanes;
    workInProgress2.child = current2.child;
    workInProgress2.subtreeFlags = NoFlags;
    workInProgress2.deletions = null;
    workInProgress2.memoizedProps = current2.memoizedProps;
    workInProgress2.memoizedState = current2.memoizedState;
    workInProgress2.updateQueue = current2.updateQueue;
    workInProgress2.type = current2.type;
    const currentDependencies = current2.dependencies;
    workInProgress2.dependencies = currentDependencies === null ? null : false ? {
      lanes: currentDependencies.lanes,
      firstContext: currentDependencies.firstContext,
      _debugThenableState: currentDependencies._debugThenableState
    } : {
      lanes: currentDependencies.lanes,
      firstContext: currentDependencies.firstContext
    };
    if (enableProfilerTimer) {
      workInProgress2.selfBaseDuration = current2.selfBaseDuration;
      workInProgress2.treeBaseDuration = current2.treeBaseDuration;
    }
  }
  return workInProgress2;
}
function createHostRootFiber(tag, isStrictMode) {
  let mode;
  if (disableLegacyMode || tag === ConcurrentRoot) {
    mode = ConcurrentMode;
    if (isStrictMode === true) {
      mode |= StrictLegacyMode | StrictEffectsMode;
    }
  } else {
    mode = NoMode;
  }
  if (enableProfilerTimer && isDevToolsPresent) {
    mode |= ProfileMode;
  }
  return createFiber(HostRoot, null, null, mode);
}
function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
  let fiberTag = FunctionComponent;
  let resolvedType = type;
  if (typeof type === "function") {
    if (shouldConstruct(type)) {
      fiberTag = ClassComponent;
      if (false) {
        resolvedType = resolveClassForHotReloading(resolvedType);
      }
    } else {
      if (false) {
        resolvedType = resolveFunctionForHotReloading(resolvedType);
      }
    }
  } else if (typeof type === "string") {
    if (void 0 && void 0) {
      const hostContext = getHostContext();
      fiberTag = (void 0)(type, pendingProps, hostContext) ? HostHoistable : (void 0)(type) ? HostSingleton : HostComponent;
    } else if (void 0) {
      const hostContext = getHostContext();
      fiberTag = (void 0)(type, pendingProps, hostContext) ? HostHoistable : HostComponent;
    } else if (void 0) {
      fiberTag = (void 0)(type) ? HostSingleton : HostComponent;
    } else {
      fiberTag = HostComponent;
    }
  } else {
    getTag: switch (type) {
      case REACT_ACTIVITY_TYPE:
        return createFiberFromActivity(pendingProps, mode, lanes, key);
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = Mode;
        mode |= StrictLegacyMode;
        if (disableLegacyMode || (mode & ConcurrentMode) !== NoMode) {
          mode |= StrictEffectsMode;
          if (enableDO_NOT_USE_disableStrictPassiveEffect && pendingProps.DO_NOT_USE_disableStrictPassiveEffect) {
            mode |= NoStrictPassiveEffectsMode;
          }
        }
        break;
      case REACT_PROFILER_TYPE:
        return createFiberFromProfiler(pendingProps, mode, lanes, key);
      case REACT_SUSPENSE_TYPE:
        return createFiberFromSuspense(pendingProps, mode, lanes, key);
      case REACT_SUSPENSE_LIST_TYPE:
        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
      case REACT_LEGACY_HIDDEN_TYPE:
        if (enableLegacyHidden) {
          return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
        }
      // Fall through
      case REACT_VIEW_TRANSITION_TYPE:
        if (enableViewTransition) {
          return createFiberFromViewTransition(pendingProps, mode, lanes, key);
        }
      // Fall through
      case REACT_SCOPE_TYPE:
        if (enableScopeAPI) {
          return createFiberFromScope(type, pendingProps, mode, lanes, key);
        }
      // Fall through
      case REACT_TRACING_MARKER_TYPE:
        if (enableTransitionTracing) {
          return createFiberFromTracingMarker(pendingProps, mode, lanes, key);
        }
      // Fall through
      default: {
        if (typeof type === "object" && type !== null) {
          switch (type.$$typeof) {
            case REACT_PROVIDER_TYPE:
              if (!enableRenderableContext) {
                fiberTag = ContextProvider;
                break getTag;
              }
            // Fall through
            case REACT_CONTEXT_TYPE:
              if (enableRenderableContext) {
                fiberTag = ContextProvider;
                break getTag;
              } else {
                fiberTag = ContextConsumer;
                break getTag;
              }
            case REACT_CONSUMER_TYPE:
              if (enableRenderableContext) {
                fiberTag = ContextConsumer;
                break getTag;
              }
            // Fall through
            case REACT_FORWARD_REF_TYPE:
              fiberTag = ForwardRef;
              if (false) {
                resolvedType = resolveForwardRefForHotReloading(resolvedType);
              }
              break getTag;
            case REACT_MEMO_TYPE:
              fiberTag = MemoComponent;
              break getTag;
            case REACT_LAZY_TYPE:
              fiberTag = LazyComponent;
              resolvedType = null;
              break getTag;
          }
        }
        let info = "";
        let typeString;
        if (false) {
          if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
          if (type === null) {
            typeString = "null";
          } else if (isArray_default(type)) {
            typeString = "array";
          } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = `<${getComponentNameFromType(type.type) || "Unknown"} />`;
            info = " Did you accidentally export a JSX literal instead of a component?";
          } else {
            typeString = typeof type;
          }
          const ownerName = owner ? getComponentNameFromOwner(owner) : null;
          if (ownerName) {
            info += "\n\nCheck the render method of `" + ownerName + "`.";
          }
        } else {
          typeString = type === null ? "null" : typeof type;
        }
        fiberTag = Throw;
        pendingProps = new Error(
          `Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: ${typeString}.${info}`
        );
        resolvedType = null;
      }
    }
  }
  const fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.lanes = lanes;
  if (false) {
    fiber._debugOwner = owner;
  }
  return fiber;
}
function createFiberFromElement(element, mode, lanes) {
  let owner = null;
  if (false) {
    owner = element._owner;
  }
  const type = element.type;
  const key = element.key;
  const pendingProps = element.props;
  const fiber = createFiberFromTypeAndProps(
    type,
    key,
    pendingProps,
    owner,
    mode,
    lanes
  );
  if (false) {
    fiber._debugOwner = element._owner;
    fiber._debugStack = element._debugStack;
    fiber._debugTask = element._debugTask;
  }
  return fiber;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  const fiber = createFiber(Fragment, elements, key, mode);
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromScope(scope, pendingProps, mode, lanes, key) {
  const fiber = createFiber(ScopeComponent, pendingProps, key, mode);
  fiber.type = scope;
  fiber.elementType = scope;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromProfiler(pendingProps, mode, lanes, key) {
  if (false) {
    if (typeof pendingProps.id !== "string") {
      console.error(
        'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
        typeof pendingProps.id
      );
    }
  }
  const fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
  fiber.elementType = REACT_PROFILER_TYPE;
  fiber.lanes = lanes;
  if (enableProfilerTimer) {
    fiber.stateNode = {
      effectDuration: 0,
      passiveEffectDuration: 0
    };
  }
  return fiber;
}
function createFiberFromSuspense(pendingProps, mode, lanes, key) {
  const fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
  fiber.elementType = REACT_SUSPENSE_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
  const fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
  const fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
  fiber.lanes = lanes;
  const primaryChildInstance = {
    _visibility: OffscreenVisible,
    _pendingMarkers: null,
    _retryCache: null,
    _transitions: null
  };
  fiber.stateNode = primaryChildInstance;
  return fiber;
}
function createFiberFromActivity(pendingProps, mode, lanes, key) {
  const fiber = createFiber(ActivityComponent, pendingProps, key, mode);
  fiber.elementType = REACT_ACTIVITY_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromViewTransition(pendingProps, mode, lanes, key) {
  if (!enableSuspenseyImages) {
    mode |= SuspenseyImagesMode;
  }
  const fiber = createFiber(ViewTransitionComponent, pendingProps, key, mode);
  fiber.elementType = REACT_VIEW_TRANSITION_TYPE;
  fiber.lanes = lanes;
  const instance = {
    autoName: null,
    paired: null,
    clones: null,
    ref: null
  };
  fiber.stateNode = instance;
  return fiber;
}
function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
  const fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode);
  fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
  fiber.lanes = lanes;
  const instance = {
    _visibility: OffscreenVisible,
    _pendingMarkers: null,
    _transitions: null,
    _retryCache: null
  };
  fiber.stateNode = instance;
  return fiber;
}
function createFiberFromTracingMarker(pendingProps, mode, lanes, key) {
  const fiber = createFiber(TracingMarkerComponent, pendingProps, key, mode);
  fiber.elementType = REACT_TRACING_MARKER_TYPE;
  fiber.lanes = lanes;
  const tracingMarkerInstance = {
    tag: TransitionTracingMarker,
    transitions: null,
    pendingBoundaries: null,
    aborts: null,
    name: pendingProps.name
  };
  fiber.stateNode = tracingMarkerInstance;
  return fiber;
}
function createFiberFromText(content, mode, lanes) {
  const fiber = createFiber(HostText, content, null, mode);
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromDehydratedFragment(dehydratedNode) {
  const fiber = createFiber(DehydratedFragment, null, null, NoMode);
  fiber.stateNode = dehydratedNode;
  return fiber;
}
function createFiberFromPortal(portal, mode, lanes) {
  const pendingProps = portal.children !== null ? portal.children : [];
  const fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
  fiber.lanes = lanes;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}
function createFiberFromThrow(error, mode, lanes) {
  const fiber = createFiber(Throw, error, null, mode);
  fiber.lanes = lanes;
  return fiber;
}

// dist/react-reconciler/src/ReactFiberRoot.js
function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
  this.tag = disableLegacyMode ? ConcurrentRoot : tag;
  this.containerInfo = containerInfo;
  this.pendingChildren = null;
  this.current = null;
  this.pingCache = null;
  this.timeoutHandle = void 0;
  this.cancelPendingCommit = null;
  this.context = null;
  this.pendingContext = null;
  this.next = null;
  this.callbackNode = null;
  this.callbackPriority = NoLane;
  this.expirationTimes = createLaneMap(NoTimestamp);
  this.pendingLanes = NoLanes;
  this.suspendedLanes = NoLanes;
  this.pingedLanes = NoLanes;
  this.warmLanes = NoLanes;
  this.expiredLanes = NoLanes;
  if (enableDefaultTransitionIndicator) {
    this.indicatorLanes = NoLanes;
  }
  this.errorRecoveryDisabledLanes = NoLanes;
  this.shellSuspendCounter = 0;
  this.entangledLanes = NoLanes;
  this.entanglements = createLaneMap(NoLanes);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  if (enableDefaultTransitionIndicator) {
    this.onDefaultTransitionIndicator = onDefaultTransitionIndicator;
    this.pendingIndicator = null;
  }
  this.pooledCache = null;
  this.pooledCacheLanes = NoLanes;
  if (enableSuspenseCallback) {
    this.hydrationCallbacks = null;
  }
  this.formState = formState;
  if (enableViewTransition) {
    this.transitionTypes = null;
  }
  if (enableGestureTransition) {
    this.pendingGestures = null;
    this.stoppingGestures = null;
    this.gestureClone = null;
  }
  this.incompleteTransitions = /* @__PURE__ */ new Map();
  if (enableTransitionTracing) {
    this.transitionCallbacks = null;
    this.transitionLanes = createLaneMap(null);
  }
  if (enableProfilerTimer && enableProfilerCommitHooks) {
    this.effectDuration = -0;
    this.passiveEffectDuration = -0;
  }
  if (enableUpdaterTracking) {
    this.memoizedUpdaters = /* @__PURE__ */ new Set();
    const pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
    for (let i = 0; i < TotalLanes; i++) {
      pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
    }
  }
  if (false) {
    if (disableLegacyMode) {
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    } else {
      switch (tag) {
        case ConcurrentRoot:
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
          break;
        case LegacyRoot:
          this._debugRootType = hydrate ? "hydrate()" : "render()";
          break;
      }
    }
  }
}
function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, transitionCallbacks) {
  const root2 = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    formState
  );
  if (enableSuspenseCallback) {
    root2.hydrationCallbacks = hydrationCallbacks;
  }
  if (enableTransitionTracing) {
    root2.transitionCallbacks = transitionCallbacks;
  }
  const uninitializedFiber = createHostRootFiber(tag, isStrictMode);
  root2.current = uninitializedFiber;
  uninitializedFiber.stateNode = root2;
  const initialCache = createCache();
  retainCache(initialCache);
  root2.pooledCache = initialCache;
  retainCache(initialCache);
  const initialState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: initialCache
  };
  uninitializedFiber.memoizedState = initialState;
  initializeUpdateQueue(uninitializedFiber);
  return root2;
}

// dist/react-reconciler/src/ReactFiberReconciler.js
if (false) {
  didWarnAboutNestedUpdates = false;
  didWarnAboutFindNodeInStrictMode = {};
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyContextObject;
  }
  const fiber = get(parentComponent);
  const parentContext = findCurrentUnmaskedContext(fiber);
  if (fiber.tag === ClassComponent) {
    const Component2 = fiber.type;
    if (isContextProvider(Component2)) {
      return processChildContext(fiber, Component2, parentContext);
    }
  }
  return parentContext;
}
function findHostInstance(component) {
  const fiber = get(component);
  if (fiber === void 0) {
    if (typeof component.render === "function") {
      throw new Error("Unable to find node on an unmounted component.");
    } else {
      const keys = Object.keys(component).join(",");
      throw new Error(
        `Argument appears to not be a ReactComponent. Keys: ${keys}`
      );
    }
  }
  const hostFiber = findCurrentHostFiber(fiber);
  if (hostFiber === null) {
    return null;
  }
  return (void 0)(hostFiber.stateNode);
}
function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, transitionCallbacks) {
  const hydrate = false;
  const initialChildren = null;
  const root2 = createFiberRoot(
    containerInfo,
    tag,
    hydrate,
    initialChildren,
    hydrationCallbacks,
    isStrictMode,
    identifierPrefix,
    null,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    transitionCallbacks
  );
  registerDefaultIndicator(onDefaultTransitionIndicator);
  return root2;
}
function updateContainer(element, container, parentComponent, callback) {
  const current2 = container.current;
  const lane = requestUpdateLane(current2);
  updateContainerImpl(
    current2,
    lane,
    element,
    container,
    parentComponent,
    callback
  );
  return lane;
}
function updateContainerSync(element, container, parentComponent, callback) {
  if (!disableLegacyMode && container.tag === LegacyRoot) {
    flushPendingEffects();
  }
  const current2 = container.current;
  updateContainerImpl(
    current2,
    SyncLane,
    element,
    container,
    parentComponent,
    callback
  );
  return SyncLane;
}
function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
  if (false) {
    onScheduleRoot(container, element);
  }
  if (enableSchedulingProfiler) {
    markRenderScheduled(lane);
  }
  const context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }
  if (false) {
    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
      didWarnAboutNestedUpdates = true;
      console.error(
        "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
        getComponentNameFromFiber(current) || "Unknown"
      );
    }
  }
  const update = createUpdate(lane);
  update.payload = { element };
  callback = callback === void 0 ? null : callback;
  if (callback !== null) {
    if (false) {
      if (typeof callback !== "function") {
        console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          callback
        );
      }
    }
    update.callback = callback;
  }
  const root2 = enqueueUpdate2(rootFiber, update, lane);
  if (root2 !== null) {
    startUpdateTimerByLane(lane, "root.render()");
    scheduleUpdateOnFiber(root2, rootFiber, lane);
    entangleTransitions(root2, rootFiber, lane);
  }
}
function attemptSynchronousHydration(fiber) {
  switch (fiber.tag) {
    case HostRoot: {
      const root2 = fiber.stateNode;
      if (isRootDehydrated(root2)) {
        const lanes = getHighestPriorityPendingLanes(root2);
        flushRoot(root2, lanes);
      }
      break;
    }
    case ActivityComponent:
    case SuspenseComponent: {
      const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
      if (root2 !== null) {
        scheduleUpdateOnFiber(root2, fiber, SyncLane);
      }
      flushSyncWork();
      const retryLane = SyncLane;
      markRetryLaneIfNotHydrated(fiber, retryLane);
      break;
    }
  }
}
function markRetryLaneImpl(fiber, retryLane) {
  const suspenseState = fiber.memoizedState;
  if (suspenseState !== null && suspenseState.dehydrated !== null) {
    suspenseState.retryLane = higherPriorityLane(
      suspenseState.retryLane,
      retryLane
    );
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  const alternate = fiber.alternate;
  if (alternate) {
    markRetryLaneImpl(alternate, retryLane);
  }
}
function attemptContinuousHydration(fiber) {
  if (fiber.tag !== SuspenseComponent && fiber.tag !== ActivityComponent) {
    return;
  }
  const lane = SelectiveHydrationLane;
  const root2 = enqueueConcurrentRenderForLane(fiber, lane);
  if (root2 !== null) {
    scheduleUpdateOnFiber(root2, fiber, lane);
  }
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptHydrationAtCurrentPriority(fiber) {
  if (fiber.tag !== SuspenseComponent && fiber.tag !== ActivityComponent) {
    return;
  }
  let lane = requestUpdateLane(fiber);
  if (enableHydrationLaneScheduling) {
    lane = getBumpedLaneForHydrationByLane(lane);
  }
  const root2 = enqueueConcurrentRenderForLane(fiber, lane);
  if (root2 !== null) {
    scheduleUpdateOnFiber(root2, fiber, lane);
  }
  markRetryLaneIfNotHydrated(fiber, lane);
}
if (false) {
  const copyWithDeleteImpl = (obj, path, index2) => {
    const key = path[index2];
    const updated = isArray_default(obj) ? obj.slice() : { ...obj };
    if (index2 + 1 === path.length) {
      if (isArray_default(updated)) {
        updated.splice(key, 1);
      } else {
        delete updated[key];
      }
      return updated;
    }
    updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
    return updated;
  };
  const copyWithDelete = (obj, path) => {
    return copyWithDeleteImpl(obj, path, 0);
  };
  const copyWithRenameImpl = (obj, oldPath, newPath, index2) => {
    const oldKey = oldPath[index2];
    const updated = isArray_default(obj) ? obj.slice() : { ...obj };
    if (index2 + 1 === oldPath.length) {
      const newKey = newPath[index2];
      updated[newKey] = updated[oldKey];
      if (isArray_default(updated)) {
        updated.splice(oldKey, 1);
      } else {
        delete updated[oldKey];
      }
    } else {
      updated[oldKey] = copyWithRenameImpl(
        // $FlowFixMe[incompatible-use] number or string is fine here
        obj[oldKey],
        oldPath,
        newPath,
        index2 + 1
      );
    }
    return updated;
  };
  const copyWithRename = (obj, oldPath, newPath) => {
    if (oldPath.length !== newPath.length) {
      console.warn("copyWithRename() expects paths of the same length");
      return;
    } else {
      for (let i = 0; i < newPath.length - 1; i++) {
        if (oldPath[i] !== newPath[i]) {
          console.warn(
            "copyWithRename() expects paths to be the same except for the deepest key"
          );
          return;
        }
      }
    }
    return copyWithRenameImpl(obj, oldPath, newPath, 0);
  };
  const copyWithSetImpl = (obj, path, index2, value) => {
    if (index2 >= path.length) {
      return value;
    }
    const key = path[index2];
    const updated = isArray_default(obj) ? obj.slice() : { ...obj };
    updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
    return updated;
  };
  const copyWithSet = (obj, path, value) => {
    return copyWithSetImpl(obj, path, 0, value);
  };
  const findHook = (fiber, id) => {
    let currentHook2 = fiber.memoizedState;
    while (currentHook2 !== null && id > 0) {
      currentHook2 = currentHook2.next;
      id--;
    }
    return currentHook2;
  };
  overrideHookState = (fiber, id, path, value) => {
    const hook = findHook(fiber, id);
    if (hook !== null) {
      const newState = copyWithSet(hook.memoizedState, path, value);
      hook.memoizedState = newState;
      hook.baseState = newState;
      fiber.memoizedProps = { ...fiber.memoizedProps };
      const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
      if (root2 !== null) {
        scheduleUpdateOnFiber(root2, fiber, SyncLane);
      }
    }
  };
  overrideHookStateDeletePath = (fiber, id, path) => {
    const hook = findHook(fiber, id);
    if (hook !== null) {
      const newState = copyWithDelete(hook.memoizedState, path);
      hook.memoizedState = newState;
      hook.baseState = newState;
      fiber.memoizedProps = { ...fiber.memoizedProps };
      const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
      if (root2 !== null) {
        scheduleUpdateOnFiber(root2, fiber, SyncLane);
      }
    }
  };
  overrideHookStateRenamePath = (fiber, id, oldPath, newPath) => {
    const hook = findHook(fiber, id);
    if (hook !== null) {
      const newState = copyWithRename(hook.memoizedState, oldPath, newPath);
      hook.memoizedState = newState;
      hook.baseState = newState;
      fiber.memoizedProps = { ...fiber.memoizedProps };
      const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
      if (root2 !== null) {
        scheduleUpdateOnFiber(root2, fiber, SyncLane);
      }
    }
  };
  overrideProps = (fiber, path, value) => {
    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }
    const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
    if (root2 !== null) {
      scheduleUpdateOnFiber(root2, fiber, SyncLane);
    }
  };
  overridePropsDeletePath = (fiber, path) => {
    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }
    const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
    if (root2 !== null) {
      scheduleUpdateOnFiber(root2, fiber, SyncLane);
    }
  };
  overridePropsRenamePath = (fiber, oldPath, newPath) => {
    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }
    const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
    if (root2 !== null) {
      scheduleUpdateOnFiber(root2, fiber, SyncLane);
    }
  };
  scheduleUpdate = (fiber) => {
    const root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
    if (root2 !== null) {
      scheduleUpdateOnFiber(root2, fiber, SyncLane);
    }
  };
  setErrorHandler = (newShouldErrorImpl) => {
    shouldErrorImpl = newShouldErrorImpl;
  };
  setSuspenseHandler = (newShouldSuspendImpl) => {
    shouldSuspendImpl = newShouldSuspendImpl;
  };
}
function getLaneLabelMap() {
  if (enableSchedulingProfiler) {
    const map = /* @__PURE__ */ new Map();
    let lane = 1;
    for (let index2 = 0; index2 < TotalLanes; index2++) {
      const label = getLabelForLane(lane);
      map.set(lane, label);
      lane *= 2;
    }
    return map;
  } else {
    return null;
  }
}
function injectIntoDevTools() {
  const internals = {
    bundleType: false ? 1 : 0,
    // Might add PROFILE later.
    version: void 0,
    rendererPackageName: void 0,
    currentDispatcherRef: ReactSharedInternals_default,
    // Enables DevTools to detect reconciler version rather than renderer version
    // which may not match for third party renderers.
    reconcilerVersion: ReactVersion_default
  };
  if (void 0 !== null) {
    internals.rendererConfig = void 0;
  }
  if (false) {
    internals.overrideHookState = overrideHookState;
    internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
    internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
    internals.overrideProps = overrideProps;
    internals.overridePropsDeletePath = overridePropsDeletePath;
    internals.overridePropsRenamePath = overridePropsRenamePath;
    internals.scheduleUpdate = scheduleUpdate;
    internals.setErrorHandler = setErrorHandler;
    internals.setSuspenseHandler = setSuspenseHandler;
    internals.scheduleRefresh = scheduleRefresh;
    internals.scheduleRoot = scheduleRoot;
    internals.setRefreshHandler = setRefreshHandler;
    internals.getCurrentFiber = getCurrentFiberForDevTools;
  }
  if (enableSchedulingProfiler) {
    internals.getLaneLabelMap = getLaneLabelMap;
    internals.injectProfilingHooks = injectProfilingHooks;
  }
  return injectInternals(internals);
}

// dist/react-dom-bindings/src/events/EventSystemFlags.js
var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
var IS_NON_DELEGATED = 1 << 1;
var IS_CAPTURE_PHASE = 1 << 2;
var IS_PASSIVE = 1 << 3;
var IS_LEGACY_FB_SUPPORT_MODE = 1 << 4;
var SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE = IS_LEGACY_FB_SUPPORT_MODE | IS_CAPTURE_PHASE;
var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;

// dist/react-dom-bindings/src/events/getEventTarget.js
function getEventTarget(nativeEvent) {
  let target = nativeEvent.target || nativeEvent.srcElement || window;
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}
var getEventTarget_default = getEventTarget;

// dist/react-dom/src/ReactDOMSharedInternals.js
var NoEventPriority2 = 0;
function requestFormReset2(element) {
  throw new Error(
    "Invalid form element. requestFormReset must be passed a form that was rendered by React."
  );
}
var DefaultDispatcher = {
  f: noop,
  r: requestFormReset2,
  D: noop,
  C: noop,
  L: noop,
  m: noop,
  X: noop,
  S: noop,
  M: noop
};
var Internals = {
  d: DefaultDispatcher,
  p: NoEventPriority2,
  findDOMNode: null
};
var ReactDOMSharedInternals_default = Internals;

// dist/react-dom/src/shared/ReactDOM.js
if (false) {
  if (typeof Map !== "function" || // $FlowFixMe[prop-missing] Flow incorrectly thinks Map has no prototype
  Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowFixMe[prop-missing] Flow incorrectly thinks Set has no prototype
  Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
    console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
    );
  }
}

// dist/shared/ReactDOMSharedInternals.js
var ReactDOMSharedInternals = ReactDOMSharedInternals_default;
var ReactDOMSharedInternals_default2 = ReactDOMSharedInternals;

// dist/react-dom-bindings/src/shared/ReactDOMFormActions.js
var sharedNotPendingObject = {
  pending: false,
  data: null,
  method: null,
  action: null
};
var NotPending = false ? Object.freeze(sharedNotPendingObject) : sharedNotPendingObject;

// dist/react-dom-bindings/src/client/ReactDOMSrcObject.js
function setSrcObject(domElement, tag, value) {
  const url = URL.createObjectURL(value);
  const loadEvent = tag === "img" ? "load" : "loadstart";
  const cleanUp = () => {
    URL.revokeObjectURL(url);
    domElement.removeEventListener(loadEvent, cleanUp);
    domElement.removeEventListener("error", cleanUp);
  };
  domElement.addEventListener(loadEvent, cleanUp);
  domElement.addEventListener("error", cleanUp);
  domElement.setAttribute("src", url);
}

// dist/react-dom-bindings/src/client/ReactDOMUpdatePriority.js
function setCurrentUpdatePriority3(newPriority, IntentionallyUnusedArgument) {
  ReactDOMSharedInternals_default2.p = newPriority;
}
function getCurrentUpdatePriority3() {
  return ReactDOMSharedInternals_default2.p;
}
function resolveUpdatePriority2() {
  const updatePriority = ReactDOMSharedInternals_default2.p;
  if (updatePriority !== NoEventPriority) {
    return updatePriority;
  }
  const currentEvent = window.event;
  if (currentEvent === void 0) {
    return DefaultEventPriority;
  }
  return getEventPriority(currentEvent.type);
}
function runWithPriority(priority, fn) {
  const previousPriority = getCurrentUpdatePriority3();
  try {
    setCurrentUpdatePriority3(priority);
    return fn();
  } finally {
    setCurrentUpdatePriority3(previousPriority);
  }
}

// dist/react-dom-bindings/src/events/EventRegistry.js
var allNativeEvents = /* @__PURE__ */ new Set();
if (enableCreateEventHandleAPI) {
  allNativeEvents.add("beforeblur");
  allNativeEvents.add("afterblur");
}
var registrationNameDependencies = {};
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  if (false) {
    if (registrationNameDependencies[registrationName]) {
      console.error(
        "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
        registrationName
      );
    }
  }
  registrationNameDependencies[registrationName] = dependencies;
  if (false) {
    const lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;
    if (registrationName === "onDoubleClick") {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
  for (let i = 0; i < dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]);
  }
}

// dist/react-dom-bindings/src/shared/isAttributeNameSafe.js
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(
  "^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$"
);
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty_default.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }
  if (hasOwnProperty_default.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  if (false) {
    console.error("Invalid attribute name: `%s`", attributeName);
  }
  return false;
}

// dist/react-dom-bindings/src/client/DOMPropertyOperations.js
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name)) {
    if (value === null) {
      node.removeAttribute(name);
      return;
    }
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
        node.removeAttribute(name);
        return;
      case "boolean": {
        const prefix2 = name.toLowerCase().slice(0, 5);
        if (prefix2 !== "data-" && prefix2 !== "aria-") {
          node.removeAttribute(name);
          return;
        }
      }
    }
    if (false) {
      checkAttributeStringCoercion(value, name);
    }
    node.setAttribute(
      name,
      enableTrustedTypesIntegration ? value : "" + value
    );
  }
}
function setValueForKnownAttribute(node, name, value) {
  if (value === null) {
    node.removeAttribute(name);
    return;
  }
  switch (typeof value) {
    case "undefined":
    case "function":
    case "symbol":
    case "boolean": {
      node.removeAttribute(name);
      return;
    }
  }
  if (false) {
    checkAttributeStringCoercion(value, name);
  }
  node.setAttribute(
    name,
    enableTrustedTypesIntegration ? value : "" + value
  );
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (value === null) {
    node.removeAttribute(name);
    return;
  }
  switch (typeof value) {
    case "undefined":
    case "function":
    case "symbol":
    case "boolean": {
      node.removeAttribute(name);
      return;
    }
  }
  if (false) {
    checkAttributeStringCoercion(value, name);
  }
  node.setAttributeNS(
    namespace,
    name,
    enableTrustedTypesIntegration ? value : "" + value
  );
}
function setValueForPropertyOnCustomComponent(node, name, value) {
  if (name[0] === "o" && name[1] === "n") {
    const useCapture = name.endsWith("Capture");
    const eventName = name.slice(2, useCapture ? name.length - 7 : void 0);
    const prevProps = getFiberCurrentPropsFromNode(node);
    const prevValue = prevProps != null ? prevProps[name] : null;
    if (typeof prevValue === "function") {
      node.removeEventListener(eventName, prevValue, useCapture);
    }
    if (typeof value === "function") {
      if (typeof prevValue !== "function" && prevValue !== null) {
        if (name in node) {
          node[name] = null;
        } else if (node.hasAttribute(name)) {
          node.removeAttribute(name);
        }
      }
      node.addEventListener(eventName, value, useCapture);
      return;
    }
  }
  trackHostMutation();
  if (name in node) {
    node[name] = value;
    return;
  }
  if (value === true) {
    node.setAttribute(name, "");
    return;
  }
  setValueForAttribute(node, name, value);
}

// dist/react-dom-bindings/src/client/ToStringValue.js
function toString(value) {
  return "" + value;
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      if (false) {
        checkFormFieldValueStringCoercion(value);
      }
      return value;
    default:
      return "";
  }
}

// dist/react-dom-bindings/src/client/inputValueTracking.js
function isCheckable(elem) {
  const type = elem.type;
  const nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
}
function getTracker(node) {
  return node._valueTracker;
}
function detachTracker(node) {
  node._valueTracker = null;
}
function getValueFromNode(node) {
  let value = "";
  if (!node) {
    return value;
  }
  if (isCheckable(node)) {
    value = node.checked ? "true" : "false";
  } else {
    value = node.value;
  }
  return value;
}
function trackValueOnNode(node, valueField, currentValue) {
  const descriptor = Object.getOwnPropertyDescriptor(
    node.constructor.prototype,
    valueField
  );
  if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
    return;
  }
  const { get: get2, set: set2 } = descriptor;
  Object.defineProperty(node, valueField, {
    configurable: true,
    // $FlowFixMe[missing-this-annot]
    get: function() {
      return get2.call(this);
    },
    // $FlowFixMe[missing-local-annot]
    // $FlowFixMe[missing-this-annot]
    set: function(value) {
      if (false) {
        checkFormFieldValueStringCoercion(value);
      }
      currentValue = "" + value;
      set2.call(this, value);
    }
  });
  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable
  });
  const tracker = {
    getValue() {
      return currentValue;
    },
    setValue(value) {
      if (false) {
        checkFormFieldValueStringCoercion(value);
      }
      currentValue = "" + value;
    },
    stopTracking() {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}
function track(node) {
  if (getTracker(node)) {
    return;
  }
  const valueField = isCheckable(node) ? "checked" : "value";
  const initialValue = "" + node[valueField];
  node._valueTracker = trackValueOnNode(node, valueField, initialValue);
}
function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }
  const tracker = getTracker(node);
  if (!tracker) {
    return true;
  }
  const lastValue = tracker.getValue();
  const nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

// dist/react-dom-bindings/src/client/getActiveElement.js
function getActiveElement(doc) {
  doc = doc || (typeof document !== "undefined" ? document : void 0);
  if (typeof doc === "undefined") {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

// dist/react-dom-bindings/src/client/escapeSelectorAttributeValueInsideDoubleQuotes.js
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n\"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(
    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
    (ch) => "\\" + ch.charCodeAt(0).toString(16) + " "
  );
}

// dist/react-dom-bindings/src/client/ReactDOMInput.js
function validateInputProps(element, props) {
  if (false) {
    if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
      console.error(
        "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        getCurrentFiberOwnerNameInDevOrNull() || "A component",
        props.type
      );
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
      console.error(
        "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        getCurrentFiberOwnerNameInDevOrNull() || "A component",
        props.type
      );
      didWarnValueDefaultValue = true;
    }
  }
}
function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
  const node = element;
  node.name = "";
  if (type != null && typeof type !== "function" && typeof type !== "symbol" && typeof type !== "boolean") {
    if (false) {
      checkAttributeStringCoercion(type, "type");
    }
    node.type = type;
  } else {
    node.removeAttribute("type");
  }
  if (value != null) {
    if (type === "number") {
      if (
        // $FlowFixMe[incompatible-type]
        value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        node.value != value
      ) {
        node.value = toString(getToStringValue(value));
      }
    } else if (node.value !== toString(getToStringValue(value))) {
      node.value = toString(getToStringValue(value));
    }
  } else if (type === "submit" || type === "reset") {
    node.removeAttribute("value");
  }
  if (disableInputAttributeSyncing) {
    if (defaultValue != null) {
      setDefaultValue(node, type, getToStringValue(defaultValue));
    } else if (lastDefaultValue != null) {
      node.removeAttribute("value");
    }
  } else {
    if (value != null) {
      setDefaultValue(node, type, getToStringValue(value));
    } else if (defaultValue != null) {
      setDefaultValue(node, type, getToStringValue(defaultValue));
    } else if (lastDefaultValue != null) {
      node.removeAttribute("value");
    }
  }
  if (disableInputAttributeSyncing) {
    if (defaultChecked == null) {
      node.removeAttribute("checked");
    } else {
      node.defaultChecked = !!defaultChecked;
    }
  } else {
    if (checked == null && defaultChecked != null) {
      node.defaultChecked = !!defaultChecked;
    }
  }
  if (checked != null) {
    node.checked = checked && typeof checked !== "function" && typeof checked !== "symbol";
  }
  if (name != null && typeof name !== "function" && typeof name !== "symbol" && typeof name !== "boolean") {
    if (false) {
      checkAttributeStringCoercion(name, "name");
    }
    node.name = toString(getToStringValue(name));
  } else {
    node.removeAttribute("name");
  }
}
function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
  const node = element;
  if (type != null && typeof type !== "function" && typeof type !== "symbol" && typeof type !== "boolean") {
    if (false) {
      checkAttributeStringCoercion(type, "type");
    }
    node.type = type;
  }
  if (value != null || defaultValue != null) {
    const isButton = type === "submit" || type === "reset";
    if (isButton && (value === void 0 || value === null)) {
      track(element);
      return;
    }
    const defaultValueStr = defaultValue != null ? toString(getToStringValue(defaultValue)) : "";
    const initialValue = value != null ? toString(getToStringValue(value)) : defaultValueStr;
    if (!isHydrating2 || enableHydrationChangeEvent) {
      if (disableInputAttributeSyncing) {
        if (value != null) {
          if (isButton || toString(getToStringValue(value)) !== node.value) {
            node.value = toString(getToStringValue(value));
          }
        }
      } else {
        if (initialValue !== node.value) {
          node.value = initialValue;
        }
      }
    }
    if (disableInputAttributeSyncing) {
      if (defaultValue != null) {
        node.defaultValue = defaultValueStr;
      }
    } else {
      node.defaultValue = initialValue;
    }
  }
  const checkedOrDefault = checked != null ? checked : defaultChecked;
  const initialChecked = typeof checkedOrDefault !== "function" && typeof checkedOrDefault !== "symbol" && !!checkedOrDefault;
  if (isHydrating2 && !enableHydrationChangeEvent) {
    node.checked = node.checked;
  } else {
    node.checked = !!initialChecked;
  }
  if (disableInputAttributeSyncing) {
    if (defaultChecked != null) {
      node.defaultChecked = !node.defaultChecked;
      node.defaultChecked = !!defaultChecked;
    }
  } else {
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !!initialChecked;
  }
  if (name != null && typeof name !== "function" && typeof name !== "symbol" && typeof name !== "boolean") {
    if (false) {
      checkAttributeStringCoercion(name, "name");
    }
    node.name = name;
  }
  track(element);
}
function restoreControlledInputState(element, props) {
  const rootNode = element;
  updateInput(
    rootNode,
    props.value,
    props.defaultValue,
    props.defaultValue,
    props.checked,
    props.defaultChecked,
    props.type,
    props.name
  );
  const name = props.name;
  if (props.type === "radio" && name != null) {
    let queryRoot = rootNode;
    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }
    if (false) {
      checkAttributeStringCoercion(name, "name");
    }
    const group = queryRoot.querySelectorAll(
      'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + name) + '"][type="radio"]'
    );
    for (let i = 0; i < group.length; i++) {
      const otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      const otherProps = getFiberCurrentPropsFromNode(otherNode);
      if (!otherProps) {
        throw new Error(
          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
        );
      }
      updateInput(
        otherNode,
        otherProps.value,
        otherProps.defaultValue,
        otherProps.defaultValue,
        otherProps.checked,
        otherProps.defaultChecked,
        otherProps.type,
        otherProps.name
      );
    }
    for (let i = 0; i < group.length; i++) {
      const otherNode = group[i];
      if (otherNode.form !== rootNode.form) {
        continue;
      }
      updateValueIfChanged(otherNode);
    }
  }
}
function setDefaultValue(node, type, value) {
  if (
    // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
    type !== "number" || getActiveElement(node.ownerDocument) !== node
  ) {
    if (node.defaultValue !== toString(value)) {
      node.defaultValue = toString(value);
    }
  }
}

// dist/react-dom-bindings/src/client/ReactDOMOption.js
function validateOptionProps(element, props) {
  if (false) {
    if (props.value == null) {
      if (typeof props.children === "object" && props.children !== null) {
        Children.forEach(props.children, function(child) {
          if (child == null) {
            return;
          }
          if (typeof child === "string" || typeof child === "number" || typeof child === "bigint") {
            return;
          }
          if (!didWarnInvalidChild) {
            didWarnInvalidChild = true;
            console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            );
          }
        });
      } else if (props.dangerouslySetInnerHTML != null) {
        if (!didWarnInvalidInnerHTML) {
          didWarnInvalidInnerHTML = true;
          console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          );
        }
      }
    }
    if (props.selected != null && !didWarnSelectedSetOnOption) {
      console.error(
        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
      );
      didWarnSelectedSetOnOption = true;
    }
  }
}

// dist/react-dom-bindings/src/client/ReactDOMSelect.js
if (false) {
  didWarnValueDefaultValue = false;
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  const options = node.options;
  if (multiple) {
    const selectedValues = propValue;
    const selectedValue = {};
    for (let i = 0; i < selectedValues.length; i++) {
      selectedValue["$" + selectedValues[i]] = true;
    }
    for (let i = 0; i < options.length; i++) {
      const selected = selectedValue.hasOwnProperty("$" + options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[i].defaultSelected = true;
      }
    }
  } else {
    const selectedValue = toString(getToStringValue(propValue));
    let defaultSelected = null;
    for (let i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        if (setDefaultSelected) {
          options[i].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[i].disabled) {
        defaultSelected = options[i];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}
function validateSelectProps(element, props) {
  if (false) {
    checkSelectPropTypes(props);
    if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
      console.error(
        "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
      );
      didWarnValueDefaultValue = true;
    }
  }
}
function initSelect(element, value, defaultValue, multiple) {
  const node = element;
  node.multiple = !!multiple;
  if (value != null) {
    updateOptions(node, !!multiple, value, false);
  } else if (defaultValue != null) {
    updateOptions(node, !!multiple, defaultValue, true);
  }
}
function restoreControlledSelectState(element, props) {
  const node = element;
  const value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

// dist/react-dom-bindings/src/client/ReactDOMTextarea.js
function validateTextareaProps(element, props) {
  if (false) {
    if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
      console.error(
        "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
        getCurrentFiberOwnerNameInDevOrNull() || "A component"
      );
      didWarnValDefaultVal = true;
    }
    if (props.children != null && props.value == null) {
      console.error(
        "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
      );
    }
  }
}
function updateTextarea(element, value, defaultValue) {
  const node = element;
  if (value != null) {
    const newValue = toString(getToStringValue(value));
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (defaultValue == null) {
      if (node.defaultValue !== newValue) {
        node.defaultValue = newValue;
      }
      return;
    }
  }
  if (defaultValue != null) {
    node.defaultValue = toString(getToStringValue(defaultValue));
  } else {
    node.defaultValue = "";
  }
}
function initTextarea(element, value, defaultValue, children) {
  const node = element;
  let initialValue = value;
  if (initialValue == null) {
    if (children != null) {
      if (!disableTextareaChildren) {
        if (defaultValue != null) {
          throw new Error(
            "If you supply `defaultValue` on a <textarea>, do not pass children."
          );
        }
        if (isArray_default(children)) {
          if (children.length > 1) {
            throw new Error("<textarea> can only have at most one child.");
          }
          children = children[0];
        }
        defaultValue = children;
      }
    }
    if (defaultValue == null) {
      defaultValue = "";
    }
    initialValue = defaultValue;
  }
  const stringValue = getToStringValue(initialValue);
  node.defaultValue = stringValue;
  const textContent = node.textContent;
  if (textContent === stringValue) {
    if (textContent !== "" && textContent !== null) {
      node.value = textContent;
    }
  }
  track(element);
}
function restoreControlledTextareaState(element, props) {
  updateTextarea(element, props.value, props.defaultValue);
}

// dist/react-dom-bindings/src/client/validateDOMNesting.js
var buttonScopeTags = false ? inScopeTags.concat(["button"]) : [];

// dist/react-dom-bindings/src/client/setTextContent.js
function setTextContent(node, text) {
  if (text) {
    const firstChild = node.firstChild;
    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
var setTextContent_default = setTextContent;

// dist/react-dom-bindings/src/shared/isUnitlessNumber.js
var unitlessNumbers = /* @__PURE__ */ new Set([
  "animationIterationCount",
  "aspectRatio",
  "borderImageOutset",
  "borderImageSlice",
  "borderImageWidth",
  "boxFlex",
  "boxFlexGroup",
  "boxOrdinalGroup",
  "columnCount",
  "columns",
  "flex",
  "flexGrow",
  "flexPositive",
  "flexShrink",
  "flexNegative",
  "flexOrder",
  "gridArea",
  "gridRow",
  "gridRowEnd",
  "gridRowSpan",
  "gridRowStart",
  "gridColumn",
  "gridColumnEnd",
  "gridColumnSpan",
  "gridColumnStart",
  "fontWeight",
  "lineClamp",
  "lineHeight",
  "opacity",
  "order",
  "orphans",
  "scale",
  "tabSize",
  "widows",
  "zIndex",
  "zoom",
  "fillOpacity",
  // SVG-related properties
  "floodOpacity",
  "stopOpacity",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "MozAnimationIterationCount",
  // Known Prefixed Properties
  "MozBoxFlex",
  // TODO: Remove these since they shouldn't be used in modern code
  "MozBoxFlexGroup",
  "MozLineClamp",
  "msAnimationIterationCount",
  "msFlex",
  "msZoom",
  "msFlexGrow",
  "msFlexNegative",
  "msFlexOrder",
  "msFlexPositive",
  "msFlexShrink",
  "msGridColumn",
  "msGridColumnSpan",
  "msGridRow",
  "msGridRowSpan",
  "WebkitAnimationIterationCount",
  "WebkitBoxFlex",
  "WebKitBoxFlexGroup",
  "WebkitBoxOrdinalGroup",
  "WebkitColumnCount",
  "WebkitColumns",
  "WebkitFlex",
  "WebkitFlexGrow",
  "WebkitFlexPositive",
  "WebkitFlexShrink",
  "WebkitLineClamp"
]);
function isUnitlessNumber_default(name) {
  return unitlessNumbers.has(name);
}

// dist/react-dom-bindings/src/client/CSSPropertyOperations.js
function setValueForStyle(style2, styleName, value) {
  const isCustomProperty = styleName.indexOf("--") === 0;
  if (false) {
    if (!isCustomProperty) {
      warnValidStyle_default(styleName, value);
    }
  }
  if (value == null || typeof value === "boolean" || value === "") {
    if (isCustomProperty) {
      style2.setProperty(styleName, "");
    } else if (styleName === "float") {
      style2.cssFloat = "";
    } else {
      style2[styleName] = "";
    }
  } else if (isCustomProperty) {
    style2.setProperty(styleName, value);
  } else if (typeof value === "number" && value !== 0 && !isUnitlessNumber_default(styleName)) {
    style2[styleName] = value + "px";
  } else {
    if (styleName === "float") {
      style2.cssFloat = value;
    } else {
      if (false) {
        checkCSSPropertyStringCoercion(value, styleName);
      }
      style2[styleName] = ("" + value).trim();
    }
  }
}
function setValueForStyles(node, styles, prevStyles) {
  if (styles != null && typeof styles !== "object") {
    throw new Error(
      "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
    );
  }
  if (false) {
    if (styles) {
      Object.freeze(styles);
    }
  }
  const style2 = node.style;
  if (prevStyles != null) {
    if (false) {
      validateShorthandPropertyCollisionInDev(prevStyles, styles);
    }
    for (const styleName in prevStyles) {
      if (prevStyles.hasOwnProperty(styleName) && (styles == null || !styles.hasOwnProperty(styleName))) {
        const isCustomProperty = styleName.indexOf("--") === 0;
        if (isCustomProperty) {
          style2.setProperty(styleName, "");
        } else if (styleName === "float") {
          style2.cssFloat = "";
        } else {
          style2[styleName] = "";
        }
        trackHostMutation();
      }
    }
    for (const styleName in styles) {
      const value = styles[styleName];
      if (styles.hasOwnProperty(styleName) && prevStyles[styleName] !== value) {
        setValueForStyle(style2, styleName, value);
        trackHostMutation();
      }
    }
  } else {
    for (const styleName in styles) {
      if (styles.hasOwnProperty(styleName)) {
        const value = styles[styleName];
        setValueForStyle(style2, styleName, value);
      }
    }
  }
}

// dist/react-dom-bindings/src/shared/isCustomElement.js
function isCustomElement(tagName, props) {
  if (tagName.indexOf("-") === -1) {
    return false;
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this list too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-core-concepts
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var isCustomElement_default = isCustomElement;

// dist/react-dom-bindings/src/shared/getAttributeAlias.js
var aliases = /* @__PURE__ */ new Map([
  ["acceptCharset", "accept-charset"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
  // HTML and SVG attributes, but the SVG attribute is case sensitive.],
  ["crossOrigin", "crossorigin"],
  // This is a list of all SVG attributes that need special casing.
  // Regular attributes that just accept strings.],
  ["accentHeight", "accent-height"],
  ["alignmentBaseline", "alignment-baseline"],
  ["arabicForm", "arabic-form"],
  ["baselineShift", "baseline-shift"],
  ["capHeight", "cap-height"],
  ["clipPath", "clip-path"],
  ["clipRule", "clip-rule"],
  ["colorInterpolation", "color-interpolation"],
  ["colorInterpolationFilters", "color-interpolation-filters"],
  ["colorProfile", "color-profile"],
  ["colorRendering", "color-rendering"],
  ["dominantBaseline", "dominant-baseline"],
  ["enableBackground", "enable-background"],
  ["fillOpacity", "fill-opacity"],
  ["fillRule", "fill-rule"],
  ["floodColor", "flood-color"],
  ["floodOpacity", "flood-opacity"],
  ["fontFamily", "font-family"],
  ["fontSize", "font-size"],
  ["fontSizeAdjust", "font-size-adjust"],
  ["fontStretch", "font-stretch"],
  ["fontStyle", "font-style"],
  ["fontVariant", "font-variant"],
  ["fontWeight", "font-weight"],
  ["glyphName", "glyph-name"],
  ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
  ["glyphOrientationVertical", "glyph-orientation-vertical"],
  ["horizAdvX", "horiz-adv-x"],
  ["horizOriginX", "horiz-origin-x"],
  ["imageRendering", "image-rendering"],
  ["letterSpacing", "letter-spacing"],
  ["lightingColor", "lighting-color"],
  ["markerEnd", "marker-end"],
  ["markerMid", "marker-mid"],
  ["markerStart", "marker-start"],
  ["overlinePosition", "overline-position"],
  ["overlineThickness", "overline-thickness"],
  ["paintOrder", "paint-order"],
  ["panose-1", "panose-1"],
  ["pointerEvents", "pointer-events"],
  ["renderingIntent", "rendering-intent"],
  ["shapeRendering", "shape-rendering"],
  ["stopColor", "stop-color"],
  ["stopOpacity", "stop-opacity"],
  ["strikethroughPosition", "strikethrough-position"],
  ["strikethroughThickness", "strikethrough-thickness"],
  ["strokeDasharray", "stroke-dasharray"],
  ["strokeDashoffset", "stroke-dashoffset"],
  ["strokeLinecap", "stroke-linecap"],
  ["strokeLinejoin", "stroke-linejoin"],
  ["strokeMiterlimit", "stroke-miterlimit"],
  ["strokeOpacity", "stroke-opacity"],
  ["strokeWidth", "stroke-width"],
  ["textAnchor", "text-anchor"],
  ["textDecoration", "text-decoration"],
  ["textRendering", "text-rendering"],
  ["transformOrigin", "transform-origin"],
  ["underlinePosition", "underline-position"],
  ["underlineThickness", "underline-thickness"],
  ["unicodeBidi", "unicode-bidi"],
  ["unicodeRange", "unicode-range"],
  ["unitsPerEm", "units-per-em"],
  ["vAlphabetic", "v-alphabetic"],
  ["vHanging", "v-hanging"],
  ["vIdeographic", "v-ideographic"],
  ["vMathematical", "v-mathematical"],
  ["vectorEffect", "vector-effect"],
  ["vertAdvY", "vert-adv-y"],
  ["vertOriginX", "vert-origin-x"],
  ["vertOriginY", "vert-origin-y"],
  ["wordSpacing", "word-spacing"],
  ["writingMode", "writing-mode"],
  ["xmlnsXlink", "xmlns:xlink"],
  ["xHeight", "x-height"]
]);
function getAttributeAlias_default(name) {
  return aliases.get(name) || name;
}

// dist/react-dom-bindings/src/shared/ReactDOMInvalidARIAHook.js
var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");

// dist/react-dom-bindings/src/shared/ReactDOMUnknownPropertyHook.js
var rARIA2 = false ? new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$") : null;
var rARIACamel2 = false ? new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$") : null;

// dist/react-dom-bindings/src/shared/sanitizeURL.js
var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
function sanitizeURL(url) {
  if (isJavaScriptProtocol.test("" + url)) {
    return "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')";
  }
  return url;
}
var sanitizeURL_default = sanitizeURL;

// dist/react-dom-bindings/src/events/CurrentReplayingEvent.js
var currentReplayingEvent = null;
function isReplayingEvent(event) {
  return event === currentReplayingEvent;
}

// dist/react-dom-bindings/src/events/ReactDOMControlledComponent.js
var restoreTarget = null;
var restoreQueue = null;
function restoreStateOfTarget(target) {
  const internalInstance = getInstanceFromNode3(target);
  if (!internalInstance) {
    return;
  }
  const stateNode = internalInstance.stateNode;
  if (stateNode) {
    const props = getFiberCurrentPropsFromNode(stateNode);
    restoreControlledState(
      internalInstance.stateNode,
      internalInstance.type,
      props
    );
  }
}
function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}
function needsStateRestore() {
  return restoreTarget !== null || restoreQueue !== null;
}
function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  const target = restoreTarget;
  const queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;
  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (let i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

// dist/react-dom-bindings/src/events/ReactDOMUpdateBatching.js
var isInsideEventHandler = false;
function finishEventHandler() {
  const controlledComponentsHavePendingUpdates = needsStateRestore();
  if (controlledComponentsHavePendingUpdates) {
    flushSyncWork();
    restoreStateIfNeeded();
  }
}
function batchedUpdates3(fn, a, b) {
  if (isInsideEventHandler) {
    return fn(a, b);
  }
  isInsideEventHandler = true;
  try {
    return batchedUpdates(fn, a, b);
  } finally {
    isInsideEventHandler = false;
    finishEventHandler();
  }
}

// dist/react-dom-bindings/src/events/getListener.js
function isInteractive(tag) {
  return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
}
function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}
function getListener(inst, registrationName) {
  const stateNode = inst.stateNode;
  if (stateNode === null) {
    return null;
  }
  const props = getFiberCurrentPropsFromNode(stateNode);
  if (props === null) {
    return null;
  }
  const listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  if (listener && typeof listener !== "function") {
    throw new Error(
      `Expected \`${registrationName}\` listener to be a function, instead got a value of \`${typeof listener}\` type.`
    );
  }
  return listener;
}

// dist/shared/ExecutionEnvironment.js
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");

// dist/react-dom-bindings/src/events/checkPassiveEvents.js
var passiveBrowserEventsSupported = false;
if (canUseDOM) {
  try {
    const options = {};
    Object.defineProperty(options, "passive", {
      get: function() {
        passiveBrowserEventsSupported = true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (e) {
    passiveBrowserEventsSupported = false;
  }
}

// dist/react-dom-bindings/src/events/EventListener.js
function addEventBubbleListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, false);
  return listener;
}
function addEventCaptureListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, true);
  return listener;
}
function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    capture: true,
    passive
  });
  return listener;
}
function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    passive
  });
  return listener;
}
function removeEventListener(target, eventType, listener, capture) {
  target.removeEventListener(eventType, listener, capture);
}

// dist/react-dom-bindings/src/events/FallbackCompositionState.js
var root = null;
var startText = null;
var fallbackText = null;
function initialize(nativeEventTarget) {
  root = nativeEventTarget;
  startText = getText();
  return true;
}
function reset() {
  root = null;
  startText = null;
  fallbackText = null;
}
function getData() {
  if (fallbackText) {
    return fallbackText;
  }
  let start;
  const startValue = startText;
  const startLength = startValue.length;
  let end;
  const endValue = getText();
  const endLength = endValue.length;
  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }
  const minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }
  const sliceTail = end > 1 ? 1 - end : void 0;
  fallbackText = endValue.slice(start, sliceTail);
  return fallbackText;
}
function getText() {
  if ("value" in root) {
    return root.value;
  }
  return root.textContent;
}

// dist/react-dom-bindings/src/events/getEventCharCode.js
function getEventCharCode(nativeEvent) {
  let charCode;
  const keyCode = nativeEvent.keyCode;
  if ("charCode" in nativeEvent) {
    charCode = nativeEvent.charCode;
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    charCode = keyCode;
  }
  if (charCode === 10) {
    charCode = 13;
  }
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }
  return 0;
}
var getEventCharCode_default = getEventCharCode;

// dist/react-dom-bindings/src/events/SyntheticEvent.js
function functionThatReturnsTrue() {
  return true;
}
function functionThatReturnsFalse() {
  return false;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (const propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      const normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
    const defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = functionThatReturnsTrue;
    } else {
      this.isDefaultPrevented = functionThatReturnsFalse;
    }
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign_default(SyntheticBaseEvent.prototype, {
    // $FlowFixMe[missing-this-annot]
    preventDefault: function() {
      this.defaultPrevented = true;
      const event = this.nativeEvent;
      if (!event) {
        return;
      }
      if (event.preventDefault) {
        event.preventDefault();
      } else if (typeof event.returnValue !== "unknown") {
        event.returnValue = false;
      }
      this.isDefaultPrevented = functionThatReturnsTrue;
    },
    // $FlowFixMe[missing-this-annot]
    stopPropagation: function() {
      const event = this.nativeEvent;
      if (!event) {
        return;
      }
      if (event.stopPropagation) {
        event.stopPropagation();
      } else if (typeof event.cancelBubble !== "unknown") {
        event.cancelBubble = true;
      }
      this.isPropagationStopped = functionThatReturnsTrue;
    },
    /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */
    persist: function() {
    },
    /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
var EventInterface = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
};
var SyntheticEvent = createSyntheticEvent(EventInterface);
var UIEventInterface = {
  ...EventInterface,
  view: 0,
  detail: 0
};
var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
var lastMovementX;
var lastMovementY;
var lastMouseEvent;
function updateMouseMovementPolyfillState(event) {
  if (event !== lastMouseEvent) {
    if (lastMouseEvent && event.type === "mousemove") {
      lastMovementX = event.screenX - lastMouseEvent.screenX;
      lastMovementY = event.screenY - lastMouseEvent.screenY;
    } else {
      lastMovementX = 0;
      lastMovementY = 0;
    }
    lastMouseEvent = event;
  }
}
var MouseEventInterface = {
  ...UIEventInterface,
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: getEventModifierState,
  button: 0,
  buttons: 0,
  relatedTarget: function(event) {
    if (event.relatedTarget === void 0)
      return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
    return event.relatedTarget;
  },
  movementX: function(event) {
    if ("movementX" in event) {
      return event.movementX;
    }
    updateMouseMovementPolyfillState(event);
    return lastMovementX;
  },
  movementY: function(event) {
    if ("movementY" in event) {
      return event.movementY;
    }
    return lastMovementY;
  }
};
var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
var DragEventInterface = {
  ...MouseEventInterface,
  dataTransfer: 0
};
var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
var FocusEventInterface = {
  ...UIEventInterface,
  relatedTarget: 0
};
var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
var AnimationEventInterface = {
  ...EventInterface,
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
};
var SyntheticAnimationEvent = createSyntheticEvent(
  AnimationEventInterface
);
var ClipboardEventInterface = {
  ...EventInterface,
  clipboardData: function(event) {
    return "clipboardData" in event ? event.clipboardData : window.clipboardData;
  }
};
var SyntheticClipboardEvent = createSyntheticEvent(
  ClipboardEventInterface
);
var CompositionEventInterface = {
  ...EventInterface,
  data: 0
};
var SyntheticCompositionEvent = createSyntheticEvent(
  CompositionEventInterface
);
var SyntheticInputEvent = SyntheticCompositionEvent;
var normalizeKey = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
};
var translateToKey = {
  "8": "Backspace",
  "9": "Tab",
  "12": "Clear",
  "13": "Enter",
  "16": "Shift",
  "17": "Control",
  "18": "Alt",
  "19": "Pause",
  "20": "CapsLock",
  "27": "Escape",
  "32": " ",
  "33": "PageUp",
  "34": "PageDown",
  "35": "End",
  "36": "Home",
  "37": "ArrowLeft",
  "38": "ArrowUp",
  "39": "ArrowRight",
  "40": "ArrowDown",
  "45": "Insert",
  "46": "Delete",
  "112": "F1",
  "113": "F2",
  "114": "F3",
  "115": "F4",
  "116": "F5",
  "117": "F6",
  "118": "F7",
  "119": "F8",
  "120": "F9",
  "121": "F10",
  "122": "F11",
  "123": "F12",
  "144": "NumLock",
  "145": "ScrollLock",
  "224": "Meta"
};
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    const key = (
      // $FlowFixMe[invalid-computed-prop] unable to index with a `mixed` value
      normalizeKey[nativeEvent.key] || nativeEvent.key
    );
    if (key !== "Unidentified") {
      return key;
    }
  }
  if (nativeEvent.type === "keypress") {
    const charCode = getEventCharCode_default(
      // $FlowFixMe[incompatible-call] unable to narrow to `KeyboardEvent`
      nativeEvent
    );
    return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
    return translateToKey[nativeEvent.keyCode] || "Unidentified";
  }
  return "";
}
var modifierKeyToProp = {
  Alt: "altKey",
  Control: "ctrlKey",
  Meta: "metaKey",
  Shift: "shiftKey"
};
function modifierStateGetter(keyArg) {
  const syntheticEvent = this;
  const nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  const keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}
function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}
var KeyboardEventInterface = {
  ...UIEventInterface,
  key: getEventKey,
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function(event) {
    if (event.type === "keypress") {
      return getEventCharCode_default(
        // $FlowFixMe[incompatible-call] unable to narrow to `KeyboardEvent`
        event
      );
    }
    return 0;
  },
  keyCode: function(event) {
    if (event.type === "keydown" || event.type === "keyup") {
      return event.keyCode;
    }
    return 0;
  },
  which: function(event) {
    if (event.type === "keypress") {
      return getEventCharCode_default(
        // $FlowFixMe[incompatible-call] unable to narrow to `KeyboardEvent`
        event
      );
    }
    if (event.type === "keydown" || event.type === "keyup") {
      return event.keyCode;
    }
    return 0;
  }
};
var SyntheticKeyboardEvent = createSyntheticEvent(
  KeyboardEventInterface
);
var PointerEventInterface = {
  ...MouseEventInterface,
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
};
var SyntheticPointerEvent = createSyntheticEvent(
  PointerEventInterface
);
var TouchEventInterface = {
  ...UIEventInterface,
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: getEventModifierState
};
var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
var TransitionEventInterface = {
  ...EventInterface,
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
};
var SyntheticTransitionEvent = createSyntheticEvent(
  TransitionEventInterface
);
var WheelEventInterface = {
  ...MouseEventInterface,
  deltaX(event) {
    return "deltaX" in event ? event.deltaX : (
      // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
      "wheelDeltaX" in event ? (
        // $FlowFixMe[unsafe-arithmetic] assuming this is a number
        -event.wheelDeltaX
      ) : 0
    );
  },
  deltaY(event) {
    return "deltaY" in event ? event.deltaY : (
      // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
      "wheelDeltaY" in event ? (
        // $FlowFixMe[unsafe-arithmetic] assuming this is a number
        -event.wheelDeltaY
      ) : (
        // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
        "wheelDelta" in event ? (
          // $FlowFixMe[unsafe-arithmetic] assuming this is a number
          -event.wheelDelta
        ) : 0
      )
    );
  },
  deltaZ: 0,
  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: 0
};
var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
var ToggleEventInterface = {
  ...EventInterface,
  newState: 0,
  oldState: 0
};
var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);

// dist/react-dom-bindings/src/events/plugins/BeforeInputEventPlugin.js
var END_KEYCODES = [9, 13, 27, 32];
var START_KEYCODE = 229;
var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
var documentMode = null;
if (canUseDOM && "documentMode" in document) {
  documentMode = document.documentMode;
}
var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
function registerEvents() {
  registerTwoPhaseEvent("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  registerTwoPhaseEvent("onCompositionEnd", [
    "compositionend",
    "focusout",
    "keydown",
    "keypress",
    "keyup",
    "mousedown"
  ]);
  registerTwoPhaseEvent("onCompositionStart", [
    "compositionstart",
    "focusout",
    "keydown",
    "keypress",
    "keyup",
    "mousedown"
  ]);
  registerTwoPhaseEvent("onCompositionUpdate", [
    "compositionupdate",
    "focusout",
    "keydown",
    "keypress",
    "keyup",
    "mousedown"
  ]);
}
var hasSpaceKeypress = false;
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}
function getCompositionEventType(domEventName) {
  switch (domEventName) {
    case "compositionstart":
      return "onCompositionStart";
    case "compositionend":
      return "onCompositionEnd";
    case "compositionupdate":
      return "onCompositionUpdate";
  }
}
function isFallbackCompositionStart(domEventName, nativeEvent) {
  return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
}
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case "keydown":
      return nativeEvent.keyCode !== START_KEYCODE;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  const detail = nativeEvent.detail;
  if (typeof detail === "object" && "data" in detail) {
    return detail.data;
  }
  return null;
}
function isUsingKoreanIME(nativeEvent) {
  return nativeEvent.locale === "ko";
}
var isComposing = false;
function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  let eventType;
  let fallbackData;
  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(domEventName);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(domEventName, nativeEvent)) {
      eventType = "onCompositionStart";
    }
  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
    eventType = "onCompositionEnd";
  }
  if (!eventType) {
    return null;
  }
  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
    if (!isComposing && eventType === "onCompositionStart") {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === "onCompositionEnd") {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }
  const listeners = accumulateTwoPhaseListeners(targetInst, eventType);
  if (listeners.length > 0) {
    const event = new SyntheticCompositionEvent(
      eventType,
      domEventName,
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({ event, listeners });
    if (fallbackData) {
      event.data = fallbackData;
    } else {
      const customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }
  }
}
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      const which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }
      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;
    case "textInput":
      const chars = nativeEvent.data;
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }
      return chars;
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing) {
    if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
      const chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (!isKeypressCommand(nativeEvent)) {
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
    default:
      return null;
  }
}
function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  let chars;
  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(domEventName, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
  }
  if (!chars) {
    return null;
  }
  const listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
  if (listeners.length > 0) {
    const event = new SyntheticInputEvent(
      "onBeforeInput",
      "beforeinput",
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({ event, listeners });
    event.data = chars;
  }
}
function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  extractCompositionEvent(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget
  );
  extractBeforeInputEvent(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget
  );
}

// dist/react-dom-bindings/src/events/isTextInputElement.js
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  "datetime-local": true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};
function isTextInputElement(elem) {
  const nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  if (nodeName === "input") {
    return !!supportedInputTypes[elem.type];
  }
  if (nodeName === "textarea") {
    return true;
  }
  return false;
}
var isTextInputElement_default = isTextInputElement;

// dist/react-dom-bindings/src/events/isEventSupported.js
function isEventSupported(eventNameSuffix) {
  if (!canUseDOM) {
    return false;
  }
  const eventName = "on" + eventNameSuffix;
  let isSupported = eventName in document;
  if (!isSupported) {
    const element = document.createElement("div");
    element.setAttribute(eventName, "return;");
    isSupported = typeof element[eventName] === "function";
  }
  return isSupported;
}
var isEventSupported_default = isEventSupported;

// dist/react-dom-bindings/src/events/plugins/ChangeEventPlugin.js
function registerEvents2() {
  registerTwoPhaseEvent("onChange", [
    "change",
    "click",
    "focusin",
    "focusout",
    "input",
    "keydown",
    "keyup",
    "selectionchange"
  ]);
}
function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
  enqueueStateRestore(target);
  const listeners = accumulateTwoPhaseListeners(inst, "onChange");
  if (listeners.length > 0) {
    const event = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    );
    dispatchQueue.push({ event, listeners });
  }
}
var activeElement = null;
var activeElementInst = null;
function shouldUseChangeEvent(elem) {
  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === "select" || nodeName === "input" && elem.type === "file";
}
function manualDispatchChangeEvent(nativeEvent) {
  const dispatchQueue = [];
  createAndAccumulateChangeEvent(
    dispatchQueue,
    activeElementInst,
    nativeEvent,
    getEventTarget_default(nativeEvent)
  );
  batchedUpdates3(runEventInBatch, dispatchQueue);
}
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  const targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if (domEventName === "change") {
    return targetInst;
  }
}
var isInputEventSupported = false;
if (canUseDOM) {
  isInputEventSupported = isEventSupported_default("input") && (!document.documentMode || document.documentMode > 9);
}
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent("onpropertychange", handlePropertyChange);
}
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent("onpropertychange", handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== "value") {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  if (domEventName === "focusin") {
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (domEventName === "focusout") {
    stopWatchingForValueChange();
  }
}
function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
  if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
    return getInstIfValueChanged(activeElementInst);
  }
}
function shouldUseClickEvent(elem) {
  const nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if (domEventName === "click") {
    return getInstIfValueChanged(targetInst);
  }
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if (domEventName === "input" || domEventName === "change") {
    return getInstIfValueChanged(targetInst);
  }
}
function handleControlledInputBlur(node, props) {
  if (node.type !== "number") {
    return;
  }
  if (!disableInputAttributeSyncing) {
    const isControlled = props.value != null;
    if (isControlled) {
      setDefaultValue(node, "number", node.value);
    }
  }
}
function extractEvents2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
  let getTargetInstFunc, handleEventFunc;
  if (shouldUseChangeEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForChangeEvent;
  } else if (isTextInputElement_default(targetNode)) {
    if (isInputEventSupported) {
      getTargetInstFunc = getTargetInstForInputOrChangeEvent;
    } else {
      getTargetInstFunc = getTargetInstForInputEventPolyfill;
      handleEventFunc = handleEventsForInputEventPolyfill;
    }
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  } else if (targetInst && isCustomElement_default(targetInst.elementType, targetInst.memoizedProps)) {
    getTargetInstFunc = getTargetInstForChangeEvent;
  }
  if (getTargetInstFunc) {
    const inst = getTargetInstFunc(domEventName, targetInst);
    if (inst) {
      createAndAccumulateChangeEvent(
        dispatchQueue,
        inst,
        nativeEvent,
        nativeEventTarget
      );
      return;
    }
  }
  if (handleEventFunc) {
    handleEventFunc(domEventName, targetNode, targetInst);
  }
  if (domEventName === "focusout" && targetInst) {
    const props = targetInst.memoizedProps;
    handleControlledInputBlur(targetNode, props);
  }
}

// dist/react-dom-bindings/src/events/plugins/EnterLeaveEventPlugin.js
function registerEvents3() {
  registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
  registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
  registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
  registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
}
function extractEvents3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  const isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
  const isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
  if (isOverEvent && !isReplayingEvent(nativeEvent)) {
    const related = nativeEvent.relatedTarget || nativeEvent.fromElement;
    if (related) {
      if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
        return;
      }
    }
  }
  if (!isOutEvent && !isOverEvent) {
    return;
  }
  let win;
  if (nativeEventTarget.window === nativeEventTarget) {
    win = nativeEventTarget;
  } else {
    const doc = nativeEventTarget.ownerDocument;
    if (doc) {
      win = doc.defaultView || doc.parentWindow;
    } else {
      win = window;
    }
  }
  let from;
  let to;
  if (isOutEvent) {
    const related = nativeEvent.relatedTarget || nativeEvent.toElement;
    from = targetInst;
    to = related ? getClosestInstanceFromNode(related) : null;
    if (to !== null) {
      const nearestMounted = getNearestMountedFiber(to);
      const tag = to.tag;
      if (to !== nearestMounted || tag !== HostComponent && tag !== HostSingleton && tag !== HostText) {
        to = null;
      }
    }
  } else {
    from = null;
    to = targetInst;
  }
  if (from === to) {
    return;
  }
  let SyntheticEventCtor = SyntheticMouseEvent;
  let leaveEventType = "onMouseLeave";
  let enterEventType = "onMouseEnter";
  let eventTypePrefix = "mouse";
  if (domEventName === "pointerout" || domEventName === "pointerover") {
    SyntheticEventCtor = SyntheticPointerEvent;
    leaveEventType = "onPointerLeave";
    enterEventType = "onPointerEnter";
    eventTypePrefix = "pointer";
  }
  const fromNode = from == null ? win : getNodeFromInstance(from);
  const toNode = to == null ? win : getNodeFromInstance(to);
  const leave = new SyntheticEventCtor(
    leaveEventType,
    eventTypePrefix + "leave",
    from,
    nativeEvent,
    nativeEventTarget
  );
  leave.target = fromNode;
  leave.relatedTarget = toNode;
  let enter = null;
  const nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (nativeTargetInst === targetInst) {
    const enterEvent = new SyntheticEventCtor(
      enterEventType,
      eventTypePrefix + "enter",
      to,
      nativeEvent,
      nativeEventTarget
    );
    enterEvent.target = toNode;
    enterEvent.relatedTarget = fromNode;
    enter = enterEvent;
  }
  accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
}

// dist/react-dom-bindings/src/client/ReactInputSelection.js
function hasSelectionCapabilities(elem) {
  const nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
}

// dist/react-dom-bindings/src/events/plugins/SelectEventPlugin.js
var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
function registerEvents4() {
  registerTwoPhaseEvent("onSelect", [
    "focusout",
    "contextmenu",
    "dragend",
    "focusin",
    "keydown",
    "keyup",
    "mousedown",
    "mouseup",
    "selectionchange"
  ]);
}
var activeElement2 = null;
var activeElementInst2 = null;
var lastSelection = null;
var mouseDown = false;
function getSelection(node) {
  if ("selectionStart" in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else {
    const win = node.ownerDocument && node.ownerDocument.defaultView || window;
    const selection = win.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}
function getEventTargetDocument(eventTarget) {
  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
}
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  const doc = getEventTargetDocument(nativeEventTarget);
  if (mouseDown || activeElement2 == null || activeElement2 !== getActiveElement(doc)) {
    return;
  }
  const currentSelection = getSelection(activeElement2);
  if (!lastSelection || !shallowEqual_default(lastSelection, currentSelection)) {
    lastSelection = currentSelection;
    const listeners = accumulateTwoPhaseListeners(
      activeElementInst2,
      "onSelect"
    );
    if (listeners.length > 0) {
      const event = new SyntheticEvent(
        "onSelect",
        "select",
        null,
        nativeEvent,
        nativeEventTarget
      );
      dispatchQueue.push({ event, listeners });
      event.target = activeElement2;
    }
  }
}
function extractEvents4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
  switch (domEventName) {
    // Track the input node that has focus.
    case "focusin":
      if (isTextInputElement_default(targetNode) || targetNode.contentEditable === "true") {
        activeElement2 = targetNode;
        activeElementInst2 = targetInst;
        lastSelection = null;
      }
      break;
    case "focusout":
      activeElement2 = null;
      activeElementInst2 = null;
      lastSelection = null;
      break;
    // Don't fire the event while the user is dragging. This matches the
    // semantics of the native select event.
    case "mousedown":
      mouseDown = true;
      break;
    case "contextmenu":
    case "mouseup":
    case "dragend":
      mouseDown = false;
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      break;
    // Chrome and IE fire non-standard event when selection is changed (and
    // sometimes when it hasn't). IE's event fires out of order with respect
    // to key and input events on deletion, so we discard it.
    //
    // Firefox doesn't support selectionchange, so check selection status
    // after each key entry. The selection changes after keydown and before
    // keyup, but we check on keydown as well in the case of holding down a
    // key, when multiple keydown events are fired but only one keyup is.
    // This is also our approach for IE handling, for the reason above.
    case "selectionchange":
      if (skipSelectionChangeEvent) {
        break;
      }
    // falls through
    case "keydown":
    case "keyup":
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
  }
}

// dist/react-dom-bindings/src/events/getVendorPrefixedEventName.js
function makePrefixMap(styleProp, eventName) {
  const prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
var vendorPrefixes = {
  animationend: makePrefixMap("Animation", "AnimationEnd"),
  animationiteration: makePrefixMap("Animation", "AnimationIteration"),
  animationstart: makePrefixMap("Animation", "AnimationStart"),
  transitionrun: makePrefixMap("Transition", "TransitionRun"),
  transitionstart: makePrefixMap("Transition", "TransitionStart"),
  transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
  transitionend: makePrefixMap("Transition", "TransitionEnd")
};
var prefixedEventNames = {};
var style = {};
if (canUseDOM) {
  style = document.createElement("div").style;
  if (!("AnimationEvent" in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }
  if (!("TransitionEvent" in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }
  const prefixMap = vendorPrefixes[eventName];
  for (const styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }
  return eventName;
}
var getVendorPrefixedEventName_default = getVendorPrefixedEventName;

// dist/react-dom-bindings/src/events/DOMEventNames.js
var ANIMATION_END = getVendorPrefixedEventName_default("animationend");
var ANIMATION_ITERATION = getVendorPrefixedEventName_default("animationiteration");
var ANIMATION_START = getVendorPrefixedEventName_default("animationstart");
var TRANSITION_RUN = getVendorPrefixedEventName_default("transitionrun");
var TRANSITION_START = getVendorPrefixedEventName_default("transitionstart");
var TRANSITION_CANCEL = getVendorPrefixedEventName_default("transitioncancel");
var TRANSITION_END = getVendorPrefixedEventName_default("transitionend");

// dist/react-dom-bindings/src/events/DOMEventProperties.js
var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
var simpleEventPluginEvents = [
  "abort",
  "auxClick",
  "beforeToggle",
  "cancel",
  "canPlay",
  "canPlayThrough",
  "click",
  "close",
  "contextMenu",
  "copy",
  "cut",
  "drag",
  "dragEnd",
  "dragEnter",
  "dragExit",
  "dragLeave",
  "dragOver",
  "dragStart",
  "drop",
  "durationChange",
  "emptied",
  "encrypted",
  "ended",
  "error",
  "gotPointerCapture",
  "input",
  "invalid",
  "keyDown",
  "keyPress",
  "keyUp",
  "load",
  "loadedData",
  "loadedMetadata",
  "loadStart",
  "lostPointerCapture",
  "mouseDown",
  "mouseMove",
  "mouseOut",
  "mouseOver",
  "mouseUp",
  "paste",
  "pause",
  "play",
  "playing",
  "pointerCancel",
  "pointerDown",
  "pointerMove",
  "pointerOut",
  "pointerOver",
  "pointerUp",
  "progress",
  "rateChange",
  "reset",
  "resize",
  "seeked",
  "seeking",
  "stalled",
  "submit",
  "suspend",
  "timeUpdate",
  "touchCancel",
  "touchEnd",
  "touchStart",
  "volumeChange",
  "scroll",
  "toggle",
  "touchMove",
  "waiting",
  "wheel"
];
if (!enableScrollEndPolyfill) {
  simpleEventPluginEvents.push("scrollEnd");
}
if (enableCreateEventHandleAPI) {
  topLevelEventsToReactNames.set("beforeblur", null);
  topLevelEventsToReactNames.set("afterblur", null);
}
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
function registerSimpleEvents() {
  for (let i = 0; i < simpleEventPluginEvents.length; i++) {
    const eventName = simpleEventPluginEvents[i];
    const domEventName = eventName.toLowerCase();
    const capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
    registerSimpleEvent(domEventName, "on" + capitalizedEvent);
  }
  registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
  registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
  registerSimpleEvent(ANIMATION_START, "onAnimationStart");
  registerSimpleEvent("dblclick", "onDoubleClick");
  registerSimpleEvent("focusin", "onFocus");
  registerSimpleEvent("focusout", "onBlur");
  registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
  registerSimpleEvent(TRANSITION_START, "onTransitionStart");
  registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
  registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
}

// dist/react-dom-bindings/src/events/plugins/SimpleEventPlugin.js
function extractEvents5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  const reactName = topLevelEventsToReactNames.get(domEventName);
  if (reactName === void 0) {
    return;
  }
  let SyntheticEventCtor = SyntheticEvent;
  let reactEventType = domEventName;
  switch (domEventName) {
    case "keypress":
      if (getEventCharCode_default(nativeEvent) === 0) {
        return;
      }
    /* falls through */
    case "keydown":
    case "keyup":
      SyntheticEventCtor = SyntheticKeyboardEvent;
      break;
    case "focusin":
      reactEventType = "focus";
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case "focusout":
      reactEventType = "blur";
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case "beforeblur":
    case "afterblur":
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case "click":
      if (nativeEvent.button === 2) {
        return;
      }
    /* falls through */
    case "auxclick":
    case "dblclick":
    case "mousedown":
    case "mousemove":
    case "mouseup":
    // TODO: Disabled elements should not respond to mouse events
    /* falls through */
    case "mouseout":
    case "mouseover":
    case "contextmenu":
      SyntheticEventCtor = SyntheticMouseEvent;
      break;
    case "drag":
    case "dragend":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "dragstart":
    case "drop":
      SyntheticEventCtor = SyntheticDragEvent;
      break;
    case "touchcancel":
    case "touchend":
    case "touchmove":
    case "touchstart":
      SyntheticEventCtor = SyntheticTouchEvent;
      break;
    case ANIMATION_END:
    case ANIMATION_ITERATION:
    case ANIMATION_START:
      SyntheticEventCtor = SyntheticAnimationEvent;
      break;
    case TRANSITION_END:
      SyntheticEventCtor = SyntheticTransitionEvent;
      break;
    case "scroll":
    case "scrollend":
      SyntheticEventCtor = SyntheticUIEvent;
      break;
    case "wheel":
      SyntheticEventCtor = SyntheticWheelEvent;
      break;
    case "copy":
    case "cut":
    case "paste":
      SyntheticEventCtor = SyntheticClipboardEvent;
      break;
    case "gotpointercapture":
    case "lostpointercapture":
    case "pointercancel":
    case "pointerdown":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerup":
      SyntheticEventCtor = SyntheticPointerEvent;
      break;
    case "toggle":
    case "beforetoggle":
      SyntheticEventCtor = SyntheticToggleEvent;
      break;
    default:
      break;
  }
  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
  if (enableCreateEventHandleAPI && eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) {
    const listeners = accumulateEventHandleNonManagedNodeListeners(
      // TODO: this cast may not make sense for events like
      // "focus" where React listens to e.g. "focusin".
      reactEventType,
      targetContainer,
      inCapturePhase
    );
    if (listeners.length > 0) {
      const event = new SyntheticEventCtor(
        reactName,
        reactEventType,
        null,
        nativeEvent,
        nativeEventTarget
      );
      dispatchQueue.push({ event, listeners });
    }
  } else {
    const accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
    // nonDelegatedEvents list in DOMPluginEventSystem.
    // Then we can remove this special list.
    // This is a breaking change that can wait until React 18.
    (domEventName === "scroll" || domEventName === "scrollend");
    const listeners = accumulateSinglePhaseListeners(
      targetInst,
      reactName,
      nativeEvent.type,
      inCapturePhase,
      accumulateTargetOnly,
      nativeEvent
    );
    if (listeners.length > 0) {
      const event = new SyntheticEventCtor(
        reactName,
        reactEventType,
        null,
        nativeEvent,
        nativeEventTarget
      );
      dispatchQueue.push({ event, listeners });
    }
  }
}

// dist/react-dom-bindings/src/events/plugins/FormActionEventPlugin.js
function coerceFormActionProp(actionProp) {
  if (actionProp == null || typeof actionProp === "symbol" || typeof actionProp === "boolean") {
    return null;
  } else if (typeof actionProp === "function") {
    return actionProp;
  } else {
    if (false) {
      checkAttributeStringCoercion(actionProp, "action");
    }
    return sanitizeURL_default(
      enableTrustedTypesIntegration ? actionProp : "" + actionProp
    );
  }
}
function createFormDataWithSubmitter(form, submitter) {
  const temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  if (form.id) {
    temp.setAttribute("form", form.id);
  }
  submitter.parentNode.insertBefore(temp, submitter);
  const formData = new FormData(form);
  temp.parentNode.removeChild(temp);
  return formData;
}
function extractEvents6(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  if (domEventName !== "submit") {
    return;
  }
  if (!maybeTargetInst || maybeTargetInst.stateNode !== nativeEventTarget) {
    return;
  }
  const formInst = maybeTargetInst;
  const form = nativeEventTarget;
  let action = coerceFormActionProp(
    getFiberCurrentPropsFromNode(form).action
  );
  let submitter = nativeEvent.submitter;
  let submitterAction;
  if (submitter) {
    const submitterProps = getFiberCurrentPropsFromNode(submitter);
    submitterAction = submitterProps ? coerceFormActionProp(submitterProps.formAction) : (
      // The built-in Flow type is ?string, wider than the spec
      submitter.getAttribute("formAction")
    );
    if (submitterAction !== null) {
      action = submitterAction;
      submitter = null;
    }
  }
  const event = new SyntheticEvent(
    "action",
    "action",
    null,
    nativeEvent,
    nativeEventTarget
  );
  function submitForm() {
    if (nativeEvent.defaultPrevented) {
      if (didCurrentEventScheduleTransition()) {
        const formData = submitter ? createFormDataWithSubmitter(form, submitter) : new FormData(form);
        const pendingState = {
          pending: true,
          data: formData,
          method: form.method,
          action
        };
        if (false) {
          Object.freeze(pendingState);
        }
        startHostTransition(
          formInst,
          pendingState,
          // Pass `null` as the action
          // TODO: Consider splitting up startHostTransition into two separate
          // functions, one that sets the form status and one that invokes
          // the action.
          null,
          formData
        );
      } else {
      }
    } else if (typeof action === "function") {
      event.preventDefault();
      const formData = submitter ? createFormDataWithSubmitter(form, submitter) : new FormData(form);
      const pendingState = {
        pending: true,
        data: formData,
        method: form.method,
        action
      };
      if (false) {
        Object.freeze(pendingState);
      }
      startHostTransition(formInst, pendingState, action, formData);
    } else {
    }
  }
  dispatchQueue.push({
    event,
    listeners: [
      {
        instance: null,
        listener: submitForm,
        currentTarget: form
      }
    ]
  });
}

// dist/react-dom-bindings/src/events/plugins/ScrollEndEventPlugin.js
var isScrollEndEventSupported = enableScrollEndPolyfill && canUseDOM && isEventSupported_default("scrollend");
var isTouchStarted = false;
var isMouseDown = false;
function registerEvents5() {
  registerTwoPhaseEvent("onScrollEnd", [
    "scroll",
    "scrollend",
    "touchstart",
    "touchcancel",
    "touchend",
    "mousedown",
    "mouseup"
  ]);
}
function manualDispatchScrollEndEvent(inst, nativeEvent, target) {
  const dispatchQueue = [];
  const listeners = accumulateTwoPhaseListeners(inst, "onScrollEnd");
  if (listeners.length > 0) {
    const event = new SyntheticUIEvent(
      "onScrollEnd",
      "scrollend",
      null,
      nativeEvent,
      // This will be the "scroll" event.
      target
    );
    dispatchQueue.push({ event, listeners });
  }
  batchedUpdates3(runEventInBatch2, dispatchQueue);
}
function runEventInBatch2(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function fireScrollEnd(targetInst, nativeEvent, nativeEventTarget) {
  clearScrollEndTimer(nativeEventTarget);
  if (isMouseDown || isTouchStarted) {
    debounceScrollEnd(targetInst, nativeEvent, nativeEventTarget);
    return;
  }
  manualDispatchScrollEndEvent(targetInst, nativeEvent, nativeEventTarget);
}
var DEBOUNCE_TIMEOUT = 200;
function debounceScrollEnd(targetInst, nativeEvent, nativeEventTarget) {
  const existingTimer = getScrollEndTimer(nativeEventTarget);
  if (existingTimer != null) {
    clearTimeout(existingTimer);
  }
  if (targetInst !== null) {
    const newTimer = setTimeout(
      fireScrollEnd.bind(null, targetInst, nativeEvent, nativeEventTarget),
      DEBOUNCE_TIMEOUT
    );
    setScrollEndTimer(nativeEventTarget, newTimer);
  }
}
function extractEvents7(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  if (!enableScrollEndPolyfill) {
    return;
  }
  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
  if (domEventName !== "scrollend") {
    if (!isScrollEndEventSupported && inCapturePhase) {
      switch (domEventName) {
        case "scroll": {
          if (nativeEventTarget !== null) {
            debounceScrollEnd(targetInst, nativeEvent, nativeEventTarget);
          }
          break;
        }
        case "touchstart": {
          isTouchStarted = true;
          break;
        }
        case "touchcancel":
        case "touchend": {
          isTouchStarted = false;
          break;
        }
        case "mousedown": {
          isMouseDown = true;
          break;
        }
        case "mouseup": {
          isMouseDown = false;
          break;
        }
      }
    }
    return;
  }
  if (!isScrollEndEventSupported && nativeEventTarget !== null) {
    const existingTimer = getScrollEndTimer(nativeEventTarget);
    if (existingTimer != null) {
      clearTimeout(existingTimer);
      clearScrollEndTimer(nativeEventTarget);
    } else {
      return;
    }
  }
  const accumulateTargetOnly = !inCapturePhase;
  const listeners = accumulateSinglePhaseListeners(
    targetInst,
    "onScrollEnd",
    "scrollend",
    inCapturePhase,
    accumulateTargetOnly,
    nativeEvent
  );
  if (listeners.length > 0) {
    const event = new SyntheticUIEvent(
      "onScrollEnd",
      "scrollend",
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({ event, listeners });
  }
}

// dist/react-dom-bindings/src/events/DOMPluginEventSystem.js
registerSimpleEvents();
registerEvents3();
registerEvents2();
registerEvents4();
registerEvents();
if (enableScrollEndPolyfill) {
  registerEvents5();
}
function extractEvents8(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  extractEvents5(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
  const shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
  if (shouldProcessPolyfillPlugins) {
    extractEvents3(
      dispatchQueue,
      domEventName,
      targetInst,
      nativeEvent,
      nativeEventTarget,
      eventSystemFlags,
      targetContainer
    );
    extractEvents2(
      dispatchQueue,
      domEventName,
      targetInst,
      nativeEvent,
      nativeEventTarget,
      eventSystemFlags,
      targetContainer
    );
    extractEvents4(
      dispatchQueue,
      domEventName,
      targetInst,
      nativeEvent,
      nativeEventTarget,
      eventSystemFlags,
      targetContainer
    );
    extractEvents(
      dispatchQueue,
      domEventName,
      targetInst,
      nativeEvent,
      nativeEventTarget,
      eventSystemFlags,
      targetContainer
    );
    extractEvents6(
      dispatchQueue,
      domEventName,
      targetInst,
      nativeEvent,
      nativeEventTarget,
      eventSystemFlags,
      targetContainer
    );
  }
  if (enableScrollEndPolyfill) {
    extractEvents7(
      dispatchQueue,
      domEventName,
      targetInst,
      nativeEvent,
      nativeEventTarget,
      eventSystemFlags,
      targetContainer
    );
  }
}
var mediaEventTypes = [
  "abort",
  "canplay",
  "canplaythrough",
  "durationchange",
  "emptied",
  "encrypted",
  "ended",
  "error",
  "loadeddata",
  "loadedmetadata",
  "loadstart",
  "pause",
  "play",
  "playing",
  "progress",
  "ratechange",
  "resize",
  "seeked",
  "seeking",
  "stalled",
  "suspend",
  "timeupdate",
  "volumechange",
  "waiting"
];
var nonDelegatedEvents = /* @__PURE__ */ new Set([
  "beforetoggle",
  "cancel",
  "close",
  "invalid",
  "load",
  "scroll",
  "scrollend",
  "toggle",
  // In order to reduce bytes, we insert the above array of media events
  // into this Set. Note: the "error" event isn't an exclusive media event,
  // and can occur on other elements too. Rather than duplicate that event,
  // we just take it from the media events array.
  ...mediaEventTypes
]);
function executeDispatch(event, listener, currentTarget) {
  event.currentTarget = currentTarget;
  try {
    listener(event);
  } catch (error) {
    reportGlobalError_default(error);
  }
  event.currentTarget = null;
}
function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
  let previousInstance;
  if (inCapturePhase) {
    for (let i = dispatchListeners.length - 1; i >= 0; i--) {
      const { instance, currentTarget, listener } = dispatchListeners[i];
      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }
      if (false) {
        runWithFiberInDEV(
          instance,
          executeDispatch,
          event,
          listener,
          currentTarget
        );
      } else {
        executeDispatch(event, listener, currentTarget);
      }
      previousInstance = instance;
    }
  } else {
    for (let i = 0; i < dispatchListeners.length; i++) {
      const { instance, currentTarget, listener } = dispatchListeners[i];
      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }
      if (false) {
        runWithFiberInDEV(
          instance,
          executeDispatch,
          event,
          listener,
          currentTarget
        );
      } else {
        executeDispatch(event, listener, currentTarget);
      }
      previousInstance = instance;
    }
  }
}
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
  for (let i = 0; i < dispatchQueue.length; i++) {
    const { event, listeners } = dispatchQueue[i];
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
  }
}
function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  const nativeEventTarget = getEventTarget_default(nativeEvent);
  const dispatchQueue = [];
  extractEvents8(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer
  );
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  if (false) {
    if (!nonDelegatedEvents.has(domEventName)) {
      console.error(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        domEventName
      );
    }
  }
  const isCapturePhaseListener = false;
  const listenerSet = getEventListenerSet(targetElement);
  const listenerSetKey = getListenerSetKey(
    domEventName,
    isCapturePhaseListener
  );
  if (!listenerSet.has(listenerSetKey)) {
    addTrappedEventListener(
      targetElement,
      domEventName,
      IS_NON_DELEGATED,
      isCapturePhaseListener
    );
    listenerSet.add(listenerSetKey);
  }
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  if (false) {
    if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
      console.error(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        domEventName
      );
    }
  }
  let eventSystemFlags = 0;
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener
  );
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach((domEventName) => {
      if (domEventName !== "selectionchange") {
        if (!nonDelegatedEvents.has(domEventName)) {
          listenToNativeEvent(domEventName, false, rootContainerElement);
        }
        listenToNativeEvent(domEventName, true, rootContainerElement);
      }
    });
    const ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
    if (ownerDocument !== null) {
      if (!ownerDocument[listeningMarker]) {
        ownerDocument[listeningMarker] = true;
        listenToNativeEvent("selectionchange", false, ownerDocument);
      }
    }
  }
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
  let listener = createEventListenerWrapperWithPriority(
    targetContainer,
    domEventName,
    eventSystemFlags
  );
  let isPassiveListener = void 0;
  if (passiveBrowserEventsSupported) {
    if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
      isPassiveListener = true;
    }
  }
  targetContainer = enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport ? targetContainer.ownerDocument : targetContainer;
  let unsubscribeListener;
  if (enableLegacyFBSupport && isDeferredListenerForLegacyFBSupport) {
    const originalListener = listener;
    listener = function(...p) {
      removeEventListener(
        targetContainer,
        domEventName,
        unsubscribeListener,
        isCapturePhaseListener
      );
      return originalListener.apply(this, p);
    };
  }
  if (isCapturePhaseListener) {
    if (isPassiveListener !== void 0) {
      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(
        targetContainer,
        domEventName,
        listener,
        isPassiveListener
      );
    } else {
      unsubscribeListener = addEventCaptureListener(
        targetContainer,
        domEventName,
        listener
      );
    }
  } else {
    if (isPassiveListener !== void 0) {
      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(
        targetContainer,
        domEventName,
        listener,
        isPassiveListener
      );
    } else {
      unsubscribeListener = addEventBubbleListener(
        targetContainer,
        domEventName,
        listener
      );
    }
  }
}
function deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer) {
  const isDeferredListenerForLegacyFBSupport = true;
  addTrappedEventListener(
    targetContainer,
    domEventName,
    IS_LEGACY_FB_SUPPORT_MODE,
    false,
    isDeferredListenerForLegacyFBSupport
  );
}
function isMatchingRootContainer(grandContainer, targetContainer) {
  return grandContainer === targetContainer || !disableCommentsAsDOMContainers && grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
}
function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  let ancestorInst = targetInst;
  if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
    const targetContainerNode = targetContainer;
    if (enableLegacyFBSupport && // If our event flags match the required flags for entering
    // FB legacy mode and we are processing the "click" event,
    // then we can defer the event to the "document", to allow
    // for legacy FB support, where the expected behavior was to
    // match React < 16 behavior of delegated clicks to the doc.
    domEventName === "click" && (eventSystemFlags & SHOULD_NOT_DEFER_CLICK_FOR_FB_SUPPORT_MODE) === 0 && !isReplayingEvent(nativeEvent)) {
      deferClickToDocumentForLegacyFBSupport(domEventName, targetContainer);
      return;
    }
    if (targetInst !== null) {
      let node = targetInst;
      mainLoop: while (true) {
        if (node === null) {
          return;
        }
        const nodeTag = node.tag;
        if (nodeTag === HostRoot || nodeTag === HostPortal) {
          let container = node.stateNode.containerInfo;
          if (isMatchingRootContainer(container, targetContainerNode)) {
            break;
          }
          if (nodeTag === HostPortal) {
            let grandNode = node.return;
            while (grandNode !== null) {
              const grandTag = grandNode.tag;
              if (grandTag === HostRoot || grandTag === HostPortal) {
                const grandContainer = grandNode.stateNode.containerInfo;
                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                  return;
                }
              }
              grandNode = grandNode.return;
            }
          }
          while (container !== null) {
            const parentNode = getClosestInstanceFromNode(container);
            if (parentNode === null) {
              return;
            }
            const parentTag = parentNode.tag;
            if (parentTag === HostComponent || parentTag === HostText || parentTag === HostHoistable || parentTag === HostSingleton) {
              node = ancestorInst = parentNode;
              continue mainLoop;
            }
            container = container.parentNode;
          }
        }
        node = node.return;
      }
    }
  }
  batchedUpdates3(
    () => dispatchEventsForPlugins(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      ancestorInst,
      targetContainer
    )
  );
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance,
    listener,
    currentTarget
  };
}
function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
  const captureName = reactName !== null ? reactName + "Capture" : null;
  const reactEventName = inCapturePhase ? captureName : reactName;
  let listeners = [];
  let instance = targetFiber;
  let lastHostComponent = null;
  while (instance !== null) {
    const { stateNode, tag } = instance;
    if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && stateNode !== null) {
      lastHostComponent = stateNode;
      if (enableCreateEventHandleAPI) {
        const eventHandlerListeners = getEventHandlerListeners(lastHostComponent);
        if (eventHandlerListeners !== null) {
          eventHandlerListeners.forEach((entry) => {
            if (entry.type === nativeEventType && entry.capture === inCapturePhase) {
              listeners.push(
                createDispatchListener(
                  instance,
                  entry.callback,
                  lastHostComponent
                )
              );
            }
          });
        }
      }
      if (reactEventName !== null) {
        const listener = getListener(instance, reactEventName);
        if (listener != null) {
          listeners.push(
            createDispatchListener(instance, listener, lastHostComponent)
          );
        }
      }
    } else if (enableCreateEventHandleAPI && enableScopeAPI && tag === ScopeComponent && lastHostComponent !== null && stateNode !== null) {
      const reactScopeInstance = stateNode;
      const eventHandlerListeners = getEventHandlerListeners(reactScopeInstance);
      if (eventHandlerListeners !== null) {
        eventHandlerListeners.forEach((entry) => {
          if (entry.type === nativeEventType && entry.capture === inCapturePhase) {
            listeners.push(
              createDispatchListener(
                instance,
                entry.callback,
                lastHostComponent
              )
            );
          }
        });
      }
    }
    if (accumulateTargetOnly) {
      break;
    }
    if (enableCreateEventHandleAPI && nativeEvent.type === "beforeblur") {
      const detachedInterceptFiber = nativeEvent._detachedInterceptFiber;
      if (detachedInterceptFiber !== null && (detachedInterceptFiber === instance || detachedInterceptFiber === instance.alternate)) {
        listeners = [];
      }
    }
    instance = instance.return;
  }
  return listeners;
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  const captureName = reactName + "Capture";
  const listeners = [];
  let instance = targetFiber;
  while (instance !== null) {
    const { stateNode, tag } = instance;
    if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && stateNode !== null) {
      const currentTarget = stateNode;
      const captureListener = getListener(instance, captureName);
      if (captureListener != null) {
        listeners.unshift(
          createDispatchListener(instance, captureListener, currentTarget)
        );
      }
      const bubbleListener = getListener(instance, reactName);
      if (bubbleListener != null) {
        listeners.push(
          createDispatchListener(instance, bubbleListener, currentTarget)
        );
      }
    }
    if (instance.tag === HostRoot) {
      return listeners;
    }
    instance = instance.return;
  }
  return [];
}
function getParent(inst) {
  if (inst === null) {
    return null;
  }
  do {
    inst = inst.return;
  } while (inst && inst.tag !== HostComponent && inst.tag !== HostSingleton);
  if (inst) {
    return inst;
  }
  return null;
}
function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
  const registrationName = event._reactName;
  const listeners = [];
  let instance = target;
  while (instance !== null) {
    if (instance === common) {
      break;
    }
    const { alternate, stateNode, tag } = instance;
    if (alternate !== null && alternate === common) {
      break;
    }
    if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && stateNode !== null) {
      const currentTarget = stateNode;
      if (inCapturePhase) {
        const captureListener = getListener(instance, registrationName);
        if (captureListener != null) {
          listeners.unshift(
            createDispatchListener(instance, captureListener, currentTarget)
          );
        }
      } else if (!inCapturePhase) {
        const bubbleListener = getListener(instance, registrationName);
        if (bubbleListener != null) {
          listeners.push(
            createDispatchListener(instance, bubbleListener, currentTarget)
          );
        }
      }
    }
    instance = instance.return;
  }
  if (listeners.length !== 0) {
    dispatchQueue.push({ event, listeners });
  }
}
function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
  const common = from && to ? getLowestCommonAncestor(from, to, getParent) : null;
  if (from !== null) {
    accumulateEnterLeaveListenersForEvent(
      dispatchQueue,
      leaveEvent,
      from,
      common,
      false
    );
  }
  if (to !== null && enterEvent !== null) {
    accumulateEnterLeaveListenersForEvent(
      dispatchQueue,
      enterEvent,
      to,
      common,
      true
    );
  }
}
function accumulateEventHandleNonManagedNodeListeners(reactEventType, currentTarget, inCapturePhase) {
  const listeners = [];
  const eventListeners = getEventHandlerListeners(currentTarget);
  if (eventListeners !== null) {
    eventListeners.forEach((entry) => {
      if (entry.type === reactEventType && entry.capture === inCapturePhase) {
        listeners.push(
          createDispatchListener(null, entry.callback, currentTarget)
        );
      }
    });
  }
  return listeners;
}
function getListenerSetKey(domEventName, capture) {
  return `${domEventName}__${capture ? "capture" : "bubble"}`;
}

// dist/react-dom-bindings/src/client/ReactDOMComponent.js
if (false) {
  didWarnForNewBooleanPropsWithEmptyValue = {};
}
function trapClickOnNonInteractiveElement(node) {
  node.onclick = noop;
}
var xlinkNamespace = "http://www.w3.org/1999/xlink";
var xmlNamespace = "http://www.w3.org/XML/1998/namespace";
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children": {
      if (typeof value === "string") {
        if (false) {
          validateTextNesting(value, tag, false);
        }
        const canSetTextContent = tag !== "body" && (tag !== "textarea" || value !== "");
        if (canSetTextContent) {
          setTextContent_default(domElement, value);
        }
      } else if (typeof value === "number" || typeof value === "bigint") {
        if (false) {
          validateTextNesting("" + value, tag, false);
        }
        const canSetTextContent = tag !== "body";
        if (canSetTextContent) {
          setTextContent_default(domElement, "" + value);
        }
      } else {
        return;
      }
      break;
    }
    // These are very common props and therefore are in the beginning of the switch.
    // TODO: aria-label is a very common prop but allows booleans so is not like the others
    // but should ideally go in this list too.
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height": {
      setValueForKnownAttribute(domElement, key, value);
      break;
    }
    case "style": {
      setValueForStyles(domElement, value, prevValue);
      return;
    }
    // These attributes accept URLs. These must not allow javascript: URLS.
    case "data":
      if (tag !== "object") {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    // fallthrough
    case "src": {
      if (enableSrcObject && typeof value === "object" && value !== null) {
        if (tag === "img" || tag === "video" || tag === "audio") {
          try {
            setSrcObject(domElement, tag, value);
            break;
          } catch (x) {
          }
        } else {
          if (false) {
            try {
              URL.revokeObjectURL(URL.createObjectURL(value));
              if (tag === "source") {
                console.error(
                  "Passing Blob, MediaSource or MediaStream to <source src> is not supported. Pass it directly to <img src>, <video src> or <audio src> instead."
                );
              } else {
                console.error(
                  "Passing Blob, MediaSource or MediaStream to <%s src> is not supported.",
                  tag
                );
              }
            } catch (x) {
            }
          }
        }
      }
    }
    case "href": {
      if (value === "" && // <a href=""> is fine for "reload" links.
      !(tag === "a" && key === "href")) {
        if (false) {
          if (key === "src") {
            console.error(
              'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
              key,
              key
            );
          } else {
            console.error(
              'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
              key,
              key
            );
          }
        }
        domElement.removeAttribute(key);
        break;
      }
      if (value == null || typeof value === "function" || typeof value === "symbol" || typeof value === "boolean") {
        domElement.removeAttribute(key);
        break;
      }
      if (false) {
        checkAttributeStringCoercion(value, key);
      }
      const sanitizedValue = sanitizeURL_default(
        enableTrustedTypesIntegration ? value : "" + value
      );
      domElement.setAttribute(key, sanitizedValue);
      break;
    }
    case "action":
    case "formAction": {
      if (false) {
        validateFormActionInDevelopment(tag, key, value, props);
      }
      if (typeof value === "function") {
        domElement.setAttribute(
          key,
          // eslint-disable-next-line no-script-url
          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
        );
        break;
      } else if (typeof prevValue === "function") {
        if (key === "formAction") {
          if (tag !== "input") {
            setProp(domElement, tag, "name", props.name, props, null);
          }
          setProp(
            domElement,
            tag,
            "formEncType",
            props.formEncType,
            props,
            null
          );
          setProp(domElement, tag, "formMethod", props.formMethod, props, null);
          setProp(domElement, tag, "formTarget", props.formTarget, props, null);
        } else {
          setProp(domElement, tag, "encType", props.encType, props, null);
          setProp(domElement, tag, "method", props.method, props, null);
          setProp(domElement, tag, "target", props.target, props, null);
        }
      }
      if (value == null || typeof value === "symbol" || typeof value === "boolean") {
        domElement.removeAttribute(key);
        break;
      }
      if (false) {
        checkAttributeStringCoercion(value, key);
      }
      const sanitizedValue = sanitizeURL_default(
        enableTrustedTypesIntegration ? value : "" + value
      );
      domElement.setAttribute(key, sanitizedValue);
      break;
    }
    case "onClick": {
      if (value != null) {
        if (false) {
          warnForInvalidEventListener(key, value);
        }
        trapClickOnNonInteractiveElement(domElement);
      }
      return;
    }
    case "onScroll": {
      if (value != null) {
        if (false) {
          warnForInvalidEventListener(key, value);
        }
        listenToNonDelegatedEvent("scroll", domElement);
      }
      return;
    }
    case "onScrollEnd": {
      if (value != null) {
        if (false) {
          warnForInvalidEventListener(key, value);
        }
        listenToNonDelegatedEvent("scrollend", domElement);
        if (enableScrollEndPolyfill) {
          listenToNonDelegatedEvent("scroll", domElement);
        }
      }
      return;
    }
    case "dangerouslySetInnerHTML": {
      if (value != null) {
        if (typeof value !== "object" || !("__html" in value)) {
          throw new Error(
            "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
          );
        }
        const nextHtml = value.__html;
        if (nextHtml != null) {
          if (props.children != null) {
            throw new Error(
              "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
            );
          }
          domElement.innerHTML = nextHtml;
        }
      }
      break;
    }
    // Note: `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`. We have special logic for handling this.
    case "multiple": {
      domElement.multiple = value && typeof value !== "function" && typeof value !== "symbol";
      break;
    }
    case "muted": {
      domElement.muted = value && typeof value !== "function" && typeof value !== "symbol";
      break;
    }
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    // Reserved
    case "defaultChecked":
    case "innerHTML":
    case "ref": {
      break;
    }
    case "autoFocus": {
      break;
    }
    case "xlinkHref": {
      if (value == null || typeof value === "function" || typeof value === "boolean" || typeof value === "symbol") {
        domElement.removeAttribute("xlink:href");
        break;
      }
      if (false) {
        checkAttributeStringCoercion(value, key);
      }
      const sanitizedValue = sanitizeURL_default(
        enableTrustedTypesIntegration ? value : "" + value
      );
      domElement.setAttributeNS(xlinkNamespace, "xlink:href", sanitizedValue);
      break;
    }
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha": {
      if (value != null && typeof value !== "function" && typeof value !== "symbol") {
        if (false) {
          checkAttributeStringCoercion(value, key);
        }
        domElement.setAttribute(
          key,
          enableTrustedTypesIntegration ? value : "" + value
        );
      } else {
        domElement.removeAttribute(key);
      }
      break;
    }
    // Boolean
    case "inert": {
      if (false) {
        if (value === "" && !didWarnForNewBooleanPropsWithEmptyValue[key]) {
          didWarnForNewBooleanPropsWithEmptyValue[key] = true;
          console.error(
            "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
            key
          );
        }
      }
    }
    // Fallthrough for boolean props that don't have a warning for empty strings.
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope": {
      if (value && typeof value !== "function" && typeof value !== "symbol") {
        domElement.setAttribute(key, "");
      } else {
        domElement.removeAttribute(key);
      }
      break;
    }
    // Overloaded Boolean
    case "capture":
    case "download": {
      if (value === true) {
        domElement.setAttribute(key, "");
      } else if (value !== false && value != null && typeof value !== "function" && typeof value !== "symbol") {
        if (false) {
          checkAttributeStringCoercion(value, key);
        }
        domElement.setAttribute(key, value);
      } else {
        domElement.removeAttribute(key);
      }
      break;
    }
    case "cols":
    case "rows":
    case "size":
    case "span": {
      if (value != null && typeof value !== "function" && typeof value !== "symbol" && !isNaN(value) && value >= 1) {
        if (false) {
          checkAttributeStringCoercion(value, key);
        }
        domElement.setAttribute(key, value);
      } else {
        domElement.removeAttribute(key);
      }
      break;
    }
    case "rowSpan":
    case "start": {
      if (value != null && typeof value !== "function" && typeof value !== "symbol" && !isNaN(value)) {
        if (false) {
          checkAttributeStringCoercion(value, key);
        }
        domElement.setAttribute(key, value);
      } else {
        domElement.removeAttribute(key);
      }
      break;
    }
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(
        domElement,
        xlinkNamespace,
        "xlink:actuate",
        value
      );
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(
        domElement,
        xlinkNamespace,
        "xlink:arcrole",
        value
      );
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(
        domElement,
        xlinkNamespace,
        "xlink:role",
        value
      );
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(
        domElement,
        xlinkNamespace,
        "xlink:show",
        value
      );
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(
        domElement,
        xlinkNamespace,
        "xlink:title",
        value
      );
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(
        domElement,
        xlinkNamespace,
        "xlink:type",
        value
      );
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(
        domElement,
        xmlNamespace,
        "xml:base",
        value
      );
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(
        domElement,
        xmlNamespace,
        "xml:lang",
        value
      );
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(
        domElement,
        xmlNamespace,
        "xml:space",
        value
      );
      break;
    // Properties that should not be allowed on custom elements.
    case "is": {
      if (false) {
        if (prevValue != null) {
          console.error(
            'Cannot update the "is" prop after it has been initialized.'
          );
        }
      }
      setValueForAttribute(domElement, "is", value);
      break;
    }
    case "innerText":
    case "textContent":
      return;
    case "popoverTarget":
      if (false) {
        if (!didWarnPopoverTargetObject && value != null && typeof value === "object") {
          didWarnPopoverTargetObject = true;
          console.error(
            "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
            value
          );
        }
      }
    // Fall through
    default: {
      if (key.length > 2 && (key[0] === "o" || key[0] === "O") && (key[1] === "n" || key[1] === "N")) {
        if (false) {
          warnForInvalidEventListener(key, value);
        }
        return;
      } else {
        const attributeName = getAttributeAlias_default(key);
        setValueForAttribute(domElement, attributeName, value);
      }
    }
  }
  trackHostMutation();
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style": {
      setValueForStyles(domElement, value, prevValue);
      return;
    }
    case "dangerouslySetInnerHTML": {
      if (value != null) {
        if (typeof value !== "object" || !("__html" in value)) {
          throw new Error(
            "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
          );
        }
        const nextHtml = value.__html;
        if (nextHtml != null) {
          if (props.children != null) {
            throw new Error(
              "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
            );
          }
          domElement.innerHTML = nextHtml;
        }
      }
      break;
    }
    case "children": {
      if (typeof value === "string") {
        setTextContent_default(domElement, value);
      } else if (typeof value === "number" || typeof value === "bigint") {
        setTextContent_default(domElement, "" + value);
      } else {
        return;
      }
      break;
    }
    case "onScroll": {
      if (value != null) {
        if (false) {
          warnForInvalidEventListener(key, value);
        }
        listenToNonDelegatedEvent("scroll", domElement);
      }
      return;
    }
    case "onScrollEnd": {
      if (value != null) {
        if (false) {
          warnForInvalidEventListener(key, value);
        }
        listenToNonDelegatedEvent("scrollend", domElement);
        if (enableScrollEndPolyfill) {
          listenToNonDelegatedEvent("scroll", domElement);
        }
      }
      return;
    }
    case "onClick": {
      if (value != null) {
        if (false) {
          warnForInvalidEventListener(key, value);
        }
        trapClickOnNonInteractiveElement(domElement);
      }
      return;
    }
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref": {
      return;
    }
    case "innerText":
    // Properties
    case "textContent":
      return;
    // Fall through
    default: {
      if (registrationNameDependencies.hasOwnProperty(key)) {
        if (false) {
          warnForInvalidEventListener(key, value);
        }
        return;
      } else {
        setValueForPropertyOnCustomComponent(domElement, key, value);
        return;
      }
    }
  }
  trackHostMutation();
}
function setInitialProperties(domElement, tag, props) {
  if (false) {
    validatePropertiesInDevelopment(tag, props);
  }
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li": {
      break;
    }
    // img tags previously were implemented as void elements with non delegated events however Safari (and possibly Firefox)
    // begin fetching the image as soon as the `src` or `srcSet` property is set and if we set these before other properties
    // that can modify the request (such as crossorigin) or the resource fetch (such as sizes) then the browser will load
    // the wrong thing or load more than one thing. This implementation ensures src and srcSet are set on the instance last
    case "img": {
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      let hasSrc = false;
      let hasSrcSet = false;
      for (const propKey in props) {
        if (!props.hasOwnProperty(propKey)) {
          continue;
        }
        const propValue = props[propKey];
        if (propValue == null) {
          continue;
        }
        switch (propKey) {
          case "src":
            hasSrc = true;
            break;
          case "srcSet":
            hasSrcSet = true;
            break;
          case "children":
          case "dangerouslySetInnerHTML": {
            throw new Error(
              `${tag} is a void element tag and must neither have \`children\` nor use \`dangerouslySetInnerHTML\`.`
            );
          }
          // defaultChecked and defaultValue are ignored by setProp
          default: {
            setProp(domElement, tag, propKey, propValue, props, null);
          }
        }
      }
      if (hasSrcSet) {
        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      }
      if (hasSrc) {
        setProp(domElement, tag, "src", props.src, props, null);
      }
      return;
    }
    case "input": {
      if (false) {
        checkControlledValueProps("input", props);
      }
      listenToNonDelegatedEvent("invalid", domElement);
      let name = null;
      let type = null;
      let value = null;
      let defaultValue = null;
      let checked = null;
      let defaultChecked = null;
      for (const propKey in props) {
        if (!props.hasOwnProperty(propKey)) {
          continue;
        }
        const propValue = props[propKey];
        if (propValue == null) {
          continue;
        }
        switch (propKey) {
          case "name": {
            name = propValue;
            break;
          }
          case "type": {
            type = propValue;
            break;
          }
          case "checked": {
            checked = propValue;
            break;
          }
          case "defaultChecked": {
            defaultChecked = propValue;
            break;
          }
          case "value": {
            value = propValue;
            break;
          }
          case "defaultValue": {
            defaultValue = propValue;
            break;
          }
          case "children":
          case "dangerouslySetInnerHTML": {
            if (propValue != null) {
              throw new Error(
                `${tag} is a void element tag and must neither have \`children\` nor use \`dangerouslySetInnerHTML\`.`
              );
            }
            break;
          }
          default: {
            setProp(domElement, tag, propKey, propValue, props, null);
          }
        }
      }
      validateInputProps(domElement, props);
      initInput(
        domElement,
        value,
        defaultValue,
        checked,
        defaultChecked,
        type,
        name,
        false
      );
      return;
    }
    case "select": {
      if (false) {
        checkControlledValueProps("select", props);
      }
      listenToNonDelegatedEvent("invalid", domElement);
      let value = null;
      let defaultValue = null;
      let multiple = null;
      for (const propKey in props) {
        if (!props.hasOwnProperty(propKey)) {
          continue;
        }
        const propValue = props[propKey];
        if (propValue == null) {
          continue;
        }
        switch (propKey) {
          case "value": {
            value = propValue;
            break;
          }
          case "defaultValue": {
            defaultValue = propValue;
            break;
          }
          case "multiple": {
            multiple = propValue;
          }
          // Fallthrough
          default: {
            setProp(domElement, tag, propKey, propValue, props, null);
          }
        }
      }
      validateSelectProps(domElement, props);
      initSelect(domElement, value, defaultValue, multiple);
      return;
    }
    case "textarea": {
      if (false) {
        checkControlledValueProps("textarea", props);
      }
      listenToNonDelegatedEvent("invalid", domElement);
      let value = null;
      let defaultValue = null;
      let children = null;
      for (const propKey in props) {
        if (!props.hasOwnProperty(propKey)) {
          continue;
        }
        const propValue = props[propKey];
        if (propValue == null) {
          continue;
        }
        switch (propKey) {
          case "value": {
            value = propValue;
            break;
          }
          case "defaultValue": {
            defaultValue = propValue;
            break;
          }
          case "children": {
            children = propValue;
            break;
          }
          case "dangerouslySetInnerHTML": {
            if (propValue != null) {
              throw new Error(
                "`dangerouslySetInnerHTML` does not make sense on <textarea>."
              );
            }
            break;
          }
          default: {
            setProp(domElement, tag, propKey, propValue, props, null);
          }
        }
      }
      validateTextareaProps(domElement, props);
      initTextarea(domElement, value, defaultValue, children);
      return;
    }
    case "option": {
      validateOptionProps(domElement, props);
      for (const propKey in props) {
        if (!props.hasOwnProperty(propKey)) {
          continue;
        }
        const propValue = props[propKey];
        if (propValue == null) {
          continue;
        }
        switch (propKey) {
          case "selected": {
            domElement.selected = propValue && typeof propValue !== "function" && typeof propValue !== "symbol";
            break;
          }
          default: {
            setProp(domElement, tag, propKey, propValue, props, null);
          }
        }
      }
      return;
    }
    case "dialog": {
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    }
    case "iframe":
    case "object": {
      listenToNonDelegatedEvent("load", domElement);
      break;
    }
    case "video":
    case "audio": {
      for (let i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }
      break;
    }
    case "image": {
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    }
    case "details": {
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    }
    case "embed":
    case "source":
    case "link": {
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
    }
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem": {
      for (const propKey in props) {
        if (!props.hasOwnProperty(propKey)) {
          continue;
        }
        const propValue = props[propKey];
        if (propValue == null) {
          continue;
        }
        switch (propKey) {
          case "children":
          case "dangerouslySetInnerHTML": {
            throw new Error(
              `${tag} is a void element tag and must neither have \`children\` nor use \`dangerouslySetInnerHTML\`.`
            );
          }
          // defaultChecked and defaultValue are ignored by setProp
          default: {
            setProp(domElement, tag, propKey, propValue, props, null);
          }
        }
      }
      return;
    }
    default: {
      if (isCustomElement_default(tag, props)) {
        for (const propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          const propValue = props[propKey];
          if (propValue === void 0) {
            continue;
          }
          setPropOnCustomElement(
            domElement,
            tag,
            propKey,
            propValue,
            props,
            void 0
          );
        }
        return;
      }
    }
  }
  for (const propKey in props) {
    if (!props.hasOwnProperty(propKey)) {
      continue;
    }
    const propValue = props[propKey];
    if (propValue == null) {
      continue;
    }
    setProp(domElement, tag, propKey, propValue, props, null);
  }
}
function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case "input":
      restoreControlledInputState(domElement, props);
      return;
    case "textarea":
      restoreControlledTextareaState(domElement, props);
      return;
    case "select":
      restoreControlledSelectState(domElement, props);
      return;
  }
}

// dist/react-dom-bindings/src/client/ReactFiberConfigDOM.js
var ACTIVITY_START_DATA = "&";
var ACTIVITY_END_DATA = "/&";
var SUSPENSE_START_DATA = "$";
var SUSPENSE_END_DATA = "/$";
var SUSPENSE_PENDING_START_DATA = "$?";
var SUSPENSE_QUEUED_START_DATA = "$~";
var SUSPENSE_FALLBACK_START_DATA = "$!";
var supportsMoveBefore = (
  // $FlowFixMe[prop-missing]: We're doing the feature detection here.
  enableMoveBefore && typeof window !== "undefined" && typeof window.Element.prototype.moveBefore === "function"
);
function ViewTransitionPseudoElement(pseudo, name) {
  this._scope = document.documentElement;
  this._selector = "::view-transition-" + pseudo + "(" + name + ")";
}
ViewTransitionPseudoElement.prototype.animate = function(keyframes, options) {
  const opts = typeof options === "number" ? {
    duration: options
  } : Object.assign({}, options);
  opts.pseudoElement = this._selector;
  return this._scope.animate(keyframes, opts);
};
ViewTransitionPseudoElement.prototype.getAnimations = function(options) {
  const scope = this._scope;
  const selector = this._selector;
  const animations = scope.getAnimations({ subtree: true });
  const result = [];
  for (let i = 0; i < animations.length; i++) {
    const effect = animations[i].effect;
    if (effect !== null && effect.target === scope && effect.pseudoElement === selector) {
      result.push(animations[i]);
    }
  }
  return result;
};
ViewTransitionPseudoElement.prototype.getComputedStyle = function() {
  const scope = this._scope;
  const selector = this._selector;
  return getComputedStyle(scope, selector);
};
function FragmentInstance(fragmentFiber) {
  this._fragmentFiber = fragmentFiber;
  this._eventListeners = null;
  this._observers = null;
}
FragmentInstance.prototype.addEventListener = function(type, listener, optionsOrUseCapture) {
  if (this._eventListeners === null) {
    this._eventListeners = [];
  }
  const listeners = this._eventListeners;
  const isNewEventListener = indexOfEventListener(listeners, type, listener, optionsOrUseCapture) === -1;
  if (isNewEventListener) {
    listeners.push({ type, listener, optionsOrUseCapture });
    traverseFragmentInstance(
      this._fragmentFiber,
      addEventListenerToChild,
      type,
      listener,
      optionsOrUseCapture
    );
  }
  this._eventListeners = listeners;
};
function addEventListenerToChild(child, type, listener, optionsOrUseCapture) {
  const instance = getInstanceFromHostFiber(child);
  instance.addEventListener(type, listener, optionsOrUseCapture);
  return false;
}
FragmentInstance.prototype.removeEventListener = function(type, listener, optionsOrUseCapture) {
  const listeners = this._eventListeners;
  if (listeners === null) {
    return;
  }
  if (typeof listeners !== "undefined" && listeners.length > 0) {
    traverseFragmentInstance(
      this._fragmentFiber,
      removeEventListenerFromChild,
      type,
      listener,
      optionsOrUseCapture
    );
    const index2 = indexOfEventListener(
      listeners,
      type,
      listener,
      optionsOrUseCapture
    );
    if (this._eventListeners !== null) {
      this._eventListeners.splice(index2, 1);
    }
  }
};
function removeEventListenerFromChild(child, type, listener, optionsOrUseCapture) {
  const instance = getInstanceFromHostFiber(child);
  instance.removeEventListener(type, listener, optionsOrUseCapture);
  return false;
}
FragmentInstance.prototype.dispatchEvent = function(event) {
  const parentHostFiber = getFragmentParentHostFiber(this._fragmentFiber);
  if (parentHostFiber === null) {
    return true;
  }
  const parentHostInstance = getInstanceFromHostFiber(parentHostFiber);
  const eventListeners = this._eventListeners;
  if (eventListeners !== null && eventListeners.length > 0 || !event.bubbles) {
    const temp = document.createTextNode("");
    if (eventListeners) {
      for (let i = 0; i < eventListeners.length; i++) {
        const { type, listener, optionsOrUseCapture } = eventListeners[i];
        temp.addEventListener(type, listener, optionsOrUseCapture);
      }
    }
    parentHostInstance.appendChild(temp);
    const cancelable = temp.dispatchEvent(event);
    if (eventListeners) {
      for (let i = 0; i < eventListeners.length; i++) {
        const { type, listener, optionsOrUseCapture } = eventListeners[i];
        temp.removeEventListener(type, listener, optionsOrUseCapture);
      }
    }
    parentHostInstance.removeChild(temp);
    return cancelable;
  } else {
    return parentHostInstance.dispatchEvent(event);
  }
};
FragmentInstance.prototype.focus = function(focusOptions) {
  traverseFragmentInstanceDeeply(
    this._fragmentFiber,
    setFocusOnFiberIfFocusable,
    focusOptions
  );
};
function setFocusOnFiberIfFocusable(fiber, focusOptions) {
  const instance = getInstanceFromHostFiber(fiber);
  return setFocusIfFocusable2(instance, focusOptions);
}
FragmentInstance.prototype.focusLast = function(focusOptions) {
  const children = [];
  traverseFragmentInstanceDeeply(
    this._fragmentFiber,
    collectChildren,
    children
  );
  for (let i = children.length - 1; i >= 0; i--) {
    const child = children[i];
    if (setFocusOnFiberIfFocusable(child, focusOptions)) {
      break;
    }
  }
};
function collectChildren(child, collection) {
  collection.push(child);
  return false;
}
FragmentInstance.prototype.blur = function() {
  traverseFragmentInstance(
    this._fragmentFiber,
    blurActiveElementWithinFragment
  );
};
function blurActiveElementWithinFragment(child) {
  const instance = getInstanceFromHostFiber(child);
  const ownerDocument = instance.ownerDocument;
  if (instance === ownerDocument.activeElement) {
    instance.blur();
    return true;
  }
  return false;
}
FragmentInstance.prototype.observeUsing = function(observer) {
  if (this._observers === null) {
    this._observers = /* @__PURE__ */ new Set();
  }
  this._observers.add(observer);
  traverseFragmentInstance(this._fragmentFiber, observeChild, observer);
};
function observeChild(child, observer) {
  const instance = getInstanceFromHostFiber(child);
  observer.observe(instance);
  return false;
}
FragmentInstance.prototype.unobserveUsing = function(observer) {
  if (this._observers === null || !this._observers.has(observer)) {
    if (false) {
      console.error(
        "You are calling unobserveUsing() with an observer that is not being observed with this fragment instance. First attach the observer with observeUsing()"
      );
    }
  } else {
    this._observers.delete(observer);
    traverseFragmentInstance(this._fragmentFiber, unobserveChild, observer);
  }
};
function unobserveChild(child, observer) {
  const instance = getInstanceFromHostFiber(child);
  observer.unobserve(instance);
  return false;
}
FragmentInstance.prototype.getClientRects = function() {
  const rects = [];
  traverseFragmentInstance(this._fragmentFiber, collectClientRects, rects);
  return rects;
};
function collectClientRects(child, rects) {
  const instance = getInstanceFromHostFiber(child);
  rects.push.apply(rects, instance.getClientRects());
  return false;
}
FragmentInstance.prototype.getRootNode = function(getRootNodeOptions) {
  const parentHostFiber = getFragmentParentHostFiber(this._fragmentFiber);
  if (parentHostFiber === null) {
    return this;
  }
  const parentHostInstance = getInstanceFromHostFiber(parentHostFiber);
  const rootNode = (
    // $FlowFixMe[incompatible-cast] Flow expects Node
    parentHostInstance.getRootNode(getRootNodeOptions)
  );
  return rootNode;
};
FragmentInstance.prototype.compareDocumentPosition = function(otherNode) {
  const parentHostFiber = getFragmentParentHostFiber(this._fragmentFiber);
  if (parentHostFiber === null) {
    return Node.DOCUMENT_POSITION_DISCONNECTED;
  }
  const children = [];
  traverseFragmentInstance(this._fragmentFiber, collectChildren, children);
  let result = Node.DOCUMENT_POSITION_DISCONNECTED;
  if (children.length === 0) {
    const parentHostInstance = getInstanceFromHostFiber(parentHostFiber);
    const parentResult = parentHostInstance.compareDocumentPosition(otherNode);
    result = parentResult;
    if (parentHostInstance === otherNode) {
      result = Node.DOCUMENT_POSITION_CONTAINS;
    } else {
      if (parentResult & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        const nextSiblingFiber = getNextSiblingHostFiber(this._fragmentFiber);
        if (nextSiblingFiber === null) {
          result = Node.DOCUMENT_POSITION_PRECEDING;
        } else {
          const nextSiblingInstance = getInstanceFromHostFiber(nextSiblingFiber);
          const nextSiblingResult = nextSiblingInstance.compareDocumentPosition(otherNode);
          if (nextSiblingResult === 0 || nextSiblingResult & Node.DOCUMENT_POSITION_FOLLOWING) {
            result = Node.DOCUMENT_POSITION_FOLLOWING;
          } else {
            result = Node.DOCUMENT_POSITION_PRECEDING;
          }
        }
      }
    }
    result |= Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
    return result;
  }
  const firstElement = getInstanceFromHostFiber(children[0]);
  const lastElement = getInstanceFromHostFiber(
    children[children.length - 1]
  );
  const firstResult = firstElement.compareDocumentPosition(otherNode);
  const lastResult = lastElement.compareDocumentPosition(otherNode);
  if (firstResult & Node.DOCUMENT_POSITION_FOLLOWING && lastResult & Node.DOCUMENT_POSITION_PRECEDING || otherNode === firstElement || otherNode === lastElement) {
    result = Node.DOCUMENT_POSITION_CONTAINED_BY;
  } else {
    result = firstResult;
  }
  if (result & Node.DOCUMENT_POSITION_DISCONNECTED || result & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
    return result;
  }
  const documentPositionMatchesFiberPosition = validateDocumentPositionWithFiberTree(
    result,
    this._fragmentFiber,
    children[0],
    children[children.length - 1],
    otherNode
  );
  if (documentPositionMatchesFiberPosition) {
    return result;
  }
  return Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
};
function validateDocumentPositionWithFiberTree(documentPosition, fragmentFiber, precedingBoundaryFiber, followingBoundaryFiber, otherNode) {
  const otherFiber = getClosestInstanceFromNode(otherNode);
  if (documentPosition & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return !!otherFiber && isFiberContainedBy(fragmentFiber, otherFiber);
  }
  if (documentPosition & Node.DOCUMENT_POSITION_CONTAINS) {
    if (otherFiber === null) {
      const ownerDocument = otherNode.ownerDocument;
      return otherNode === ownerDocument || otherNode === ownerDocument.body;
    }
    return isFiberContainedBy(otherFiber, fragmentFiber);
  }
  if (documentPosition & Node.DOCUMENT_POSITION_PRECEDING) {
    return !!otherFiber && (otherFiber === precedingBoundaryFiber || isFiberPreceding(precedingBoundaryFiber, otherFiber));
  }
  if (documentPosition & Node.DOCUMENT_POSITION_FOLLOWING) {
    return !!otherFiber && (otherFiber === followingBoundaryFiber || isFiberFollowing(followingBoundaryFiber, otherFiber));
  }
  return false;
}
function normalizeListenerOptions(opts) {
  if (opts == null) {
    return "0";
  }
  if (typeof opts === "boolean") {
    return `c=${opts ? "1" : "0"}`;
  }
  return `c=${opts.capture ? "1" : "0"}&o=${opts.once ? "1" : "0"}&p=${opts.passive ? "1" : "0"}`;
}
function indexOfEventListener(eventListeners, type, listener, optionsOrUseCapture) {
  for (let i = 0; i < eventListeners.length; i++) {
    const item = eventListeners[i];
    if (item.type === type && item.listener === listener && normalizeListenerOptions(item.optionsOrUseCapture) === normalizeListenerOptions(optionsOrUseCapture)) {
      return i;
    }
  }
  return -1;
}
function getParentHydrationBoundary(targetInstance) {
  let node = targetInstance.previousSibling;
  let depth = 0;
  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      const data = node.data;
      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_QUEUED_START_DATA || data === ACTIVITY_START_DATA) {
        if (depth === 0) {
          return node;
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_END_DATA || data === ACTIVITY_END_DATA) {
        depth++;
      }
    }
    node = node.previousSibling;
  }
  return null;
}
function setFocusIfFocusable2(node, focusOptions) {
  let didFocus = false;
  const handleFocus = () => {
    didFocus = true;
  };
  const element = node;
  try {
    element.addEventListener("focus", handleFocus);
    (element.focus || HTMLElement.prototype.focus).call(element, focusOptions);
  } finally {
    element.removeEventListener("focus", handleFocus);
  }
  return didFocus;
}
var NotLoaded = (
  /*       */
  0
);
var Loaded = (
  /*          */
  1
);
var Errored = (
  /*         */
  2
);
var Inserted = (
  /*        */
  4
);
var preloadPropsMap = /* @__PURE__ */ new Map();
var preconnectsSet = /* @__PURE__ */ new Set();
var previousDispatcher = ReactDOMSharedInternals_default2.d;
ReactDOMSharedInternals_default2.d = {
  f: disableLegacyMode ? flushSyncWork2 : previousDispatcher.f,
  r: requestFormReset4,
  D: prefetchDNS2,
  C: preconnect2,
  L: preload2,
  m: preloadModule2,
  X: preinitScript,
  S: preinitStyle,
  M: preinitModuleScript
};
function flushSyncWork2() {
  if (disableLegacyMode) {
    const previousWasRendering = previousDispatcher.f();
    const wasRendering = flushSyncWork();
    return previousWasRendering || wasRendering;
  } else {
    throw new Error(
      "flushSyncWork should not be called from builds that support legacy mode. This is a bug in React."
    );
  }
}
function requestFormReset4(form) {
  const formInst = getInstanceFromNode3(form);
  if (formInst !== null && formInst.tag === HostComponent && formInst.type === "form") {
    requestFormReset(formInst);
  } else {
    previousDispatcher.r(
      /* requestFormReset */
      form
    );
  }
}
var globalDocument = typeof document === "undefined" ? null : document;
function getGlobalDocument() {
  return globalDocument;
}
function preconnectAs(rel, href, crossOrigin) {
  const ownerDocument = getGlobalDocument();
  if (ownerDocument && typeof href === "string" && href) {
    const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
    let key = `link[rel="${rel}"][href="${limitedEscapedHref}"]`;
    if (typeof crossOrigin === "string") {
      key += `[crossorigin="${crossOrigin}"]`;
    }
    if (!preconnectsSet.has(key)) {
      preconnectsSet.add(key);
      const preconnectProps = { rel, crossOrigin, href };
      if (null === ownerDocument.querySelector(key)) {
        const instance = ownerDocument.createElement("link");
        setInitialProperties(instance, "link", preconnectProps);
        markNodeAsHoistable(instance);
        ownerDocument.head.appendChild(instance);
      }
    }
  }
}
function prefetchDNS2(href) {
  previousDispatcher.D(
    /* prefetchDNS */
    href
  );
  preconnectAs("dns-prefetch", href, null);
}
function preconnect2(href, crossOrigin) {
  previousDispatcher.C(
    /* preconnect */
    href,
    crossOrigin
  );
  preconnectAs("preconnect", href, crossOrigin);
}
function preload2(href, as, options) {
  previousDispatcher.L(
    /* preload */
    href,
    as,
    options
  );
  const ownerDocument = getGlobalDocument();
  if (ownerDocument && href && as) {
    let preloadSelector = `link[rel="preload"][as="${escapeSelectorAttributeValueInsideDoubleQuotes(
      as
    )}"]`;
    if (as === "image") {
      if (options && options.imageSrcSet) {
        preloadSelector += `[imagesrcset="${escapeSelectorAttributeValueInsideDoubleQuotes(
          options.imageSrcSet
        )}"]`;
        if (typeof options.imageSizes === "string") {
          preloadSelector += `[imagesizes="${escapeSelectorAttributeValueInsideDoubleQuotes(
            options.imageSizes
          )}"]`;
        }
      } else {
        preloadSelector += `[href="${escapeSelectorAttributeValueInsideDoubleQuotes(
          href
        )}"]`;
      }
    } else {
      preloadSelector += `[href="${escapeSelectorAttributeValueInsideDoubleQuotes(
        href
      )}"]`;
    }
    let key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
        break;
    }
    if (!preloadPropsMap.has(key)) {
      const preloadProps = Object.assign(
        {
          rel: "preload",
          // There is a bug in Safari where imageSrcSet is not respected on preload links
          // so we omit the href here if we have imageSrcSet b/c safari will load the wrong image.
          // This harms older browers that do not support imageSrcSet by making their preloads not work
          // but this population is shrinking fast and is already small so we accept this tradeoff.
          href: as === "image" && options && options.imageSrcSet ? void 0 : href,
          as
        },
        options
      );
      preloadPropsMap.set(key, preloadProps);
      if (null === ownerDocument.querySelector(preloadSelector)) {
        if (as === "style" && ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) {
          return;
        } else if (as === "script" && ownerDocument.querySelector(getScriptSelectorFromKey(key))) {
          return;
        }
        const instance = ownerDocument.createElement("link");
        setInitialProperties(instance, "link", preloadProps);
        markNodeAsHoistable(instance);
        ownerDocument.head.appendChild(instance);
      }
    }
  }
}
function preloadModule2(href, options) {
  previousDispatcher.m(
    /* preloadModule */
    href,
    options
  );
  const ownerDocument = getGlobalDocument();
  if (ownerDocument && href) {
    const as = options && typeof options.as === "string" ? options.as : "script";
    const preloadSelector = `link[rel="modulepreload"][as="${escapeSelectorAttributeValueInsideDoubleQuotes(
      as
    )}"][href="${escapeSelectorAttributeValueInsideDoubleQuotes(href)}"]`;
    let key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script": {
        key = getScriptKey(href);
        break;
      }
    }
    if (!preloadPropsMap.has(key)) {
      const props = Object.assign(
        {
          rel: "modulepreload",
          href
        },
        options
      );
      preloadPropsMap.set(key, props);
      if (null === ownerDocument.querySelector(preloadSelector)) {
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script": {
            if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) {
              return;
            }
          }
        }
        const instance = ownerDocument.createElement("link");
        setInitialProperties(instance, "link", props);
        markNodeAsHoistable(instance);
        ownerDocument.head.appendChild(instance);
      }
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(
    /* preinitStyle */
    href,
    precedence,
    options
  );
  const ownerDocument = getGlobalDocument();
  if (ownerDocument && href) {
    const styles = getResourcesFromRoot(ownerDocument).hoistableStyles;
    const key = getStyleKey(href);
    precedence = precedence || "default";
    let resource = styles.get(key);
    if (resource) {
      return;
    }
    const state = {
      loading: NotLoaded,
      preload: null
    };
    let instance = ownerDocument.querySelector(
      getStylesheetSelectorFromKey(key)
    );
    if (instance) {
      state.loading = Loaded | Inserted;
    } else {
      const stylesheetProps = Object.assign(
        {
          rel: "stylesheet",
          href,
          "data-precedence": precedence
        },
        options
      );
      const preloadProps = preloadPropsMap.get(key);
      if (preloadProps) {
        adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps);
      }
      const link = instance = ownerDocument.createElement("link");
      markNodeAsHoistable(link);
      setInitialProperties(link, "link", stylesheetProps);
      link._p = new Promise((resolve, reject) => {
        link.onload = resolve;
        link.onerror = reject;
      });
      link.addEventListener("load", () => {
        state.loading |= Loaded;
      });
      link.addEventListener("error", () => {
        state.loading |= Errored;
      });
      state.loading |= Inserted;
      insertStylesheet(instance, precedence, ownerDocument);
    }
    resource = {
      type: "stylesheet",
      instance,
      count: 1,
      state
    };
    styles.set(key, resource);
    return;
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(
    /* preinitScript */
    src,
    options
  );
  const ownerDocument = getGlobalDocument();
  if (ownerDocument && src) {
    const scripts = getResourcesFromRoot(ownerDocument).hoistableScripts;
    const key = getScriptKey(src);
    let resource = scripts.get(key);
    if (resource) {
      return;
    }
    let instance = ownerDocument.querySelector(
      getScriptSelectorFromKey(key)
    );
    if (!instance) {
      const scriptProps = Object.assign(
        {
          src,
          async: true
        },
        options
      );
      const preloadProps = preloadPropsMap.get(key);
      if (preloadProps) {
        adoptPreloadPropsForScript(scriptProps, preloadProps);
      }
      instance = ownerDocument.createElement("script");
      markNodeAsHoistable(instance);
      setInitialProperties(instance, "link", scriptProps);
      ownerDocument.head.appendChild(instance);
    }
    resource = {
      type: "script",
      instance,
      count: 1,
      state: null
    };
    scripts.set(key, resource);
    return;
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(
    /* preinitModuleScript */
    src,
    options
  );
  const ownerDocument = getGlobalDocument();
  if (ownerDocument && src) {
    const scripts = getResourcesFromRoot(ownerDocument).hoistableScripts;
    const key = getScriptKey(src);
    let resource = scripts.get(key);
    if (resource) {
      return;
    }
    let instance = ownerDocument.querySelector(
      getScriptSelectorFromKey(key)
    );
    if (!instance) {
      const scriptProps = Object.assign(
        {
          src,
          async: true,
          type: "module"
        },
        options
      );
      const preloadProps = preloadPropsMap.get(key);
      if (preloadProps) {
        adoptPreloadPropsForScript(scriptProps, preloadProps);
      }
      instance = ownerDocument.createElement("script");
      markNodeAsHoistable(instance);
      setInitialProperties(instance, "link", scriptProps);
      ownerDocument.head.appendChild(instance);
    }
    resource = {
      type: "script",
      instance,
      count: 1,
      state: null
    };
    scripts.set(key, resource);
    return;
  }
}
function getStyleKey(href) {
  const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
  return `href="${limitedEscapedHref}"`;
}
function getStylesheetSelectorFromKey(key) {
  return `link[rel="stylesheet"][${key}]`;
}
function getScriptKey(src) {
  const limitedEscapedSrc = escapeSelectorAttributeValueInsideDoubleQuotes(src);
  return `[src="${limitedEscapedSrc}"]`;
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function insertStylesheet(instance, precedence, root2) {
  const nodes = root2.querySelectorAll(
    'link[rel="stylesheet"][data-precedence],style[data-precedence]'
  );
  const last = nodes.length ? nodes[nodes.length - 1] : null;
  let prior = last;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    const nodePrecedence = node.dataset.precedence;
    if (nodePrecedence === precedence) {
      prior = node;
    } else if (prior !== last) {
      break;
    }
  }
  if (prior) {
    prior.parentNode.insertBefore(instance, prior.nextSibling);
  } else {
    const parent = root2.nodeType === DOCUMENT_NODE ? root2.head : root2;
    parent.insertBefore(instance, parent.firstChild);
  }
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  if (stylesheetProps.crossOrigin == null)
    stylesheetProps.crossOrigin = preloadProps.crossOrigin;
  if (stylesheetProps.referrerPolicy == null)
    stylesheetProps.referrerPolicy = preloadProps.referrerPolicy;
  if (stylesheetProps.title == null) stylesheetProps.title = preloadProps.title;
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  if (scriptProps.crossOrigin == null)
    scriptProps.crossOrigin = preloadProps.crossOrigin;
  if (scriptProps.referrerPolicy == null)
    scriptProps.referrerPolicy = preloadProps.referrerPolicy;
  if (scriptProps.integrity == null)
    scriptProps.integrity = preloadProps.integrity;
}

// dist/react-dom-bindings/src/client/ReactDOMComponentTree.js
var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = "__reactFiber$" + randomKey;
var internalPropsKey = "__reactProps$" + randomKey;
var internalContainerInstanceKey = "__reactContainer$" + randomKey;
var internalEventHandlersKey = "__reactEvents$" + randomKey;
var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
var internalHoistableMarker = "__reactMarker$" + randomKey;
var internalScrollTimer = "__reactScroll$" + randomKey;
function markContainerAsRoot(hostRoot, node) {
  node[internalContainerInstanceKey] = hostRoot;
}
function unmarkContainerAsRoot(node) {
  node[internalContainerInstanceKey] = null;
}
function isContainerMarkedAsRoot(node) {
  return !!node[internalContainerInstanceKey];
}
function getClosestInstanceFromNode(targetNode) {
  let targetInst = targetNode[internalInstanceKey];
  if (targetInst) {
    return targetInst;
  }
  let parentNode = targetNode.parentNode;
  while (parentNode) {
    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
    if (targetInst) {
      const alternate = targetInst.alternate;
      if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
        let hydrationInstance = getParentHydrationBoundary(targetNode);
        while (hydrationInstance !== null) {
          const targetFiber = hydrationInstance[internalInstanceKey];
          if (targetFiber) {
            return targetFiber;
          }
          hydrationInstance = getParentHydrationBoundary(hydrationInstance);
        }
      }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode3(node) {
  const inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
  if (inst) {
    const tag = inst.tag;
    if (tag === HostComponent || tag === HostText || tag === SuspenseComponent || tag === ActivityComponent || tag === HostHoistable || tag === HostSingleton || tag === HostRoot) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}
function getNodeFromInstance(inst) {
  const tag = inst.tag;
  if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {
    return inst.stateNode;
  }
  throw new Error("getNodeFromInstance: Invalid argument.");
}
function getFiberCurrentPropsFromNode(node) {
  return node[internalPropsKey] || null;
}
function getEventListenerSet(node) {
  let elementListenerSet = node[internalEventHandlersKey];
  if (elementListenerSet === void 0) {
    elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
  }
  return elementListenerSet;
}
function getEventHandlerListeners(scope) {
  return scope[internalEventHandlerListenersKey] || null;
}
function getResourcesFromRoot(root2) {
  let resources = root2[internalRootNodeResourcesKey];
  if (!resources) {
    resources = root2[internalRootNodeResourcesKey] = {
      hoistableStyles: /* @__PURE__ */ new Map(),
      hoistableScripts: /* @__PURE__ */ new Map()
    };
  }
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = true;
}
function getScrollEndTimer(node) {
  return node[internalScrollTimer];
}
function setScrollEndTimer(node, timer) {
  node[internalScrollTimer] = timer;
}
function clearScrollEndTimer(node) {
  node[internalScrollTimer] = void 0;
}

// dist/react-dom-bindings/src/events/ReactDOMEventListener.js
var _enabled = true;
function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
  const eventPriority = getEventPriority(domEventName);
  let listenerWrapper;
  switch (eventPriority) {
    case DiscreteEventPriority:
      listenerWrapper = dispatchDiscreteEvent;
      break;
    case ContinuousEventPriority:
      listenerWrapper = dispatchContinuousEvent;
      break;
    case DefaultEventPriority:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  return listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
}
function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  const prevTransition = ReactSharedInternals_default.T;
  ReactSharedInternals_default.T = null;
  const previousPriority = getCurrentUpdatePriority3();
  try {
    setCurrentUpdatePriority3(DiscreteEventPriority);
    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    setCurrentUpdatePriority3(previousPriority);
    ReactSharedInternals_default.T = prevTransition;
  }
}
function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  const prevTransition = ReactSharedInternals_default.T;
  ReactSharedInternals_default.T = null;
  const previousPriority = getCurrentUpdatePriority3();
  try {
    setCurrentUpdatePriority3(ContinuousEventPriority);
    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    setCurrentUpdatePriority3(previousPriority);
    ReactSharedInternals_default.T = prevTransition;
  }
}
function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (!_enabled) {
    return;
  }
  let blockedOn = findInstanceBlockingEvent(nativeEvent);
  if (blockedOn === null) {
    dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      return_targetInst,
      targetContainer
    );
    clearIfContinuousEvent(domEventName, nativeEvent);
    return;
  }
  if (queueIfContinuousEvent(
    blockedOn,
    domEventName,
    eventSystemFlags,
    targetContainer,
    nativeEvent
  )) {
    nativeEvent.stopPropagation();
    return;
  }
  clearIfContinuousEvent(domEventName, nativeEvent);
  if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
    while (blockedOn !== null) {
      const fiber = getInstanceFromNode3(blockedOn);
      if (fiber !== null) {
        attemptSynchronousHydration(fiber);
      }
      const nextBlockedOn = findInstanceBlockingEvent(nativeEvent);
      if (nextBlockedOn === null) {
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          return_targetInst,
          targetContainer
        );
      }
      if (nextBlockedOn === blockedOn) {
        break;
      }
      blockedOn = nextBlockedOn;
    }
    if (blockedOn !== null) {
      nativeEvent.stopPropagation();
    }
    return;
  }
  dispatchEventForPluginEventSystem(
    domEventName,
    eventSystemFlags,
    nativeEvent,
    null,
    targetContainer
  );
}
function findInstanceBlockingEvent(nativeEvent) {
  const nativeEventTarget = getEventTarget_default(nativeEvent);
  return findInstanceBlockingTarget(nativeEventTarget);
}
var return_targetInst = null;
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  let targetInst = getClosestInstanceFromNode(targetNode);
  if (targetInst !== null) {
    const nearestMounted = getNearestMountedFiber(targetInst);
    if (nearestMounted === null) {
      targetInst = null;
    } else {
      const tag = nearestMounted.tag;
      if (tag === SuspenseComponent) {
        const instance = getSuspenseInstanceFromFiber(nearestMounted);
        if (instance !== null) {
          return instance;
        }
        targetInst = null;
      } else if (tag === ActivityComponent) {
        const instance = getActivityInstanceFromFiber(nearestMounted);
        if (instance !== null) {
          return instance;
        }
        targetInst = null;
      } else if (tag === HostRoot) {
        const root2 = nearestMounted.stateNode;
        if (isRootDehydrated(root2)) {
          return getContainerFromFiber(nearestMounted);
        }
        targetInst = null;
      } else if (nearestMounted !== targetInst) {
        targetInst = null;
      }
    }
  }
  return_targetInst = targetInst;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    // Used by SimpleEventPlugin:
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    // Used by polyfills: (fall through)
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    // Only enableCreateEventHandleAPI: (fall through)
    case "beforeblur":
    case "afterblur":
    // Not used by React but could be by user code: (fall through)
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return DiscreteEventPriority;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    // Not used by React but could be by user code: (fall through)
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return ContinuousEventPriority;
    case "message": {
      const schedulerPriority = getCurrentPriorityLevel();
      switch (schedulerPriority) {
        case ImmediatePriority2:
          return DiscreteEventPriority;
        case UserBlockingPriority2:
          return ContinuousEventPriority;
        case NormalPriority2:
        case LowPriority2:
          return DefaultEventPriority;
        case IdlePriority2:
          return IdleEventPriority;
        default:
          return DefaultEventPriority;
      }
    }
    default:
      return DefaultEventPriority;
  }
}

// dist/react-dom-bindings/src/events/ReactDOMEventReplaying.js
var queuedFocus = null;
var queuedDrag = null;
var queuedMouse = null;
var queuedPointers = /* @__PURE__ */ new Map();
var queuedPointerCaptures = /* @__PURE__ */ new Map();
var queuedExplicitHydrationTargets = [];
var discreteReplayableEvents = [
  "mousedown",
  "mouseup",
  "touchcancel",
  "touchend",
  "touchstart",
  "auxclick",
  "dblclick",
  "pointercancel",
  "pointerdown",
  "pointerup",
  "dragend",
  "dragstart",
  "drop",
  "compositionend",
  "compositionstart",
  "keydown",
  "keypress",
  "keyup",
  "input",
  "textInput",
  // Intentionally camelCase
  "copy",
  "cut",
  "paste",
  "click",
  "change",
  "contextmenu",
  "reset"
  // 'submit', // stopPropagation blocks the replay mechanism
];
function isDiscreteEventThatRequiresHydration(eventType) {
  return discreteReplayableEvents.indexOf(eventType) > -1;
}
function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  return {
    blockedOn,
    domEventName,
    eventSystemFlags,
    nativeEvent,
    targetContainers: [targetContainer]
  };
}
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout": {
      const pointerId = nativeEvent.pointerId;
      queuedPointers.delete(pointerId);
      break;
    }
    case "gotpointercapture":
    case "lostpointercapture": {
      const pointerId = nativeEvent.pointerId;
      queuedPointerCaptures.delete(pointerId);
      break;
    }
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
    const queuedEvent = createQueuedReplayableEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    );
    if (blockedOn !== null) {
      const fiber = getInstanceFromNode3(blockedOn);
      if (fiber !== null) {
        attemptContinuousHydration(fiber);
      }
    }
    return queuedEvent;
  }
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  const targetContainers = existingQueuedEvent.targetContainers;
  if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
    targetContainers.push(targetContainer);
  }
  return existingQueuedEvent;
}
function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  switch (domEventName) {
    case "focusin": {
      const focusEvent = nativeEvent;
      queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
        queuedFocus,
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        focusEvent
      );
      return true;
    }
    case "dragenter": {
      const dragEvent = nativeEvent;
      queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
        queuedDrag,
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        dragEvent
      );
      return true;
    }
    case "mouseover": {
      const mouseEvent = nativeEvent;
      queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
        queuedMouse,
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        mouseEvent
      );
      return true;
    }
    case "pointerover": {
      const pointerEvent = nativeEvent;
      const pointerId = pointerEvent.pointerId;
      queuedPointers.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointers.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          pointerEvent
        )
      );
      return true;
    }
    case "gotpointercapture": {
      const pointerEvent = nativeEvent;
      const pointerId = pointerEvent.pointerId;
      queuedPointerCaptures.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointerCaptures.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          pointerEvent
        )
      );
      return true;
    }
  }
  return false;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  const targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (targetInst !== null) {
    const nearestMounted = getNearestMountedFiber(targetInst);
    if (nearestMounted !== null) {
      const tag = nearestMounted.tag;
      if (tag === SuspenseComponent) {
        const instance = getSuspenseInstanceFromFiber(nearestMounted);
        if (instance !== null) {
          queuedTarget.blockedOn = instance;
          runWithPriority(queuedTarget.priority, () => {
            attemptHydrationAtCurrentPriority(nearestMounted);
          });
          return;
        }
      } else if (tag === ActivityComponent) {
        const instance = getActivityInstanceFromFiber(nearestMounted);
        if (instance !== null) {
          queuedTarget.blockedOn = instance;
          runWithPriority(queuedTarget.priority, () => {
            attemptHydrationAtCurrentPriority(nearestMounted);
          });
          return;
        }
      } else if (tag === HostRoot) {
        const root2 = nearestMounted.stateNode;
        if (isRootDehydrated(root2)) {
          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
          return;
        }
      }
    }
  }
  queuedTarget.blockedOn = null;
}
function queueExplicitHydrationTarget(target) {
  const updatePriority = resolveUpdatePriority2();
  const queuedTarget = {
    blockedOn: null,
    target,
    priority: updatePriority
  };
  let i = 0;
  for (; i < queuedExplicitHydrationTargets.length; i++) {
    if (!isHigherEventPriority(
      updatePriority,
      queuedExplicitHydrationTargets[i].priority
    )) {
      break;
    }
  }
  queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
  if (i === 0) {
    attemptExplicitHydrationTarget(queuedTarget);
  }
}

// dist/react-dom/src/client/ReactDOMDefaultTransitionIndicator.js
function defaultOnDefaultTransitionIndicator() {
  if (typeof navigation !== "object") {
    return;
  }
  let isCancelled = false;
  let pendingResolve = null;
  function handleNavigate(event) {
    if (event.canIntercept && event.info === "react-transition") {
      event.intercept({
        handler() {
          return new Promise((resolve) => pendingResolve = resolve);
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
  }
  function handleNavigateComplete() {
    if (pendingResolve !== null) {
      pendingResolve();
      pendingResolve = null;
    }
    if (!isCancelled) {
      startFakeNavigation();
    }
  }
  navigation.addEventListener("navigate", handleNavigate);
  navigation.addEventListener("navigatesuccess", handleNavigateComplete);
  navigation.addEventListener("navigateerror", handleNavigateComplete);
  function startFakeNavigation() {
    if (isCancelled) {
      return;
    }
    if (navigation.transition) {
      return;
    }
    const currentEntry = navigation.currentEntry;
    if (currentEntry && currentEntry.url != null) {
      navigation.navigate(currentEntry.url, {
        state: currentEntry.getState(),
        info: "react-transition",
        // indicator to routers to ignore this navigation
        history: "replace"
      });
    }
  }
  setTimeout(startFakeNavigation, 100);
  return function() {
    isCancelled = true;
    navigation.removeEventListener("navigate", handleNavigate);
    navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
    navigation.removeEventListener("navigateerror", handleNavigateComplete);
    if (pendingResolve !== null) {
      pendingResolve();
      pendingResolve = null;
    }
  };
}

// dist/react-dom/src/client/ReactDOMRoot.js
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = // $FlowFixMe[missing-this-annot]
function(children) {
  const root2 = this._internalRoot;
  if (root2 === null) {
    throw new Error("Cannot update an unmounted root.");
  }
  if (false) {
    const args = arguments;
    if (typeof args[1] === "function") {
      console.error(
        "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      );
    } else if (isValidContainer(args[1])) {
      console.error(
        "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
      );
    } else if (typeof args[1] !== "undefined") {
      console.error(
        "You passed a second argument to root.render(...) but it only accepts one argument."
      );
    }
  }
  updateContainer(children, root2, null, null);
};
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = // $FlowFixMe[missing-this-annot]
function() {
  if (false) {
    const args = arguments;
    if (typeof args[0] === "function") {
      console.error(
        "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      );
    }
  }
  const root2 = this._internalRoot;
  if (root2 !== null) {
    this._internalRoot = null;
    const container = root2.containerInfo;
    if (false) {
      if (isAlreadyRendering()) {
        console.error(
          "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
        );
      }
    }
    updateContainerSync(null, root2, null, null);
    flushSyncWork();
    unmarkContainerAsRoot(container);
  }
};
function createRoot(container, options) {
  if (!isValidContainer(container)) {
    throw new Error("Target container is not a DOM element.");
  }
  warnIfReactDOMContainerInDEV(container);
  const concurrentUpdatesByDefaultOverride = false;
  let isStrictMode = false;
  let identifierPrefix = "";
  let onUncaughtError = defaultOnUncaughtError;
  let onCaughtError = defaultOnCaughtError;
  let onRecoverableError = defaultOnRecoverableError;
  let onDefaultTransitionIndicator = defaultOnDefaultTransitionIndicator;
  let transitionCallbacks = null;
  if (options !== null && options !== void 0) {
    if (false) {
      if (options.hydrate) {
        console.warn(
          "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
        );
      } else {
        if (typeof options === "object" && options !== null && options.$$typeof === REACT_ELEMENT_TYPE) {
          console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          );
        }
      }
    }
    if (options.unstable_strictMode === true) {
      isStrictMode = true;
    }
    if (options.identifierPrefix !== void 0) {
      identifierPrefix = options.identifierPrefix;
    }
    if (options.onUncaughtError !== void 0) {
      onUncaughtError = options.onUncaughtError;
    }
    if (options.onCaughtError !== void 0) {
      onCaughtError = options.onCaughtError;
    }
    if (options.onRecoverableError !== void 0) {
      onRecoverableError = options.onRecoverableError;
    }
    if (enableDefaultTransitionIndicator) {
      if (options.onDefaultTransitionIndicator !== void 0) {
        onDefaultTransitionIndicator = options.onDefaultTransitionIndicator;
      }
    }
    if (options.unstable_transitionCallbacks !== void 0) {
      transitionCallbacks = options.unstable_transitionCallbacks;
    }
  }
  const root2 = createContainer(
    container,
    ConcurrentRoot,
    null,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    transitionCallbacks
  );
  markContainerAsRoot(root2.current, container);
  const rootContainerElement = !disableCommentsAsDOMContainers && container.nodeType === COMMENT_NODE ? container.parentNode : container;
  listenToAllSupportedEvents(rootContainerElement);
  return new ReactDOMRoot(root2);
}
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
function scheduleHydration(target) {
  if (target) {
    queueExplicitHydrationTarget(target);
  }
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
function warnIfReactDOMContainerInDEV(container) {
  if (false) {
    if (isContainerMarkedAsRoot(container)) {
      if (container._reactRootContainer) {
        console.error(
          "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
        );
      } else {
        console.error(
          "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
        );
      }
    }
  }
}

// dist/react-dom/src/shared/ensureCorrectIsomorphicReactVersion.js
function ensureCorrectIsomorphicReactVersion() {
  const isomorphicReactPackageVersion = ReactVersion_default;
  if (isomorphicReactPackageVersion !== ReactVersion_default) {
    throw new Error(
      `Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ${isomorphicReactPackageVersion}
  - react-dom:  ${ReactVersion_default}
Learn more: https://react.dev/warnings/version-mismatch`
    );
  }
}

// dist/react-dom/src/client/ReactDOMClient.js
ensureCorrectIsomorphicReactVersion();
if (false) {
  if (typeof Map !== "function" || // $FlowFixMe[prop-missing] Flow incorrectly thinks Map has no prototype
  Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowFixMe[prop-missing] Flow incorrectly thinks Set has no prototype
  Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
    console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
    );
  }
}
function findDOMNode(componentOrElement) {
  return findHostInstance(componentOrElement);
}
ReactDOMSharedInternals_default2.findDOMNode = findDOMNode;
var foundDevTools = injectIntoDevTools();
if (false) {
  if (!foundDevTools && canUseDOM && window.top === window.self) {
    if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
      const protocol = window.location.protocol;
      if (/^(https?|file):$/.test(protocol)) {
        console.info(
          "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
          "font-weight:bold"
        );
      }
    }
  }
}

// src/main.js
function App() {
  console.log("App called");
  return createElement("h1", null, "Hello world!");
}
var rootElement = document.getElementById("root");
var reactRoot = createRoot(rootElement);
reactRoot.render(createElement(App));
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
//# sourceMappingURL=bundle.js.map
